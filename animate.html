<!DOCTYPE html>
<html>
  <head></head>
<body>
<div id="world"></div>

<script>
(() => {
    var t = {
        6714: function (t) {
          t.exports = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            function e(e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            }
            function n() {
              return (n =
                Object.assign ||
                function (t) {
                  for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n)
                      Object.prototype.hasOwnProperty.call(n, i) &&
                        (t[i] = n[i]);
                  }
                  return t;
                }).apply(this, arguments);
            }
            function i(t, e) {
              (t.prototype = Object.create(e.prototype)),
                (t.prototype.constructor = t),
                (t.__proto__ = e);
            }
            function r(t) {
              return (r = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  })(t);
            }
            function s(t, e) {
              return (s =
                Object.setPrototypeOf ||
                function (t, e) {
                  return (t.__proto__ = e), t;
                })(t, e);
            }
            function o(t, e, n) {
              return (o = (function () {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                  return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                  return (
                    Date.prototype.toString.call(
                      Reflect.construct(Date, [], function () {})
                    ),
                    !0
                  );
                } catch (t) {
                  return !1;
                }
              })()
                ? Reflect.construct
                : function (t, e, n) {
                    var i = [null];
                    i.push.apply(i, e);
                    var r = new (Function.bind.apply(t, i))();
                    return n && s(r, n.prototype), r;
                  }).apply(null, arguments);
            }
            function a(t) {
              var e = "function" == typeof Map ? new Map() : void 0;
              return (a = function (t) {
                if (
                  null === t ||
                  -1 === Function.toString.call(t).indexOf("[native code]")
                )
                  return t;
                if ("function" != typeof t)
                  throw new TypeError(
                    "Super expression must either be null or a function"
                  );
                if (void 0 !== e) {
                  if (e.has(t)) return e.get(t);
                  e.set(t, n);
                }
                function n() {
                  return o(t, arguments, r(this).constructor);
                }
                return (
                  (n.prototype = Object.create(t.prototype, {
                    constructor: {
                      value: n,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0,
                    },
                  })),
                  s(n, t)
                );
              })(t);
            }
            function l(t, e) {
              try {
                var n = t();
              } catch (t) {
                return e(t);
              }
              return n && n.then ? n.then(void 0, e) : n;
            }
            "undefined" != typeof Symbol &&
              (Symbol.iterator ||
                (Symbol.iterator = Symbol("Symbol.iterator"))),
              "undefined" != typeof Symbol &&
                (Symbol.asyncIterator ||
                  (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
            var c,
              u = "2.9.7",
              h = function () {};
            !(function (t) {
              (t[(t.off = 0)] = "off"),
                (t[(t.error = 1)] = "error"),
                (t[(t.warning = 2)] = "warning"),
                (t[(t.info = 3)] = "info"),
                (t[(t.debug = 4)] = "debug");
            })(c || (c = {}));
            var d = c.off,
              p = (function () {
                function t(t) {
                  this.t = t;
                }
                (t.getLevel = function () {
                  return d;
                }),
                  (t.setLevel = function (t) {
                    return (d = c[t]);
                  });
                var e = t.prototype;
                return (
                  (e.error = function () {
                    for (
                      var t = arguments.length, e = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      e[n] = arguments[n];
                    this.i(console.error, c.error, e);
                  }),
                  (e.warn = function () {
                    for (
                      var t = arguments.length, e = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      e[n] = arguments[n];
                    this.i(console.warn, c.warning, e);
                  }),
                  (e.info = function () {
                    for (
                      var t = arguments.length, e = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      e[n] = arguments[n];
                    this.i(console.info, c.info, e);
                  }),
                  (e.debug = function () {
                    for (
                      var t = arguments.length, e = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      e[n] = arguments[n];
                    this.i(console.log, c.debug, e);
                  }),
                  (e.i = function (e, n, i) {
                    n <= t.getLevel() &&
                      e.apply(console, ["[" + this.t + "] "].concat(i));
                  }),
                  t
                );
              })(),
              f = R,
              m = w,
              g = b,
              v = E,
              y = A,
              _ = "/",
              x = new RegExp(
                [
                  "(\\\\.)",
                  "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?",
                ].join("|"),
                "g"
              );
            function b(t, e) {
              for (
                var n,
                  i = [],
                  r = 0,
                  s = 0,
                  o = "",
                  a = (e && e.delimiter) || _,
                  l = (e && e.whitelist) || void 0,
                  c = !1;
                null !== (n = x.exec(t));

              ) {
                var u = n[0],
                  h = n[1],
                  d = n.index;
                if (((o += t.slice(s, d)), (s = d + u.length), h))
                  (o += h[1]), (c = !0);
                else {
                  var p = "",
                    f = n[2],
                    m = n[3],
                    g = n[4],
                    v = n[5];
                  if (!c && o.length) {
                    var y = o.length - 1,
                      b = o[y];
                    (!l || l.indexOf(b) > -1) && ((p = b), (o = o.slice(0, y)));
                  }
                  o && (i.push(o), (o = ""), (c = !1));
                  var w = m || g,
                    E = p || a;
                  i.push({
                    name: f || r++,
                    prefix: p,
                    delimiter: E,
                    optional: "?" === v || "*" === v,
                    repeat: "+" === v || "*" === v,
                    pattern: w ? M(w) : "[^" + S(E === a ? E : E + a) + "]+?",
                  });
                }
              }
              return (o || s < t.length) && i.push(o + t.substr(s)), i;
            }
            function w(t, e) {
              return function (n, i) {
                var r = t.exec(n);
                if (!r) return !1;
                for (
                  var s = r[0],
                    o = r.index,
                    a = {},
                    l = (i && i.decode) || decodeURIComponent,
                    c = 1;
                  c < r.length;
                  c++
                )
                  if (void 0 !== r[c]) {
                    var u = e[c - 1];
                    a[u.name] = u.repeat
                      ? r[c].split(u.delimiter).map(function (t) {
                          return l(t, u);
                        })
                      : l(r[c], u);
                  }
                return {
                  path: s,
                  index: o,
                  params: a,
                };
              };
            }
            function E(t, e) {
              for (var n = new Array(t.length), i = 0; i < t.length; i++)
                "object" == typeof t[i] &&
                  (n[i] = new RegExp("^(?:" + t[i].pattern + ")$", T(e)));
              return function (e, i) {
                for (
                  var r = "",
                    s = (i && i.encode) || encodeURIComponent,
                    o = !i || !1 !== i.validate,
                    a = 0;
                  a < t.length;
                  a++
                ) {
                  var l = t[a];
                  if ("string" != typeof l) {
                    var c,
                      u = e ? e[l.name] : void 0;
                    if (Array.isArray(u)) {
                      if (!l.repeat)
                        throw new TypeError(
                          'Expected "' +
                            l.name +
                            '" to not repeat, but got array'
                        );
                      if (0 === u.length) {
                        if (l.optional) continue;
                        throw new TypeError(
                          'Expected "' + l.name + '" to not be empty'
                        );
                      }
                      for (var h = 0; h < u.length; h++) {
                        if (((c = s(u[h], l)), o && !n[a].test(c)))
                          throw new TypeError(
                            'Expected all "' +
                              l.name +
                              '" to match "' +
                              l.pattern +
                              '"'
                          );
                        r += (0 === h ? l.prefix : l.delimiter) + c;
                      }
                    } else if (
                      "string" != typeof u &&
                      "number" != typeof u &&
                      "boolean" != typeof u
                    ) {
                      if (!l.optional)
                        throw new TypeError(
                          'Expected "' +
                            l.name +
                            '" to be ' +
                            (l.repeat ? "an array" : "a string")
                        );
                    } else {
                      if (((c = s(String(u), l)), o && !n[a].test(c)))
                        throw new TypeError(
                          'Expected "' +
                            l.name +
                            '" to match "' +
                            l.pattern +
                            '", but got "' +
                            c +
                            '"'
                        );
                      r += l.prefix + c;
                    }
                  } else r += l;
                }
                return r;
              };
            }
            function S(t) {
              return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
            }
            function M(t) {
              return t.replace(/([=!:$/()])/g, "\\$1");
            }
            function T(t) {
              return t && t.sensitive ? "" : "i";
            }
            function A(t, e, n) {
              for (
                var i = (n = n || {}).strict,
                  r = !1 !== n.start,
                  s = !1 !== n.end,
                  o = n.delimiter || _,
                  a = []
                    .concat(n.endsWith || [])
                    .map(S)
                    .concat("$")
                    .join("|"),
                  l = r ? "^" : "",
                  c = 0;
                c < t.length;
                c++
              ) {
                var u = t[c];
                if ("string" == typeof u) l += S(u);
                else {
                  var h = u.repeat
                    ? "(?:" +
                      u.pattern +
                      ")(?:" +
                      S(u.delimiter) +
                      "(?:" +
                      u.pattern +
                      "))*"
                    : u.pattern;
                  e && e.push(u),
                    (l += u.optional
                      ? u.prefix
                        ? "(?:" + S(u.prefix) + "(" + h + "))?"
                        : "(" + h + ")?"
                      : S(u.prefix) + "(" + h + ")");
                }
              }
              if (s)
                i || (l += "(?:" + S(o) + ")?"),
                  (l += "$" === a ? "$" : "(?=" + a + ")");
              else {
                var d = t[t.length - 1],
                  p =
                    "string" == typeof d ? d[d.length - 1] === o : void 0 === d;
                i || (l += "(?:" + S(o) + "(?=" + a + "))?"),
                  p || (l += "(?=" + S(o) + "|" + a + ")");
              }
              return new RegExp(l, T(n));
            }
            function R(t, e, n) {
              return t instanceof RegExp
                ? (function (t, e) {
                    if (!e) return t;
                    var n = t.source.match(/\((?!\?)/g);
                    if (n)
                      for (var i = 0; i < n.length; i++)
                        e.push({
                          name: i,
                          prefix: null,
                          delimiter: null,
                          optional: !1,
                          repeat: !1,
                          pattern: null,
                        });
                    return t;
                  })(t, e)
                : Array.isArray(t)
                ? (function (t, e, n) {
                    for (var i = [], r = 0; r < t.length; r++)
                      i.push(R(t[r], e, n).source);
                    return new RegExp("(?:" + i.join("|") + ")", T(n));
                  })(t, e, n)
                : (function (t, e, n) {
                    return A(b(t, n), e, n);
                  })(t, e, n);
            }
            (f.match = function (t, e) {
              var n = [];
              return w(R(t, n, e), n);
            }),
              (f.regexpToFunction = m),
              (f.parse = g),
              (f.compile = function (t, e) {
                return E(b(t, e), e);
              }),
              (f.tokensToFunction = v),
              (f.tokensToRegExp = y);
            var C = {
                container: "container",
                history: "history",
                namespace: "namespace",
                prefix: "data-barba",
                prevent: "prevent",
                wrapper: "wrapper",
              },
              L = new ((function () {
                function t() {
                  (this.o = C), (this.u = new DOMParser());
                }
                var e = t.prototype;
                return (
                  (e.toString = function (t) {
                    return t.outerHTML;
                  }),
                  (e.toDocument = function (t) {
                    return this.u.parseFromString(t, "text/html");
                  }),
                  (e.toElement = function (t) {
                    var e = document.createElement("div");
                    return (e.innerHTML = t), e;
                  }),
                  (e.getHtml = function (t) {
                    return (
                      void 0 === t && (t = document),
                      this.toString(t.documentElement)
                    );
                  }),
                  (e.getWrapper = function (t) {
                    return (
                      void 0 === t && (t = document),
                      t.querySelector(
                        "[" + this.o.prefix + '="' + this.o.wrapper + '"]'
                      )
                    );
                  }),
                  (e.getContainer = function (t) {
                    return (
                      void 0 === t && (t = document),
                      t.querySelector(
                        "[" + this.o.prefix + '="' + this.o.container + '"]'
                      )
                    );
                  }),
                  (e.removeContainer = function (t) {
                    document.body.contains(t) && t.parentNode.removeChild(t);
                  }),
                  (e.addContainer = function (t, e) {
                    var n = this.getContainer();
                    n ? this.s(t, n) : e.appendChild(t);
                  }),
                  (e.getNamespace = function (t) {
                    void 0 === t && (t = document);
                    var e = t.querySelector(
                      "[" + this.o.prefix + "-" + this.o.namespace + "]"
                    );
                    return e
                      ? e.getAttribute(this.o.prefix + "-" + this.o.namespace)
                      : null;
                  }),
                  (e.getHref = function (t) {
                    if (t.tagName && "a" === t.tagName.toLowerCase()) {
                      if ("string" == typeof t.href) return t.href;
                      var e =
                        t.getAttribute("href") || t.getAttribute("xlink:href");
                      if (e) return this.resolveUrl(e.baseVal || e);
                    }
                    return null;
                  }),
                  (e.resolveUrl = function () {
                    for (
                      var t = arguments.length, e = new Array(t), n = 0;
                      n < t;
                      n++
                    )
                      e[n] = arguments[n];
                    var i = e.length;
                    if (0 === i)
                      throw new Error(
                        "resolveUrl requires at least one argument; got none."
                      );
                    var r = document.createElement("base");
                    if (((r.href = arguments[0]), 1 === i)) return r.href;
                    var s = document.getElementsByTagName("head")[0];
                    s.insertBefore(r, s.firstChild);
                    for (
                      var o, a = document.createElement("a"), l = 1;
                      l < i;
                      l++
                    )
                      (a.href = arguments[l]), (r.href = o = a.href);
                    return s.removeChild(r), o;
                  }),
                  (e.s = function (t, e) {
                    e.parentNode.insertBefore(t, e.nextSibling);
                  }),
                  t
                );
              })())(),
              P = new ((function () {
                function t() {
                  (this.h = []), (this.v = -1);
                }
                var i = t.prototype;
                return (
                  (i.init = function (t, e) {
                    this.l = "barba";
                    var n = {
                      ns: e,
                      scroll: {
                        x: window.scrollX,
                        y: window.scrollY,
                      },
                      url: t,
                    };
                    this.h.push(n), (this.v = 0);
                    var i = {
                      from: this.l,
                      index: 0,
                      states: [].concat(this.h),
                    };
                    window.history && window.history.replaceState(i, "", t);
                  }),
                  (i.change = function (t, e, n) {
                    if (n && n.state) {
                      var i = n.state,
                        r = i.index;
                      (e = this.m(this.v - r)),
                        this.replace(i.states),
                        (this.v = r);
                    } else this.add(t, e);
                    return e;
                  }),
                  (i.add = function (t, e) {
                    var n = this.size,
                      i = this.p(e),
                      r = {
                        ns: "tmp",
                        scroll: {
                          x: window.scrollX,
                          y: window.scrollY,
                        },
                        url: t,
                      };
                    this.h.push(r), (this.v = n);
                    var s = {
                      from: this.l,
                      index: n,
                      states: [].concat(this.h),
                    };
                    switch (i) {
                      case "push":
                        window.history && window.history.pushState(s, "", t);
                        break;
                      case "replace":
                        window.history && window.history.replaceState(s, "", t);
                    }
                  }),
                  (i.update = function (t, e) {
                    var i = e || this.v,
                      r = n({}, this.get(i), {}, t);
                    this.set(i, r);
                  }),
                  (i.remove = function (t) {
                    t ? this.h.splice(t, 1) : this.h.pop(), this.v--;
                  }),
                  (i.clear = function () {
                    (this.h = []), (this.v = -1);
                  }),
                  (i.replace = function (t) {
                    this.h = t;
                  }),
                  (i.get = function (t) {
                    return this.h[t];
                  }),
                  (i.set = function (t, e) {
                    return (this.h[t] = e);
                  }),
                  (i.p = function (t) {
                    var e = "push",
                      n = t,
                      i = C.prefix + "-" + C.history;
                    return (
                      n.hasAttribute &&
                        n.hasAttribute(i) &&
                        (e = n.getAttribute(i)),
                      e
                    );
                  }),
                  (i.m = function (t) {
                    return Math.abs(t) > 1
                      ? t > 0
                        ? "forward"
                        : "back"
                      : 0 === t
                      ? "popstate"
                      : t > 0
                      ? "back"
                      : "forward";
                  }),
                  e(t, [
                    {
                      key: "current",
                      get: function () {
                        return this.h[this.v];
                      },
                    },
                    {
                      key: "state",
                      get: function () {
                        return this.h[this.h.length - 1];
                      },
                    },
                    {
                      key: "previous",
                      get: function () {
                        return this.v < 1 ? null : this.h[this.v - 1];
                      },
                    },
                    {
                      key: "size",
                      get: function () {
                        return this.h.length;
                      },
                    },
                  ]),
                  t
                );
              })())(),
              O = function (t, e) {
                try {
                  var n = (function () {
                    if (!e.next.html)
                      return Promise.resolve(t).then(function (t) {
                        var n = e.next;
                        if (t) {
                          var i = L.toElement(t);
                          (n.namespace = L.getNamespace(i)),
                            (n.container = L.getContainer(i)),
                            (n.html = t),
                            P.update({
                              ns: n.namespace,
                            });
                          var r = L.toDocument(t);
                          document.title = r.title;
                        }
                      });
                  })();
                  return Promise.resolve(
                    n && n.then ? n.then(function () {}) : void 0
                  );
                } catch (t) {
                  return Promise.reject(t);
                }
              },
              I = f,
              N = {
                __proto__: null,
                update: O,
                nextTick: function () {
                  return new Promise(function (t) {
                    window.requestAnimationFrame(t);
                  });
                },
                pathToRegexp: I,
              },
              D = function () {
                return window.location.origin;
              },
              U = function (t) {
                return void 0 === t && (t = window.location.href), F(t).port;
              },
              F = function (t) {
                var e,
                  n = t.match(/:\d+/);
                if (null === n)
                  /^http/.test(t) && (e = 80), /^https/.test(t) && (e = 443);
                else {
                  var i = n[0].substring(1);
                  e = parseInt(i, 10);
                }
                var r,
                  s = t.replace(D(), ""),
                  o = {},
                  a = s.indexOf("#");
                a >= 0 && ((r = s.slice(a + 1)), (s = s.slice(0, a)));
                var l = s.indexOf("?");
                return (
                  l >= 0 && ((o = k(s.slice(l + 1))), (s = s.slice(0, l))),
                  {
                    hash: r,
                    path: s,
                    port: e,
                    query: o,
                  }
                );
              },
              k = function (t) {
                return t.split("&").reduce(function (t, e) {
                  var n = e.split("=");
                  return (t[n[0]] = n[1]), t;
                }, {});
              },
              B = function (t) {
                return (
                  void 0 === t && (t = window.location.href),
                  t.replace(/(\/#.*|\/|#.*)$/, "")
                );
              },
              z = {
                __proto__: null,
                getHref: function () {
                  return window.location.href;
                },
                getOrigin: D,
                getPort: U,
                getPath: function (t) {
                  return void 0 === t && (t = window.location.href), F(t).path;
                },
                parse: F,
                parseQuery: k,
                clean: B,
              };
            function H(t, e, n) {
              return (
                void 0 === e && (e = 2e3),
                new Promise(function (i, r) {
                  var s = new XMLHttpRequest();
                  (s.onreadystatechange = function () {
                    if (s.readyState === XMLHttpRequest.DONE)
                      if (200 === s.status) i(s.responseText);
                      else if (s.status) {
                        var e = {
                          status: s.status,
                          statusText: s.statusText,
                        };
                        n(t, e), r(e);
                      }
                  }),
                    (s.ontimeout = function () {
                      var i = new Error("Timeout error [" + e + "]");
                      n(t, i), r(i);
                    }),
                    (s.onerror = function () {
                      var e = new Error("Fetch error");
                      n(t, e), r(e);
                    }),
                    s.open("GET", t),
                    (s.timeout = e),
                    s.setRequestHeader(
                      "Accept",
                      "text/html,application/xhtml+xml,application/xml"
                    ),
                    s.setRequestHeader("x-barba", "yes"),
                    s.send();
                })
              );
            }
            var V = function (t) {
              return (
                !!t &&
                ("object" == typeof t || "function" == typeof t) &&
                "function" == typeof t.then
              );
            };
            function G(t, e) {
              return (
                void 0 === e && (e = {}),
                function () {
                  for (
                    var n = arguments.length, i = new Array(n), r = 0;
                    r < n;
                    r++
                  )
                    i[r] = arguments[r];
                  var s = !1,
                    o = new Promise(function (n, r) {
                      e.async = function () {
                        return (
                          (s = !0),
                          function (t, e) {
                            t ? r(t) : n(e);
                          }
                        );
                      };
                      var o = t.apply(e, i);
                      s || (V(o) ? o.then(n, r) : n(o));
                    });
                  return o;
                }
              );
            }
            var W = new ((function (t) {
                function e() {
                  var e;
                  return (
                    ((e = t.call(this) || this).logger = new p("@barba/core")),
                    (e.all = [
                      "ready",
                      "page",
                      "reset",
                      "currentAdded",
                      "currentRemoved",
                      "nextAdded",
                      "nextRemoved",
                      "beforeOnce",
                      "once",
                      "afterOnce",
                      "before",
                      "beforeLeave",
                      "leave",
                      "afterLeave",
                      "beforeEnter",
                      "enter",
                      "afterEnter",
                      "after",
                    ]),
                    (e.registered = new Map()),
                    e.init(),
                    e
                  );
                }
                i(e, t);
                var n = e.prototype;
                return (
                  (n.init = function () {
                    var t = this;
                    this.registered.clear(),
                      this.all.forEach(function (e) {
                        t[e] ||
                          (t[e] = function (n, i) {
                            t.registered.has(e) ||
                              t.registered.set(e, new Set()),
                              t.registered.get(e).add({
                                ctx: i || {},
                                fn: n,
                              });
                          });
                      });
                  }),
                  (n.do = function (t) {
                    for (
                      var e = this,
                        n = arguments.length,
                        i = new Array(n > 1 ? n - 1 : 0),
                        r = 1;
                      r < n;
                      r++
                    )
                      i[r - 1] = arguments[r];
                    if (this.registered.has(t)) {
                      var s = Promise.resolve();
                      return (
                        this.registered.get(t).forEach(function (t) {
                          s = s.then(function () {
                            return G(t.fn, t.ctx).apply(void 0, i);
                          });
                        }),
                        s.catch(function (n) {
                          e.logger.debug("Hook error [" + t + "]"),
                            e.logger.error(n);
                        })
                      );
                    }
                    return Promise.resolve();
                  }),
                  (n.clear = function () {
                    var t = this;
                    this.all.forEach(function (e) {
                      delete t[e];
                    }),
                      this.init();
                  }),
                  (n.help = function () {
                    this.logger.info("Available hooks: " + this.all.join(","));
                    var t = [];
                    this.registered.forEach(function (e, n) {
                      return t.push(n);
                    }),
                      this.logger.info("Registered hooks: " + t.join(","));
                  }),
                  e
                );
              })(h))(),
              j = (function () {
                function t(t) {
                  if (((this.P = []), "boolean" == typeof t)) this.g = t;
                  else {
                    var e = Array.isArray(t) ? t : [t];
                    this.P = e.map(function (t) {
                      return I(t);
                    });
                  }
                }
                return (
                  (t.prototype.checkHref = function (t) {
                    if ("boolean" == typeof this.g) return this.g;
                    var e = F(t).path;
                    return this.P.some(function (t) {
                      return null !== t.exec(e);
                    });
                  }),
                  t
                );
              })(),
              q = (function (t) {
                function e(e) {
                  var n;
                  return ((n = t.call(this, e) || this).k = new Map()), n;
                }
                i(e, t);
                var r = e.prototype;
                return (
                  (r.set = function (t, e, n) {
                    return (
                      this.k.set(t, {
                        action: n,
                        request: e,
                      }),
                      {
                        action: n,
                        request: e,
                      }
                    );
                  }),
                  (r.get = function (t) {
                    return this.k.get(t);
                  }),
                  (r.getRequest = function (t) {
                    return this.k.get(t).request;
                  }),
                  (r.getAction = function (t) {
                    return this.k.get(t).action;
                  }),
                  (r.has = function (t) {
                    return !this.checkHref(t) && this.k.has(t);
                  }),
                  (r.delete = function (t) {
                    return this.k.delete(t);
                  }),
                  (r.update = function (t, e) {
                    var i = n({}, this.k.get(t), {}, e);
                    return this.k.set(t, i), i;
                  }),
                  e
                );
              })(j),
              X = function () {
                return !window.history.pushState;
              },
              Y = function (t) {
                return !t.el || !t.href;
              },
              K = function (t) {
                var e = t.event;
                return (
                  e.which > 1 ||
                  e.metaKey ||
                  e.ctrlKey ||
                  e.shiftKey ||
                  e.altKey
                );
              },
              $ = function (t) {
                var e = t.el;
                return e.hasAttribute("target") && "_blank" === e.target;
              },
              Z = function (t) {
                var e = t.el;
                return (
                  (void 0 !== e.protocol &&
                    window.location.protocol !== e.protocol) ||
                  (void 0 !== e.hostname &&
                    window.location.hostname !== e.hostname)
                );
              },
              J = function (t) {
                var e = t.el;
                return void 0 !== e.port && U() !== U(e.href);
              },
              Q = function (t) {
                var e = t.el;
                return (
                  e.getAttribute &&
                  "string" == typeof e.getAttribute("download")
                );
              },
              tt = function (t) {
                return t.el.hasAttribute(C.prefix + "-" + C.prevent);
              },
              et = function (t) {
                return Boolean(
                  t.el.closest("[" + C.prefix + "-" + C.prevent + '="all"]')
                );
              },
              nt = function (t) {
                var e = t.href;
                return B(e) === B() && U(e) === U();
              },
              it = (function (t) {
                function e(e) {
                  var n;
                  return (
                    ((n = t.call(this, e) || this).suite = []),
                    (n.tests = new Map()),
                    n.init(),
                    n
                  );
                }
                i(e, t);
                var n = e.prototype;
                return (
                  (n.init = function () {
                    this.add("pushState", X),
                      this.add("exists", Y),
                      this.add("newTab", K),
                      this.add("blank", $),
                      this.add("corsDomain", Z),
                      this.add("corsPort", J),
                      this.add("download", Q),
                      this.add("preventSelf", tt),
                      this.add("preventAll", et),
                      this.add("sameUrl", nt, !1);
                  }),
                  (n.add = function (t, e, n) {
                    void 0 === n && (n = !0),
                      this.tests.set(t, e),
                      n && this.suite.push(t);
                  }),
                  (n.run = function (t, e, n, i) {
                    return this.tests.get(t)({
                      el: e,
                      event: n,
                      href: i,
                    });
                  }),
                  (n.checkLink = function (t, e, n) {
                    var i = this;
                    return this.suite.some(function (r) {
                      return i.run(r, t, e, n);
                    });
                  }),
                  e
                );
              })(j),
              rt = (function (t) {
                function e(n, i) {
                  var r;
                  void 0 === i && (i = "Barba error");
                  for (
                    var s = arguments.length,
                      o = new Array(s > 2 ? s - 2 : 0),
                      a = 2;
                    a < s;
                    a++
                  )
                    o[a - 2] = arguments[a];
                  return (
                    ((r = t.call.apply(t, [this].concat(o)) || this).error = n),
                    (r.label = i),
                    Error.captureStackTrace &&
                      Error.captureStackTrace(
                        (function (t) {
                          if (void 0 === t)
                            throw new ReferenceError(
                              "this hasn't been initialised - super() hasn't been called"
                            );
                          return t;
                        })(r),
                        e
                      ),
                    (r.name = "BarbaError"),
                    r
                  );
                }
                return i(e, t), e;
              })(a(Error)),
              st = (function () {
                function t(t) {
                  void 0 === t && (t = []),
                    (this.logger = new p("@barba/core")),
                    (this.all = []),
                    (this.page = []),
                    (this.once = []),
                    (this.A = [
                      {
                        name: "namespace",
                        type: "strings",
                      },
                      {
                        name: "custom",
                        type: "function",
                      },
                    ]),
                    t && (this.all = this.all.concat(t)),
                    this.update();
                }
                var e = t.prototype;
                return (
                  (e.add = function (t, e) {
                    "rule" === t
                      ? this.A.splice(e.position || 0, 0, e.value)
                      : this.all.push(e),
                      this.update();
                  }),
                  (e.resolve = function (t, e) {
                    var n = this;
                    void 0 === e && (e = {});
                    var i = e.once ? this.once : this.page;
                    i = i.filter(
                      e.self
                        ? function (t) {
                            return t.name && "self" === t.name;
                          }
                        : function (t) {
                            return !t.name || "self" !== t.name;
                          }
                    );
                    var r = new Map(),
                      s = i.find(function (i) {
                        var s = !0,
                          o = {};
                        return (
                          !(!e.self || "self" !== i.name) ||
                          (n.A.reverse().forEach(function (e) {
                            s &&
                              ((s = n.R(i, e, t, o)),
                              i.from &&
                                i.to &&
                                (s =
                                  n.R(i, e, t, o, "from") &&
                                  n.R(i, e, t, o, "to")),
                              i.from && !i.to && (s = n.R(i, e, t, o, "from")),
                              !i.from && i.to && (s = n.R(i, e, t, o, "to")));
                          }),
                          r.set(i, o),
                          s)
                        );
                      }),
                      o = r.get(s),
                      a = [];
                    if (
                      (a.push(e.once ? "once" : "page"),
                      e.self && a.push("self"),
                      o)
                    ) {
                      var l,
                        c = [s];
                      Object.keys(o).length > 0 && c.push(o),
                        (l = this.logger).info.apply(
                          l,
                          ["Transition found [" + a.join(",") + "]"].concat(c)
                        );
                    } else
                      this.logger.info(
                        "No transition found [" + a.join(",") + "]"
                      );
                    return s;
                  }),
                  (e.update = function () {
                    var t = this;
                    (this.all = this.all
                      .map(function (e) {
                        return t.T(e);
                      })
                      .sort(function (t, e) {
                        return t.priority - e.priority;
                      })
                      .reverse()
                      .map(function (t) {
                        return delete t.priority, t;
                      })),
                      (this.page = this.all.filter(function (t) {
                        return void 0 !== t.leave || void 0 !== t.enter;
                      })),
                      (this.once = this.all.filter(function (t) {
                        return void 0 !== t.once;
                      }));
                  }),
                  (e.R = function (t, e, n, i, r) {
                    var s = !0,
                      o = !1,
                      a = t,
                      l = e.name,
                      c = l,
                      u = l,
                      h = l,
                      d = r ? a[r] : a,
                      p = "to" === r ? n.next : n.current;
                    if (r ? d && d[l] : d[l]) {
                      switch (e.type) {
                        case "strings":
                        default:
                          var f = Array.isArray(d[c]) ? d[c] : [d[c]];
                          p[c] && -1 !== f.indexOf(p[c]) && (o = !0),
                            -1 === f.indexOf(p[c]) && (s = !1);
                          break;
                        case "object":
                          var m = Array.isArray(d[u]) ? d[u] : [d[u]];
                          p[u]
                            ? (p[u].name &&
                                -1 !== m.indexOf(p[u].name) &&
                                (o = !0),
                              -1 === m.indexOf(p[u].name) && (s = !1))
                            : (s = !1);
                          break;
                        case "function":
                          d[h](n) ? (o = !0) : (s = !1);
                      }
                      o &&
                        (r
                          ? ((i[r] = i[r] || {}), (i[r][l] = a[r][l]))
                          : (i[l] = a[l]));
                    }
                    return s;
                  }),
                  (e.O = function (t, e, n) {
                    var i = 0;
                    return (
                      (t[e] || (t.from && t.from[e]) || (t.to && t.to[e])) &&
                        ((i += Math.pow(10, n)),
                        t.from && t.from[e] && (i += 1),
                        t.to && t.to[e] && (i += 2)),
                      i
                    );
                  }),
                  (e.T = function (t) {
                    var e = this;
                    t.priority = 0;
                    var n = 0;
                    return (
                      this.A.forEach(function (i, r) {
                        n += e.O(t, i.name, r + 1);
                      }),
                      (t.priority = n),
                      t
                    );
                  }),
                  t
                );
              })(),
              ot = (function () {
                function t(t) {
                  void 0 === t && (t = []),
                    (this.logger = new p("@barba/core")),
                    (this.S = !1),
                    (this.store = new st(t));
                }
                var n = t.prototype;
                return (
                  (n.get = function (t, e) {
                    return this.store.resolve(t, e);
                  }),
                  (n.doOnce = function (t) {
                    var e = t.data,
                      n = t.transition;
                    try {
                      var i = function () {
                          r.S = !1;
                        },
                        r = this,
                        s = n || {};
                      r.S = !0;
                      var o = l(
                        function () {
                          return Promise.resolve(r.j("beforeOnce", e, s)).then(
                            function () {
                              return Promise.resolve(r.once(e, s)).then(
                                function () {
                                  return Promise.resolve(
                                    r.j("afterOnce", e, s)
                                  ).then(function () {});
                                }
                              );
                            }
                          );
                        },
                        function (t) {
                          (r.S = !1),
                            r.logger.debug(
                              "Transition error [before/after/once]"
                            ),
                            r.logger.error(t);
                        }
                      );
                      return Promise.resolve(o && o.then ? o.then(i) : i());
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.doPage = function (t) {
                    var e = t.data,
                      n = t.transition,
                      i = t.page,
                      r = t.wrapper;
                    try {
                      var s = function (t) {
                          if (o) return t;
                          a.S = !1;
                        },
                        o = !1,
                        a = this,
                        c = n || {},
                        u = !0 === c.sync || !1;
                      a.S = !0;
                      var h = l(
                        function () {
                          function t() {
                            return Promise.resolve(a.j("before", e, c)).then(
                              function () {
                                var t = !1;
                                function n(n) {
                                  return t
                                    ? n
                                    : Promise.resolve(a.remove(e)).then(
                                        function () {
                                          return Promise.resolve(
                                            a.j("after", e, c)
                                          ).then(function () {});
                                        }
                                      );
                                }
                                var s = (function () {
                                  if (u)
                                    return l(
                                      function () {
                                        return Promise.resolve(
                                          a.add(e, r)
                                        ).then(function () {
                                          return Promise.resolve(
                                            a.j("beforeLeave", e, c)
                                          ).then(function () {
                                            return Promise.resolve(
                                              a.j("beforeEnter", e, c)
                                            ).then(function () {
                                              return Promise.resolve(
                                                Promise.all([
                                                  a.leave(e, c),
                                                  a.enter(e, c),
                                                ])
                                              ).then(function () {
                                                return Promise.resolve(
                                                  a.j("afterLeave", e, c)
                                                ).then(function () {
                                                  return Promise.resolve(
                                                    a.j("afterEnter", e, c)
                                                  ).then(function () {});
                                                });
                                              });
                                            });
                                          });
                                        });
                                      },
                                      function (t) {
                                        if (a.M(t))
                                          throw new rt(
                                            t,
                                            "Transition error [sync]"
                                          );
                                      }
                                    );
                                  var n = function (n) {
                                      return t
                                        ? n
                                        : l(
                                            function () {
                                              var t = (function () {
                                                if (!1 !== s)
                                                  return Promise.resolve(
                                                    a.add(e, r)
                                                  ).then(function () {
                                                    return Promise.resolve(
                                                      a.j("beforeEnter", e, c)
                                                    ).then(function () {
                                                      return Promise.resolve(
                                                        a.enter(e, c, s)
                                                      ).then(function () {
                                                        return Promise.resolve(
                                                          a.j(
                                                            "afterEnter",
                                                            e,
                                                            c
                                                          )
                                                        ).then(function () {});
                                                      });
                                                    });
                                                  });
                                              })();
                                              if (t && t.then)
                                                return t.then(function () {});
                                            },
                                            function (t) {
                                              if (a.M(t))
                                                throw new rt(
                                                  t,
                                                  "Transition error [before/after/enter]"
                                                );
                                            }
                                          );
                                    },
                                    s = !1,
                                    o = l(
                                      function () {
                                        return Promise.resolve(
                                          a.j("beforeLeave", e, c)
                                        ).then(function () {
                                          return Promise.resolve(
                                            Promise.all([
                                              a.leave(e, c),
                                              O(i, e),
                                            ]).then(function (t) {
                                              return t[0];
                                            })
                                          ).then(function (t) {
                                            return (
                                              (s = t),
                                              Promise.resolve(
                                                a.j("afterLeave", e, c)
                                              ).then(function () {})
                                            );
                                          });
                                        });
                                      },
                                      function (t) {
                                        if (a.M(t))
                                          throw new rt(
                                            t,
                                            "Transition error [before/after/leave]"
                                          );
                                      }
                                    );
                                  return o && o.then ? o.then(n) : n(o);
                                })();
                                return s && s.then ? s.then(n) : n(s);
                              }
                            );
                          }
                          var n = (function () {
                            if (u)
                              return Promise.resolve(O(i, e)).then(
                                function () {}
                              );
                          })();
                          return n && n.then ? n.then(t) : t();
                        },
                        function (t) {
                          if (((a.S = !1), t.name && "BarbaError" === t.name))
                            throw (
                              (a.logger.debug(t.label),
                              a.logger.error(t.error),
                              t)
                            );
                          throw (
                            (a.logger.debug("Transition error [page]"),
                            a.logger.error(t),
                            t)
                          );
                        }
                      );
                      return Promise.resolve(h && h.then ? h.then(s) : s(h));
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.once = function (t, e) {
                    try {
                      return Promise.resolve(W.do("once", t, e)).then(
                        function () {
                          return e.once ? G(e.once, e)(t) : Promise.resolve();
                        }
                      );
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.leave = function (t, e) {
                    try {
                      return Promise.resolve(W.do("leave", t, e)).then(
                        function () {
                          return e.leave ? G(e.leave, e)(t) : Promise.resolve();
                        }
                      );
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.enter = function (t, e, n) {
                    try {
                      return Promise.resolve(W.do("enter", t, e)).then(
                        function () {
                          return e.enter
                            ? G(e.enter, e)(t, n)
                            : Promise.resolve();
                        }
                      );
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.add = function (t, e) {
                    try {
                      return (
                        L.addContainer(t.next.container, e),
                        W.do("nextAdded", t),
                        Promise.resolve()
                      );
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.remove = function (t) {
                    try {
                      return (
                        L.removeContainer(t.current.container),
                        W.do("currentRemoved", t),
                        Promise.resolve()
                      );
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  (n.M = function (t) {
                    return t.message
                      ? !/Timeout error|Fetch error/.test(t.message)
                      : !t.status;
                  }),
                  (n.j = function (t, e, n) {
                    try {
                      return Promise.resolve(W.do(t, e, n)).then(function () {
                        return n[t] ? G(n[t], n)(e) : Promise.resolve();
                      });
                    } catch (t) {
                      return Promise.reject(t);
                    }
                  }),
                  e(t, [
                    {
                      key: "isRunning",
                      get: function () {
                        return this.S;
                      },
                      set: function (t) {
                        this.S = t;
                      },
                    },
                    {
                      key: "hasOnce",
                      get: function () {
                        return this.store.once.length > 0;
                      },
                    },
                    {
                      key: "hasSelf",
                      get: function () {
                        return this.store.all.some(function (t) {
                          return "self" === t.name;
                        });
                      },
                    },
                    {
                      key: "shouldWait",
                      get: function () {
                        return this.store.all.some(function (t) {
                          return (t.to && !t.to.route) || t.sync;
                        });
                      },
                    },
                  ]),
                  t
                );
              })(),
              at = (function () {
                function t(t) {
                  var e = this;
                  (this.names = [
                    "beforeLeave",
                    "afterLeave",
                    "beforeEnter",
                    "afterEnter",
                  ]),
                    (this.byNamespace = new Map()),
                    0 !== t.length &&
                      (t.forEach(function (t) {
                        e.byNamespace.set(t.namespace, t);
                      }),
                      this.names.forEach(function (t) {
                        W[t](e.L(t));
                      }));
                }
                return (
                  (t.prototype.L = function (t) {
                    var e = this;
                    return function (n) {
                      var i = t.match(/enter/i) ? n.next : n.current,
                        r = e.byNamespace.get(i.namespace);
                      return r && r[t] ? G(r[t], r)(n) : Promise.resolve();
                    };
                  }),
                  t
                );
              })();
            Element.prototype.matches ||
              (Element.prototype.matches =
                Element.prototype.msMatchesSelector ||
                Element.prototype.webkitMatchesSelector),
              Element.prototype.closest ||
                (Element.prototype.closest = function (t) {
                  var e = this;
                  do {
                    if (e.matches(t)) return e;
                    e = e.parentElement || e.parentNode;
                  } while (null !== e && 1 === e.nodeType);
                  return null;
                });
            var lt = {
              container: null,
              html: "",
              namespace: "",
              url: {
                hash: "",
                href: "",
                path: "",
                port: null,
                query: {},
              },
            };
            return new ((function () {
              function t() {
                (this.version = u),
                  (this.schemaPage = lt),
                  (this.Logger = p),
                  (this.logger = new p("@barba/core")),
                  (this.plugins = []),
                  (this.hooks = W),
                  (this.dom = L),
                  (this.helpers = N),
                  (this.history = P),
                  (this.request = H),
                  (this.url = z);
              }
              var i = t.prototype;
              return (
                (i.use = function (t, e) {
                  var n = this.plugins;
                  n.indexOf(t) > -1
                    ? this.logger.warn(
                        "Plugin [" + t.name + "] already installed."
                      )
                    : "function" == typeof t.install
                    ? (t.install(this, e), n.push(t))
                    : this.logger.warn(
                        "Plugin [" + t.name + '] has no "install" method.'
                      );
                }),
                (i.init = function (t) {
                  var e = void 0 === t ? {} : t,
                    i = e.transitions,
                    r = void 0 === i ? [] : i,
                    s = e.views,
                    o = void 0 === s ? [] : s,
                    a = e.schema,
                    l = void 0 === a ? C : a,
                    c = e.requestError,
                    u = e.timeout,
                    h = void 0 === u ? 2e3 : u,
                    d = e.cacheIgnore,
                    f = void 0 !== d && d,
                    m = e.prefetchIgnore,
                    g = void 0 !== m && m,
                    v = e.preventRunning,
                    y = void 0 !== v && v,
                    _ = e.prevent,
                    x = void 0 === _ ? null : _,
                    b = e.debug,
                    w = e.logLevel;
                  if (
                    (p.setLevel(
                      !0 === (void 0 !== b && b)
                        ? "debug"
                        : void 0 === w
                        ? "off"
                        : w
                    ),
                    this.logger.info(this.version),
                    Object.keys(l).forEach(function (t) {
                      C[t] && (C[t] = l[t]);
                    }),
                    (this.$ = c),
                    (this.timeout = h),
                    (this.cacheIgnore = f),
                    (this.prefetchIgnore = g),
                    (this.preventRunning = y),
                    (this._ = this.dom.getWrapper()),
                    !this._)
                  )
                    throw new Error("[@barba/core] No Barba wrapper found"); 
                  this._.setAttribute("aria-live", "polite"), this.q();
                  var E = this.data.current;
                  if (!E.container)
                    throw new Error("[@barba/core] No Barba container found"); 
                  if (
                    ((this.cache = new q(f)),
                    (this.prevent = new it(g)),
                    (this.transitions = new ot(r)),
                    (this.views = new at(o)),
                    null !== x)
                  ) {
                    if ("function" != typeof x)
                      throw new Error(
                        "[@barba/core] Prevent should be a function"
                      );
                    this.prevent.add("preventCustom", x);
                  }
                  this.history.init(E.url.href, E.namespace),
                    (this.B = this.B.bind(this)),
                    (this.U = this.U.bind(this)),
                    (this.D = this.D.bind(this)),
                    this.F(),
                    this.plugins.forEach(function (t) {
                      return t.init();
                    });
                  var S = this.data;
                  (S.trigger = "barba"),
                    (S.next = S.current),
                    (S.current = n({}, this.schemaPage)),
                    this.hooks.do("ready", S),
                    this.once(S),
                    this.q();
                }),
                (i.destroy = function () {
                  this.q(),
                    this.H(),
                    this.history.clear(),
                    this.hooks.clear(),
                    (this.plugins = []);
                }),
                (i.force = function (t) {
                  window.location.assign(t);
                }),
                (i.go = function (t, e, n) {
                  var i;
                  if (
                    (void 0 === e && (e = "barba"), this.transitions.isRunning)
                  )
                    this.force(t);
                  else if (
                    !(i =
                      "popstate" === e
                        ? this.history.current &&
                          this.url.getPath(this.history.current.url) ===
                            this.url.getPath(t)
                        : this.prevent.run("sameUrl", null, null, t)) ||
                    this.transitions.hasSelf
                  )
                    return (
                      (e = this.history.change(t, e, n)),
                      n && (n.stopPropagation(), n.preventDefault()),
                      this.page(t, e, i)
                    );
                }),
                (i.once = function (t) {
                  try {
                    var e = this;
                    return Promise.resolve(e.hooks.do("beforeEnter", t)).then(
                      function () {
                        function n() {
                          return Promise.resolve(
                            e.hooks.do("afterEnter", t)
                          ).then(function () {});
                        }
                        var i = (function () {
                          if (e.transitions.hasOnce) {
                            var n = e.transitions.get(t, {
                              once: !0,
                            });
                            return Promise.resolve(
                              e.transitions.doOnce({
                                transition: n,
                                data: t,
                              })
                            ).then(function () {});
                          }
                        })();
                        return i && i.then ? i.then(n) : n();
                      }
                    );
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (i.page = function (t, e, i) {
                  try {
                    var r = function () {
                        var t = s.data;
                        return Promise.resolve(s.hooks.do("page", t)).then(
                          function () {
                            var e = l(
                              function () {
                                var e = s.transitions.get(t, {
                                  once: !1,
                                  self: i,
                                });
                                return Promise.resolve(
                                  s.transitions.doPage({
                                    data: t,
                                    page: o,
                                    transition: e,
                                    wrapper: s._,
                                  })
                                ).then(function () {
                                  s.q();
                                });
                              },
                              function () {
                                0 === p.getLevel() &&
                                  s.force(t.current.url.href);
                              }
                            );
                            if (e && e.then) return e.then(function () {});
                          }
                        );
                      },
                      s = this;
                    (s.data.next.url = n(
                      {
                        href: t,
                      },
                      s.url.parse(t)
                    )),
                      (s.data.trigger = e);
                    var o = s.cache.has(t)
                        ? s.cache.update(t, {
                            action: "click",
                          }).request
                        : s.cache.set(
                            t,
                            s.request(
                              t,
                              s.timeout,
                              s.onRequestError.bind(s, e)
                            ),
                            "click"
                          ).request,
                      a = (function () {
                        if (s.transitions.shouldWait)
                          return Promise.resolve(O(o, s.data)).then(
                            function () {}
                          );
                      })();
                    return Promise.resolve(a && a.then ? a.then(r) : r());
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (i.onRequestError = function (t) {
                  this.transitions.isRunning = !1;
                  for (
                    var e = arguments.length,
                      n = new Array(e > 1 ? e - 1 : 0),
                      i = 1;
                    i < e;
                    i++
                  )
                    n[i - 1] = arguments[i];
                  var r = n[0],
                    s = n[1],
                    o = this.cache.getAction(r);
                  return (
                    this.cache.delete(r),
                    !(
                      (this.$ && !1 === this.$(t, o, r, s)) ||
                      ("click" === o && this.force(r), 1)
                    )
                  );
                }),
                (i.prefetch = function (t) {
                  var e = this;
                  this.cache.has(t) ||
                    this.cache.set(
                      t,
                      this.request(
                        t,
                        this.timeout,
                        this.onRequestError.bind(this, "barba")
                      ).catch(function (t) {
                        e.logger.error(t);
                      }),
                      "prefetch"
                    );
                }),
                (i.F = function () {
                  !0 !== this.prefetchIgnore &&
                    (document.addEventListener("mouseover", this.B),
                    document.addEventListener("touchstart", this.B)),
                    document.addEventListener("click", this.U),
                    window.addEventListener("popstate", this.D);
                }),
                (i.H = function () {
                  !0 !== this.prefetchIgnore &&
                    (document.removeEventListener("mouseover", this.B),
                    document.removeEventListener("touchstart", this.B)),
                    document.removeEventListener("click", this.U),
                    window.removeEventListener("popstate", this.D);
                }),
                (i.B = function (t) {
                  var e = this,
                    n = this.I(t);
                  if (n) {
                    var i = this.dom.getHref(n);
                    this.prevent.checkHref(i) ||
                      this.cache.has(i) ||
                      this.cache.set(
                        i,
                        this.request(
                          i,
                          this.timeout,
                          this.onRequestError.bind(this, n)
                        ).catch(function (t) {
                          e.logger.error(t);
                        }),
                        "enter"
                      );
                  }
                }),
                (i.U = function (t) {
                  var e = this.I(t);
                  if (e)
                    return this.transitions.isRunning && this.preventRunning
                      ? (t.preventDefault(), void t.stopPropagation())
                      : void this.go(this.dom.getHref(e), e, t);
                }),
                (i.D = function (t) {
                  this.go(this.url.getHref(), "popstate", t);
                }),
                (i.I = function (t) {
                  for (var e = t.target; e && !this.dom.getHref(e); )
                    e = e.parentNode;
                  if (e && !this.prevent.checkLink(e, t, this.dom.getHref(e)))
                    return e;
                }),
                (i.q = function () {
                  var t = this.url.getHref(),
                    e = {
                      container: this.dom.getContainer(),
                      html: this.dom.getHtml(),
                      namespace: this.dom.getNamespace(),
                      url: n(
                        {
                          href: t,
                        },
                        this.url.parse(t)
                      ),
                    };
                  (this.C = {
                    current: e,
                    next: n({}, this.schemaPage),
                    trigger: void 0,
                  }),
                    this.hooks.do("reset", this.data);
                }),
                e(t, [
                  {
                    key: "data",
                    get: function () {
                      return this.C;
                    },
                  },
                  {
                    key: "wrapper",
                    get: function () {
                      return this._;
                    },
                  },
                ]),
                t
              );
            })())();
          })();
        },
        3824: function (t) {
          var e;
          t.exports =
            ((e = "2.1.15"),
            new ((function () {
              function t() {
                (this.name = "@barba/css"),
                  (this.version = e),
                  (this.prefix = "barba"),
                  (this.callbacks = {}),
                  (this.t = !1);
              }
              var n = t.prototype;
              return (
                (n.install = function (t) {
                  (this.logger = new t.Logger(this.name)),
                    this.logger.info(this.version),
                    (this.barba = t),
                    (this.i = this.i.bind(this)),
                    (this.s = this.s.bind(this)),
                    (this.h = this.h.bind(this));
                }),
                (n.init = function () {
                  this.barba.hooks.before(this.o, this),
                    this.barba.hooks.beforeOnce(this.o, this),
                    this.barba.hooks.beforeOnce(this.u, this),
                    this.barba.hooks.afterOnce(this.m, this),
                    this.barba.hooks.beforeLeave(this.P, this),
                    this.barba.hooks.afterLeave(this.v, this),
                    this.barba.hooks.beforeEnter(this.l, this),
                    this.barba.hooks.afterEnter(this.p, this),
                    (this.barba.transitions.once = this.i),
                    (this.barba.transitions.leave = this.s),
                    (this.barba.transitions.enter = this.h),
                    this.barba.transitions.store.all.unshift({
                      name: "barba",
                      once: function () {},
                      leave: function () {},
                      enter: function () {},
                    }),
                    this.barba.transitions.store.update();
                }),
                (n.start = function (t, e) {
                  try {
                    var n = this;
                    return (
                      n.add(t, e),
                      Promise.resolve(n.barba.helpers.nextTick()).then(
                        function () {
                          return (
                            n.add(t, e + "-active"),
                            Promise.resolve(n.barba.helpers.nextTick()).then(
                              function () {}
                            )
                          );
                        }
                      )
                    );
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.next = function (t, e) {
                  try {
                    var n = this;
                    return (
                      (n.t = n.g(t)),
                      Promise.resolve(
                        n.t
                          ? new Promise(function (i) {
                              try {
                                return (
                                  (n.cb = i),
                                  (n.callbacks[e] = i),
                                  t.addEventListener("transitionend", i, !1),
                                  Promise.resolve(
                                    n.barba.helpers.nextTick()
                                  ).then(function () {
                                    return (
                                      n.remove(t, e),
                                      n.add(t, e + "-to"),
                                      Promise.resolve(
                                        n.barba.helpers.nextTick()
                                      ).then(function () {})
                                    );
                                  })
                                );
                              } catch (t) {
                                return Promise.reject(t);
                              }
                            })
                          : (n.remove(t, e),
                            Promise.resolve(n.barba.helpers.nextTick()).then(
                              function () {
                                return (
                                  n.add(t, e + "-to"),
                                  Promise.resolve(
                                    n.barba.helpers.nextTick()
                                  ).then(function () {})
                                );
                              }
                            ))
                      )
                    );
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.end = function (t, e) {
                  try {
                    return (
                      this.remove(t, e + "-to"),
                      this.remove(t, e + "-active"),
                      t.removeEventListener("transitionend", this.callbacks[e]),
                      (this.t = !1),
                      Promise.resolve()
                    );
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.add = function (t, e) {
                  t.classList.add(this.prefix + "-" + e);
                }),
                (n.remove = function (t, e) {
                  t.classList.remove(this.prefix + "-" + e);
                }),
                (n.o = function (t, e) {
                  this.prefix = e.name || "barba";
                }),
                (n.g = function (t) {
                  return "0s" !== getComputedStyle(t).transitionDuration;
                }),
                (n.u = function (t) {
                  return this.start(t.next.container, "once");
                }),
                (n.i = function (t, e) {
                  try {
                    var n = this;
                    return Promise.resolve(n.barba.hooks.do("once", t, e)).then(
                      function () {
                        return n.next(t.next.container, "once");
                      }
                    );
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.m = function (t) {
                  return this.end(t.next.container, "once");
                }),
                (n.P = function (t) {
                  return this.start(t.current.container, "leave");
                }),
                (n.s = function (t, e) {
                  try {
                    var n = this;
                    return Promise.resolve(
                      n.barba.hooks.do("leave", t, e)
                    ).then(function () {
                      return n.next(t.current.container, "leave");
                    });
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.v = function (t) {
                  return (
                    this.end(t.current.container, "leave"),
                    this.barba.transitions.remove(t),
                    Promise.resolve()
                  );
                }),
                (n.l = function (t) {
                  return 1 === this.barba.history.size
                    ? Promise.resolve()
                    : this.start(t.next.container, "enter");
                }),
                (n.h = function (t, e) {
                  try {
                    var n = this;
                    return Promise.resolve(
                      n.barba.hooks.do("enter", t, e)
                    ).then(function () {
                      return n.next(t.next.container, "enter");
                    });
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }),
                (n.p = function (t) {
                  return 1 === this.barba.history.size
                    ? Promise.resolve()
                    : this.end(t.next.container, "enter");
                }),
                t
              );
            })())());
        },
        2212: function (t) {
          var e, n;
          t.exports =
            ((e = "2.1.10"),
            (n =
              window.requestIdleCallback ||
              function (t) {
                var e = Date.now();
                return setTimeout(function () {
                  t({
                    didTimeout: !1,
                    timeRemaining: function () {
                      return Math.max(0, 50 - (Date.now() - e));
                    },
                  });
                }, 1);
              }),
            new ((function () {
              function t() {
                (this.name = "@barba/prefetch"),
                  (this.version = e),
                  (this.toPrefetch = new Set());
              }
              var i = t.prototype;
              return (
                (i.install = function (t, e) {
                  var n = void 0 === e ? {} : e,
                    i = n.root,
                    r = void 0 === i ? document.body : i,
                    s = n.timeout,
                    o = void 0 === s ? 2e3 : s;
                  (this.logger = new t.Logger(this.name)),
                    this.logger.info(this.version),
                    (this.barba = t),
                    (this.root = r),
                    (this.timeout = o);
                }),
                (i.init = function () {
                  var t = this;
                  this.barba.prefetchIgnore
                    ? this.logger.warn("barba.prefetchIgnore is enabled")
                    : this.barba.cacheIgnore
                    ? this.logger.warn("barba.cacheIgnore is enabled")
                    : ((this.observer = new IntersectionObserver(function (e) {
                        e.forEach(function (e) {
                          if (e.isIntersecting) {
                            var n = e.target,
                              i = t.barba.dom.getHref(n);
                            t.toPrefetch.has(i) &&
                              (t.observer.unobserve(n),
                              t.barba.cache.has(i)
                                ? t.barba.cache.update(i, {
                                    action: "prefetch",
                                  })
                                : t.barba.cache.set(
                                    i,
                                    t.barba
                                      .request(
                                        i,
                                        t.barba.timeout,
                                        t.barba.onRequestError.bind(
                                          t.barba,
                                          "barba"
                                        )
                                      )
                                      .catch(function (e) {
                                        t.logger.error(e);
                                      }),
                                    "prefetch"
                                  ));
                          }
                        });
                      })),
                      this.observe(),
                      this.barba.hooks.after(this.observe, this));
                }),
                (i.observe = function () {
                  var t = this;
                  n(
                    function () {
                      t.root.querySelectorAll("a").forEach(function (e) {
                        var n = e,
                          i = t.barba.dom.getHref(n);
                        t.barba.cache.has(i) ||
                          t.barba.prevent.checkHref(i) ||
                          t.barba.prevent.checkLink(n, {}, i) ||
                          (t.observer.observe(e), t.toPrefetch.add(i));
                      });
                    },
                    {
                      timeout: this.timeout,
                    }
                  );
                }),
                t
              );
            })())());
        },
        4610: (t) => {
          var e = !(
            "undefined" == typeof window ||
            !window.document ||
            !window.document.createElement
          );
          t.exports = e;
        },
        181: (t, e, n) => {
          var i = NaN,
            r = "[object Symbol]",
            s = /^\s+|\s+$/g,
            o = /^[-+]0x[0-9a-f]+$/i,
            a = /^0b[01]+$/i,
            l = /^0o[0-7]+$/i,
            c = parseInt,
            u = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
            h =
              "object" == typeof self && self && self.Object === Object && self,
            d = u || h || Function("return this")(),
            p = Object.prototype.toString,
            f = Math.max,
            m = Math.min,
            g = function () {
              return d.Date.now();
            };
          function v(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e);
          }
          function y(t) {
            if ("number" == typeof t) return t;
            if (
              (function (t) {
                return (
                  "symbol" == typeof t ||
                  ((function (t) {
                    return !!t && "object" == typeof t;
                  })(t) &&
                    p.call(t) == r)
                );
              })(t)
            )
              return i;
            if (v(t)) {
              var e = "function" == typeof t.valueOf ? t.valueOf() : t;
              t = v(e) ? e + "" : e;
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = t.replace(s, "");
            var n = a.test(t);
            return n || l.test(t)
              ? c(t.slice(2), n ? 2 : 8)
              : o.test(t)
              ? i
              : +t;
          }
          t.exports = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c = 0,
              u = !1,
              h = !1,
              d = !0;
            if ("function" != typeof t)
              throw new TypeError("Expected a function");
            function p(e) {
              var n = i,
                s = r;
              return (i = r = void 0), (c = e), (o = t.apply(s, n));
            }
            function _(t) {
              var n = t - l;
              return void 0 === l || n >= e || n < 0 || (h && t - c >= s);
            }
            function x() {
              var t = g();
              if (_(t)) return b(t);
              a = setTimeout(
                x,
                (function (t) {
                  var n = e - (t - l);
                  return h ? m(n, s - (t - c)) : n;
                })(t)
              );
            }
            function b(t) {
              return (a = void 0), d && i ? p(t) : ((i = r = void 0), o);
            }
            function w() {
              var t = g(),
                n = _(t);
              if (((i = arguments), (r = this), (l = t), n)) {
                if (void 0 === a)
                  return (function (t) {
                    return (c = t), (a = setTimeout(x, e)), u ? p(t) : o;
                  })(l);
                if (h) return (a = setTimeout(x, e)), p(l);
              }
              return void 0 === a && (a = setTimeout(x, e)), o;
            }
            return (
              (e = y(e) || 0),
              v(n) &&
                ((u = !!n.leading),
                (s = (h = "maxWait" in n) ? f(y(n.maxWait) || 0, e) : s),
                (d = "trailing" in n ? !!n.trailing : d)),
              (w.cancel = function () {
                void 0 !== a && clearTimeout(a),
                  (c = 0),
                  (i = l = r = a = void 0);
              }),
              (w.flush = function () {
                return void 0 === a ? o : b(g());
              }),
              w
            );
          };
        },
        7654: (t, e, n) => {
          var i = "__lodash_hash_undefined__",
            r = "[object Function]",
            s = "[object GeneratorFunction]",
            o = /^\[object .+?Constructor\]$/,
            a = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
            l =
              "object" == typeof self && self && self.Object === Object && self,
            c = a || l || Function("return this")();
          var u,
            h = Array.prototype,
            d = Function.prototype,
            p = Object.prototype,
            f = c["__core-js_shared__"],
            m = (u = /[^.]+$/.exec((f && f.keys && f.keys.IE_PROTO) || ""))
              ? "Symbol(src)_1." + u
              : "",
            g = d.toString,
            v = p.hasOwnProperty,
            y = p.toString,
            _ = RegExp(
              "^" +
                g
                  .call(v)
                  .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    "$1.*?"
                  ) +
                "$"
            ),
            x = h.splice,
            b = C(c, "Map"),
            w = C(Object, "create");
          function E(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          function S(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          function M(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          function T(t, e) {
            for (var n, i, r = t.length; r--; )
              if ((n = t[r][0]) === (i = e) || (n != n && i != i)) return r;
            return -1;
          }
          function A(t) {
            if (!P(t) || ((e = t), m && m in e)) return !1;
            var e,
              n =
                (function (t) {
                  var e = P(t) ? y.call(t) : "";
                  return e == r || e == s;
                })(t) ||
                (function (t) {
                  var e = !1;
                  if (null != t && "function" != typeof t.toString)
                    try {
                      e = !!(t + "");
                    } catch (t) {}
                  return e;
                })(t)
                  ? _
                  : o;
            return n.test(
              (function (t) {
                if (null != t) {
                  try {
                    return g.call(t);
                  } catch (t) {}
                  try {
                    return t + "";
                  } catch (t) {}
                }
                return "";
              })(t)
            );
          }
          function R(t, e) {
            var n,
              i,
              r = t.__data__;
            return (
              "string" == (i = typeof (n = e)) ||
              "number" == i ||
              "symbol" == i ||
              "boolean" == i
                ? "__proto__" !== n
                : null === n
            )
              ? r["string" == typeof e ? "string" : "hash"]
              : r.map;
          }
          function C(t, e) {
            var n = (function (t, e) {
              return null == t ? void 0 : t[e];
            })(t, e);
            return A(n) ? n : void 0;
          }
          function L(t, e) {
            if ("function" != typeof t || (e && "function" != typeof e))
              throw new TypeError("Expected a function");
            var n = function () {
              var i = arguments,
                r = e ? e.apply(this, i) : i[0],
                s = n.cache;
              if (s.has(r)) return s.get(r);
              var o = t.apply(this, i);
              return (n.cache = s.set(r, o)), o;
            };
            return (n.cache = new (L.Cache || M)()), n;
          }
          function P(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e);
          }
          (E.prototype.clear = function () {
            this.__data__ = w ? w(null) : {};
          }),
            (E.prototype.delete = function (t) {
              return this.has(t) && delete this.__data__[t];
            }),
            (E.prototype.get = function (t) {
              var e = this.__data__;
              if (w) {
                var n = e[t];
                return n === i ? void 0 : n;
              }
              return v.call(e, t) ? e[t] : void 0;
            }),
            (E.prototype.has = function (t) {
              var e = this.__data__;
              return w ? void 0 !== e[t] : v.call(e, t);
            }),
            (E.prototype.set = function (t, e) {
              return (this.__data__[t] = w && void 0 === e ? i : e), this;
            }),
            (S.prototype.clear = function () {
              this.__data__ = [];
            }),
            (S.prototype.delete = function (t) {
              var e = this.__data__,
                n = T(e, t);
              return (
                !(n < 0) && (n == e.length - 1 ? e.pop() : x.call(e, n, 1), !0)
              );
            }),
            (S.prototype.get = function (t) {
              var e = this.__data__,
                n = T(e, t);
              return n < 0 ? void 0 : e[n][1];
            }),
            (S.prototype.has = function (t) {
              return T(this.__data__, t) > -1;
            }),
            (S.prototype.set = function (t, e) {
              var n = this.__data__,
                i = T(n, t);
              return i < 0 ? n.push([t, e]) : (n[i][1] = e), this;
            }),
            (M.prototype.clear = function () {
              this.__data__ = {
                hash: new E(),
                map: new (b || S)(),
                string: new E(),
              };
            }),
            (M.prototype.delete = function (t) {
              return R(this, t).delete(t);
            }),
            (M.prototype.get = function (t) {
              return R(this, t).get(t);
            }),
            (M.prototype.has = function (t) {
              return R(this, t).has(t);
            }),
            (M.prototype.set = function (t, e) {
              return R(this, t).set(t, e), this;
            }),
            (L.Cache = M),
            (t.exports = L);
        },
        5858: (t, e, n) => {
          var i = "Expected a function",
            r = NaN,
            s = "[object Symbol]",
            o = /^\s+|\s+$/g,
            a = /^[-+]0x[0-9a-f]+$/i,
            l = /^0b[01]+$/i,
            c = /^0o[0-7]+$/i,
            u = parseInt,
            h = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
            d =
              "object" == typeof self && self && self.Object === Object && self,
            p = h || d || Function("return this")(),
            f = Object.prototype.toString,
            m = Math.max,
            g = Math.min,
            v = function () {
              return p.Date.now();
            };
          function y(t, e, n) {
            var r,
              s,
              o,
              a,
              l,
              c,
              u = 0,
              h = !1,
              d = !1,
              p = !0;
            if ("function" != typeof t) throw new TypeError(i);
            function f(e) {
              var n = r,
                i = s;
              return (r = s = void 0), (u = e), (a = t.apply(i, n));
            }
            function y(t) {
              var n = t - c;
              return void 0 === c || n >= e || n < 0 || (d && t - u >= o);
            }
            function b() {
              var t = v();
              if (y(t)) return w(t);
              l = setTimeout(
                b,
                (function (t) {
                  var n = e - (t - c);
                  return d ? g(n, o - (t - u)) : n;
                })(t)
              );
            }
            function w(t) {
              return (l = void 0), p && r ? f(t) : ((r = s = void 0), a);
            }
            function E() {
              var t = v(),
                n = y(t);
              if (((r = arguments), (s = this), (c = t), n)) {
                if (void 0 === l)
                  return (function (t) {
                    return (u = t), (l = setTimeout(b, e)), h ? f(t) : a;
                  })(c);
                if (d) return (l = setTimeout(b, e)), f(c);
              }
              return void 0 === l && (l = setTimeout(b, e)), a;
            }
            return (
              (e = x(e) || 0),
              _(n) &&
                ((h = !!n.leading),
                (o = (d = "maxWait" in n) ? m(x(n.maxWait) || 0, e) : o),
                (p = "trailing" in n ? !!n.trailing : p)),
              (E.cancel = function () {
                void 0 !== l && clearTimeout(l),
                  (u = 0),
                  (r = c = s = l = void 0);
              }),
              (E.flush = function () {
                return void 0 === l ? a : w(v());
              }),
              E
            );
          }
          function _(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e);
          }
          function x(t) {
            if ("number" == typeof t) return t;
            if (
              (function (t) {
                return (
                  "symbol" == typeof t ||
                  ((function (t) {
                    return !!t && "object" == typeof t;
                  })(t) &&
                    f.call(t) == s)
                );
              })(t)
            )
              return r;
            if (_(t)) {
              var e = "function" == typeof t.valueOf ? t.valueOf() : t;
              t = _(e) ? e + "" : e;
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = t.replace(o, "");
            var n = l.test(t);
            return n || c.test(t)
              ? u(t.slice(2), n ? 2 : 8)
              : a.test(t)
              ? r
              : +t;
          }
          t.exports = function (t, e, n) {
            var r = !0,
              s = !0;
            if ("function" != typeof t) throw new TypeError(i);
            return (
              _(n) &&
                ((r = "leading" in n ? !!n.leading : r),
                (s = "trailing" in n ? !!n.trailing : s)),
              y(t, e, {
                leading: r,
                maxWait: e,
                trailing: s,
              })
            );
          };
        },
        4595: function (t) {
          t.exports = (function () {
            "use strict";
            var t = {
                d: function (e, n) {
                  for (var i in n)
                    t.o(n, i) &&
                      !t.o(e, i) &&
                      Object.defineProperty(e, i, {
                        enumerable: !0,
                        get: n[i],
                      });
                },
                o: function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                },
              },
              e = {};
            t.d(e, {
              default: function () {
                return A;
              },
            });
            var n = "rtl",
              i = "ltr";
            function r(t) {
              return (
                (r =
                  "function" == typeof Symbol &&
                  "symbol" == typeof Symbol.iterator
                    ? function (t) {
                        return typeof t;
                      }
                    : function (t) {
                        return t &&
                          "function" == typeof Symbol &&
                          t.constructor === Symbol &&
                          t !== Symbol.prototype
                          ? "symbol"
                          : typeof t;
                      }),
                r(t)
              );
            }
            function s(t) {
              return (
                (function (t) {
                  if (Array.isArray(t)) return o(t);
                })(t) ||
                (function (t) {
                  if (
                    ("undefined" != typeof Symbol &&
                      null != t[Symbol.iterator]) ||
                    null != t["@@iterator"]
                  )
                    return Array.from(t);
                })(t) ||
                (function (t, e) {
                  if (t) {
                    if ("string" == typeof t) return o(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return (
                      "Object" === n &&
                        t.constructor &&
                        (n = t.constructor.name),
                      "Map" === n || "Set" === n
                        ? Array.from(t)
                        : "Arguments" === n ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                        ? o(t, e)
                        : void 0
                    );
                  }
                })(t) ||
                (function () {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                })()
              );
            }
            function o(t, e) {
              (null == e || e > t.length) && (e = t.length);
              for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
              return i;
            }
            function a(t) {
              return "string" == typeof t ? document.querySelector(t) : t;
            }
            function l(t) {
              return Array.isArray(t)
                ? t
                : null == t
                ? []
                : "object" == r(t) && "number" == typeof t.length
                ? s(t)
                : [t];
            }
            function c(t) {
              return (
                Object.keys(t).includes("speed") &&
                  !Number(t.speed) &&
                  (t.speed = 7),
                Number(t.speed) <= 0 && (t.speed = 1),
                Object.keys(t).includes("margin") &&
                  !Number(t.margin) &&
                  0 !== Number(t.margin) &&
                  (t.margin = 10),
                Object.keys(t).includes("direction") &&
                  (t.direction = t.direction.toLowerCase()),
                Object.keys(t).includes("direction") &&
                  t.direction !== n &&
                  t.direction !== i &&
                  (t.direction = n),
                Object.keys(t).includes("autoplaySpeed") &&
                  !Number(t.autoplaySpeed) &&
                  (t.autoplaySpeed = 5),
                Number(t.autoplaySpeed) <= 0 && (t.autoplaySpeed = 1),
                t
              );
            }
            function u(t, e) {
              var n =
                ("undefined" != typeof Symbol && t[Symbol.iterator]) ||
                t["@@iterator"];
              if (!n) {
                if (
                  Array.isArray(t) ||
                  (n = (function (t, e) {
                    if (t) {
                      if ("string" == typeof t) return h(t, e);
                      var n = Object.prototype.toString.call(t).slice(8, -1);
                      return (
                        "Object" === n &&
                          t.constructor &&
                          (n = t.constructor.name),
                        "Map" === n || "Set" === n
                          ? Array.from(t)
                          : "Arguments" === n ||
                            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                          ? h(t, e)
                          : void 0
                      );
                    }
                  })(t)) ||
                  (e && t && "number" == typeof t.length)
                ) {
                  n && (t = n);
                  var i = 0,
                    r = function () {};
                  return {
                    s: r,
                    n: function () {
                      return i >= t.length
                        ? {
                            done: !0,
                          }
                        : {
                            done: !1,
                            value: t[i++],
                          };
                    },
                    e: function (t) {
                      throw t;
                    },
                    f: r,
                  };
                }
                throw new TypeError(
                  "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                );
              }
              var s,
                o = !0,
                a = !1;
              return {
                s: function () {
                  n = n.call(t);
                },
                n: function () {
                  var t = n.next();
                  return (o = t.done), t;
                },
                e: function (t) {
                  (a = !0), (s = t);
                },
                f: function () {
                  try {
                    o || null == n.return || n.return();
                  } finally {
                    if (a) throw s;
                  }
                },
              };
            }
            function h(t, e) {
              (null == e || e > t.length) && (e = t.length);
              for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
              return i;
            }
            function d() {}
            var p = d.prototype;
            function f(t) {
              return (
                (function (t) {
                  if (Array.isArray(t)) return m(t);
                })(t) ||
                (function (t) {
                  if (
                    ("undefined" != typeof Symbol &&
                      null != t[Symbol.iterator]) ||
                    null != t["@@iterator"]
                  )
                    return Array.from(t);
                })(t) ||
                (function (t, e) {
                  if (t) {
                    if ("string" == typeof t) return m(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return (
                      "Object" === n &&
                        t.constructor &&
                        (n = t.constructor.name),
                      "Map" === n || "Set" === n
                        ? Array.from(t)
                        : "Arguments" === n ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                        ? m(t, e)
                        : void 0
                    );
                  }
                })(t) ||
                (function () {
                  throw new TypeError(
                    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                })()
              );
            }
            function m(t, e) {
              (null == e || e > t.length) && (e = t.length);
              for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
              return i;
            }
            function g(t, e) {
              var n = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e &&
                  (i = i.filter(function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                  })),
                  n.push.apply(n, i);
              }
              return n;
            }
            function v(t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2
                  ? g(Object(n), !0).forEach(function (e) {
                      y(t, e, n[e]);
                    })
                  : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(
                      t,
                      Object.getOwnPropertyDescriptors(n)
                    )
                  : g(Object(n)).forEach(function (e) {
                      Object.defineProperty(
                        t,
                        e,
                        Object.getOwnPropertyDescriptor(n, e)
                      );
                    });
              }
              return t;
            }
            function y(t, e, n) {
              return (
                e in t
                  ? Object.defineProperty(t, e, {
                      value: n,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (t[e] = n),
                t
              );
            }
            (p.on = function (t, e) {
              if (!t || !e) return this;
              var n = (this._events = this._events || {}),
                i = (n[t] = n[t] || []);
              return i.includes(e) || i.push(e), this;
            }),
              (p.emitEvent = function (t, e) {
                var n = this._events && this._events[t];
                if (!n || !n.length) return this;
                e = e || [];
                var i,
                  r = u((n = n.slice(0)));
                try {
                  for (r.s(); !(i = r.n()).done; ) i.value.apply(this, e);
                } catch (t) {
                  r.e(t);
                } finally {
                  r.f();
                }
                return this;
              }),
              (p.allOff = function () {
                return delete this._events, this;
              });
            var _ = 0,
              x = {};
            function b(t) {
              var e =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {},
                n = a(t);
              if (n) {
                if (((this.element = n), this.element.scrollCarouselGUID)) {
                  var i = x[this.element.scrollCarouselGUID];
                  return i && i.option(e), i;
                }
                (this.baseOption = e),
                  (this.options = v({}, this.constructor.defaults));
                var r = c(e);
                this.option(r), this._create();
              } else
                console &&
                  console.error(
                    "Bad element for Scroll Carousel: ".concat(n || t)
                  );
            }
            b.defaults = {
              speed: 7,
              smartSpeed: !1,
              margin: 10,
              autoplay: !1,
              autoplaySpeed: 5,
              slideSelector: null,
              direction: n,
            };
            var w,
              E,
              S,
              M,
              T = b.prototype;
            Object.assign(T, d.prototype),
              (T._create = function () {
                var t = (this.guid = ++_);
                for (var e in ((this.element.scrollCarouselGUID = t),
                (x[t] = this),
                this._createViewport(),
                this._createSlider(),
                this.options.on)) {
                  var n = this.options.on[e];
                  this.on(e, n);
                }
                this.activate();
              }),
              (T.option = function (t) {
                Object.assign(this.options, t);
              }),
              (T.activate = function () {
                var t,
                  e = this;
                if (!this.isActive) {
                  (this.isActive = !0),
                    (this.translate = 0),
                    (this.displacement = 0),
                    (this.isScrolling = !0),
                    (this.prevPosition =
                      document.body.scrollTop ||
                      document.documentElement.scrollTop),
                    (this.baseElems = l(this.element.children));
                  var n = this._filterFindSlideElements(this.element.children);
                  (this.slideElems = this._makeSlides(n)),
                    this.options.direction === i &&
                      (this.slideElems = this.slideElems.reverse());
                  var r = this.slideElems.map(function (t) {
                    return t.cloneNode(!0);
                  });
                  (t = this.slider).append.apply(
                    t,
                    f(this.slideElems).concat(f(r))
                  ),
                    this.viewport.append(this.slider),
                    this.element.append(this.viewport),
                    this.options.direction === i && this._supportLtr(),
                    this.options.autoplay && this._autoplay(),
                    this.emitEvent("ready"),
                    window.addEventListener("scroll", function () {
                      return e._transform();
                    });
                }
              }),
              (T._autoplay = function () {
                var t = this;
                this.interval = setInterval(function () {
                  t._transform();
                }, 10);
              }),
              (T._transform = function () {
                (function (t) {
                  if (!t) return !1;
                  var e = t.getBoundingClientRect(),
                    n =
                      window.innerHeight ||
                      document.documentElement.clientHeight,
                    i =
                      window.innerWidth || document.documentElement.clientWidth,
                    r = e.top <= n && e.top + e.height >= 0,
                    s = e.left <= i && e.left + e.width >= 0;
                  return r && s;
                })(this.element) &&
                  (this.options.autoplay && this._setIsScrolling(),
                  this.options.smartSpeed
                    ? this._calcSmartSpeed()
                    : this._calcRegularSpeed(),
                  this.emitEvent("move", [this.progress]));
              }),
              (T._calcRegularSpeed = function () {
                var t = this.slider.getBoundingClientRect();
                this.slider.style.transform = "translateX(".concat(
                  this.translate,
                  "px)"
                );
                var e = this.isScrolling ? this.options.speed : 1.2;
                this.options.direction === n && (this.translate -= e),
                  this.options.direction === i && (this.translate += e),
                  this.options.direction === n &&
                    this.translate <= -t.width / 2 &&
                    (this.translate = 0),
                  this.options.direction === i &&
                    this.translate >= 0 &&
                    (this.translate = -t.width / 2),
                  (this.progress = ((100 * -this.translate) / t.width) * 2);
              }),
              (T._calcSmartSpeed = function () {
                var t =
                  document.body.scrollTop || document.documentElement.scrollTop;
                (this.displacement -= this.isScrolling
                  ? Math.abs(this.prevPosition - t)
                  : 1.2),
                  this.options.direction === i &&
                    this.displacement < 0 &&
                    (this.displacement =
                      50 / (((10 * this.options.speed) / 5500) % 50));
                var e,
                  r =
                    ((this.displacement / 5500) * (10 * this.options.speed)) %
                    50;
                (this.progress = 2 * -r),
                  this.options.direction === n && (e = r),
                  this.options.direction === i && (e = -r),
                  (this.slider.style.transform = "translateX(".concat(e, "%)")),
                  (this.prevPosition = t);
              }),
              (T._supportLtr = function () {
                var t = this.slider.getBoundingClientRect();
                this.translate =
                  -t.width +
                  Math.min(
                    document.documentElement.clientWidth,
                    window.innerWidth
                  );
                var e = (100 * this.translate) / t.width;
                (this.displacement =
                  -e / (((10 * this.options.speed) / 5500) % 50)),
                  this.options.smartSpeed
                    ? (this.slider.style.transform = "translateX(".concat(
                        e,
                        "%)"
                      ))
                    : (this.slider.style.transform = "translateX(".concat(
                        this.translate,
                        "px)"
                      ));
              }),
              (T._setIsScrolling = function () {
                var t =
                  document.body.scrollTop || document.documentElement.scrollTop;
                (this.isScrolling = !0),
                  this.prevPosition !== t
                    ? this.options.smartSpeed || (this.prevPosition = t)
                    : (this.isScrolling = !1);
              }),
              (T._makeSlide = function (t) {
                var e = document.createElement("div");
                return (
                  (e.style.marginRight = this.options.margin + "px"),
                  (e.className = "sc-slide"),
                  (this.slideElem = e),
                  this.slideElem.append(t),
                  this.slideElem
                );
              }),
              (T._makeSlides = function (t) {
                var e = this;
                return t.map(function (t) {
                  return e._makeSlide(t);
                });
              }),
              (T._createSlider = function () {
                var t = document.createElement("div");
                (t.className = "scroll-carousel-slider"), (this.slider = t);
              }),
              (T._createViewport = function () {
                (this.viewport = document.createElement("div")),
                  (this.viewport.className = "scroll-carousel-viewport");
              }),
              (T._filterFindSlideElements = function (t) {
                return (function (t, e) {
                  return (t = l(t))
                    .filter(function (t) {
                      return t instanceof HTMLElement;
                    })
                    .reduce(function (t, n) {
                      var i;
                      if (!e) return t.push(n), t;
                      n.matches(e) && t.push(n);
                      var r = n.querySelectorAll(e);
                      return (i = t).concat.apply(i, s(r));
                    }, []);
                })(t, this.options.slideSelector);
              }),
              (T.destroy = function () {
                var t;
                this.isActive &&
                  (this.viewport.remove(),
                  (t = this.element).append.apply(t, f(this.baseElems)),
                  (this.isActive = !1),
                  clearInterval(this.interval),
                  window.removeEventListener("scroll", this),
                  this.emitEvent("destroy"),
                  this.allOff(),
                  delete this.element.scrollCarouselGUID,
                  delete x[this.guid]);
              }),
              (T.reinit = function () {
                return new b(this.element, this.baseOption);
              }),
              (b.data = function (t) {
                if ((t = a(t))) return x[t.scrollCarouselGUID];
              }),
              (w = b),
              (E = "carousel"),
              (S = function () {
                var t =
                  "data-" +
                  E.replace(/(.)([A-Z])/g, function (t, e, n) {
                    return e + "-" + n;
                  }).toLowerCase();
                s(document.querySelectorAll("[".concat(t, "]"))).forEach(
                  function (e) {
                    var n,
                      i = e.getAttribute(t);
                    try {
                      n = i && JSON.parse(i);
                    } catch (n) {
                      return void (
                        console &&
                        console.error(
                          "Error parsing "
                            .concat(t, " on ")
                            .concat(e.className, ": ")
                            .concat(n)
                        )
                      );
                    }
                    new w(e, n);
                  }
                );
              }),
              "complete" == (M = document.readyState) || "interactive" == M
                ? setTimeout(S)
                : document.addEventListener("DOMContentLoaded", S);
            var A = b;
            return e.default;
          })();
        },
        1321: (t) => {
          t.exports =
            "attribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;\n  gl_Position = vec4(position, 1);\n}\n";
        },
        7195: (t) => {
          t.exports =
            "precision highp float;\nvoid main () {\n  gl_FragColor = vec4(vec3(0), 1);\n}";
        },
        7118: (t) => {
          t.exports =
            "precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform vec2 uDirection;\nuniform vec2 uPixelSize;\nuniform float uWeights[GAUSS_RADIUS];\n\nvoid main() {\n  vec4 color = vec4(0), sumColor = vec4(0);\n  float weight = 0.0, sumWeight = 0.0, actualWeight = 0.0;\n\n  for(int i = 0; i < GAUSS_RADIUS - 1; i++){\n    weight = uWeights[i];\n\n    vec2 offsetUv = vec2(i) * uDirection * uPixelSize;\n\n    color = texture2D( uTexture, vUv - offsetUv);\n    actualWeight = weight * color.a;\n    sumColor.rgb += color.rgb * actualWeight;\n    sumColor.a += color.a * weight;\n    sumWeight += actualWeight;\n\n    color = texture2D( uTexture, vUv + offsetUv);\n    actualWeight = weight * color.a;\n    sumColor.rgb += color.rgb * actualWeight;\n    sumColor.a += color.a * weight;\n    sumWeight += actualWeight;\n  }\n\n  color = texture2D( uTexture, vUv );\n  actualWeight = weight * color.a;\n  sumColor.rgb += color.rgb * actualWeight;\n  sumColor.a += color.a * weight;\n  sumWeight += actualWeight;\n\n  gl_FragColor = vec4(sumColor.rgb / sumWeight, sumColor.a);\n}\n";
        },
        3801: (t) => {
          t.exports =
            "precision highp float;\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float uContrast;\nuniform float uSubtract;\n\nvoid main () {\n  vec4 color = texture2D(uTexture, vUv);\n  color.a = min(1.0, color.a * uContrast - uSubtract);\n\n  gl_FragColor = color;\n}\n\n";
        },
        2545: (t) => {
          t.exports =
            "precision highp float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nuniform float uDiffuseThreshold;\nuniform float uSunStrength;\nuniform vec3 uColor;\nuniform vec3 uSunColor;\nuniform vec3 uLightPosition;\nvoid main( void ) {\n  vec3 diffuse = vec3(clamp(dot(vNormal, uLightPosition), 0.1, 1.0));\n\n  // vec3 eye = vec3(0,0,-10.0);\n  // vec3 refractVector = refract(eye, vNormal, 1.0);\n  // float fresnel = pow(1.0 + dot(eye, vNormal), -2.0);\n  // vec3 fresnelColor = vec3(fresnel) * vec3(0.4902, 0.498, 1.0);\n  // fresnelColor.r = step(0.1, fresnelColor.r);\n  // fresnelColor.g = step(0.1, fresnelColor.g);\n  // fresnelColor.b = step(0.1, fresnelColor.b);\n\n  vec4 color = vec4(uColor, 1.0);\n  gl_FragColor = vec4(mix(color.rgb, color.rgb * (diffuse * uSunColor + uSunStrength), uDiffuseThreshold), 1.0);\n  // gl_FragColor.rgb += fresnelColor;\n  // gl_FragColor.rgb = fresnelColor;\n}\n";
        },
        5921: (t) => {
          t.exports =
            "attribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvoid main(){\n  vUv = uv;\n  vNormal = normal;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n}\n";
        },
        9306: (t, e, n) => {
          "use strict";
          var i = n(4901),
            r = n(6823),
            s = TypeError;
          t.exports = function (t) {
            if (i(t)) return t;
            throw new s(r(t) + " is not a function");
          };
        },
        3506: (t, e, n) => {
          "use strict";
          var i = n(3925),
            r = String,
            s = TypeError;
          t.exports = function (t) {
            if (i(t)) return t;
            throw new s("Can't set " + r(t) + " as a prototype");
          };
        },
        6469: (t, e, n) => {
          "use strict";
          var i = n(8227),
            r = n(2360),
            s = n(4913).f,
            o = i("unscopables"),
            a = Array.prototype;
          void 0 === a[o] &&
            s(a, o, {
              configurable: !0,
              value: r(null),
            }),
            (t.exports = function (t) {
              a[o][t] = !0;
            });
        },
        7829: (t, e, n) => {
          "use strict";
          var i = n(8183).charAt;
          t.exports = function (t, e, n) {
            return e + (n ? i(t, e).length : 1);
          };
        },
        679: (t, e, n) => {
          "use strict";
          var i = n(1625),
            r = TypeError;
          t.exports = function (t, e) {
            if (i(e, t)) return t;
            throw new r("Incorrect invocation");
          };
        },
        8551: (t, e, n) => {
          "use strict";
          var i = n(34),
            r = String,
            s = TypeError;
          t.exports = function (t) {
            if (i(t)) return t;
            throw new s(r(t) + " is not an object");
          };
        },
        5652: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = i(function () {
            if ("function" == typeof ArrayBuffer) {
              var t = new ArrayBuffer(8);
              Object.isExtensible(t) &&
                Object.defineProperty(t, "a", {
                  value: 8,
                });
            }
          });
        },
        235: (t, e, n) => {
          "use strict";
          var i = n(9213).forEach,
            r = n(4598)("forEach");
          t.exports = r
            ? [].forEach
            : function (t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
              };
        },
        9617: (t, e, n) => {
          "use strict";
          var i = n(5397),
            r = n(5610),
            s = n(6198),
            o = function (t) {
              return function (e, n, o) {
                var a = i(e),
                  l = s(a);
                if (0 === l) return !t && -1;
                var c,
                  u = r(o, l);
                if (t && n != n) {
                  for (; l > u; ) if ((c = a[u++]) != c) return !0;
                } else
                  for (; l > u; u++)
                    if ((t || u in a) && a[u] === n) return t || u || 0;
                return !t && -1;
              };
            };
          t.exports = {
            includes: o(!0),
            indexOf: o(!1),
          };
        },
        9213: (t, e, n) => {
          "use strict";
          var i = n(6080),
            r = n(9504),
            s = n(7055),
            o = n(8981),
            a = n(6198),
            l = n(1469),
            c = r([].push),
            u = function (t) {
              var e = 1 === t,
                n = 2 === t,
                r = 3 === t,
                u = 4 === t,
                h = 6 === t,
                d = 7 === t,
                p = 5 === t || h;
              return function (f, m, g, v) {
                for (
                  var y,
                    _,
                    x = o(f),
                    b = s(x),
                    w = a(b),
                    E = i(m, g),
                    S = 0,
                    M = v || l,
                    T = e ? M(f, w) : n || d ? M(f, 0) : void 0;
                  w > S;
                  S++
                )
                  if ((p || S in b) && ((_ = E((y = b[S]), S, x)), t))
                    if (e) T[S] = _;
                    else if (_)
                      switch (t) {
                        case 3:
                          return !0;
                        case 5:
                          return y;
                        case 6:
                          return S;
                        case 2:
                          c(T, y);
                      }
                    else
                      switch (t) {
                        case 4:
                          return !1;
                        case 7:
                          c(T, y);
                      }
                return h ? -1 : r || u ? u : T;
              };
            };
          t.exports = {
            forEach: u(0),
            map: u(1),
            filter: u(2),
            some: u(3),
            every: u(4),
            find: u(5),
            findIndex: u(6),
            filterReject: u(7),
          };
        },
        597: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(8227),
            s = n(7388),
            o = r("species");
          t.exports = function (t) {
            return (
              s >= 51 ||
              !i(function () {
                var e = [];
                return (
                  ((e.constructor = {})[o] = function () {
                    return {
                      foo: 1,
                    };
                  }),
                  1 !== e[t](Boolean).foo
                );
              })
            );
          };
        },
        4598: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = function (t, e) {
            var n = [][t];
            return (
              !!n &&
              i(function () {
                n.call(
                  null,
                  e ||
                    function () {
                      return 1;
                    },
                  1
                );
              })
            );
          };
        },
        926: (t, e, n) => {
          "use strict";
          var i = n(9306),
            r = n(8981),
            s = n(7055),
            o = n(6198),
            a = TypeError,
            l = "Reduce of empty array with no initial value",
            c = function (t) {
              return function (e, n, c, u) {
                var h = r(e),
                  d = s(h),
                  p = o(h);
                if ((i(n), 0 === p && c < 2)) throw new a(l);
                var f = t ? p - 1 : 0,
                  m = t ? -1 : 1;
                if (c < 2)
                  for (;;) {
                    if (f in d) {
                      (u = d[f]), (f += m);
                      break;
                    }
                    if (((f += m), t ? f < 0 : p <= f)) throw new a(l);
                  }
                for (; t ? f >= 0 : p > f; f += m)
                  f in d && (u = n(u, d[f], f, h));
                return u;
              };
            };
          t.exports = {
            left: c(!1),
            right: c(!0),
          };
        },
        7680: (t, e, n) => {
          "use strict";
          var i = n(9504);
          t.exports = i([].slice);
        },
        7433: (t, e, n) => {
          "use strict";
          var i = n(4376),
            r = n(3517),
            s = n(34),
            o = n(8227)("species"),
            a = Array;
          t.exports = function (t) {
            var e;
            return (
              i(t) &&
                ((e = t.constructor),
                ((r(e) && (e === a || i(e.prototype))) ||
                  (s(e) && null === (e = e[o]))) &&
                  (e = void 0)),
              void 0 === e ? a : e
            );
          };
        },
        1469: (t, e, n) => {
          "use strict";
          var i = n(7433);
          t.exports = function (t, e) {
            return new (i(t))(0 === e ? 0 : e);
          };
        },
        4428: (t, e, n) => {
          "use strict";
          var i = n(8227)("iterator"),
            r = !1;
          try {
            var s = 0,
              o = {
                next: function () {
                  return {
                    done: !!s++,
                  };
                },
                return: function () {
                  r = !0;
                },
              };
            (o[i] = function () {
              return this;
            }),
              Array.from(o, function () {
                throw 2;
              });
          } catch (t) {}
          t.exports = function (t, e) {
            try {
              if (!e && !r) return !1;
            } catch (t) {
              return !1;
            }
            var n = !1;
            try {
              var s = {};
              (s[i] = function () {
                return {
                  next: function () {
                    return {
                      done: (n = !0),
                    };
                  },
                };
              }),
                t(s);
            } catch (t) {}
            return n;
          };
        },
        4576: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = i({}.toString),
            s = i("".slice);
          t.exports = function (t) {
            return s(r(t), 8, -1);
          };
        },
        6955: (t, e, n) => {
          "use strict";
          var i = n(2140),
            r = n(4901),
            s = n(4576),
            o = n(8227)("toStringTag"),
            a = Object,
            l =
              "Arguments" ===
              s(
                (function () {
                  return arguments;
                })()
              );
          t.exports = i
            ? s
            : function (t) {
                var e, n, i;
                return void 0 === t
                  ? "Undefined"
                  : null === t
                  ? "Null"
                  : "string" ==
                    typeof (n = (function (t, e) {
                      try {
                        return t[e];
                      } catch (t) {}
                    })((e = a(t)), o))
                  ? n
                  : l
                  ? s(e)
                  : "Object" === (i = s(e)) && r(e.callee)
                  ? "Arguments"
                  : i;
              };
        },
        4006: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(6279),
            s = n(3451).getWeakData,
            o = n(679),
            a = n(8551),
            l = n(4117),
            c = n(34),
            u = n(2652),
            h = n(9213),
            d = n(9297),
            p = n(1181),
            f = p.set,
            m = p.getterFor,
            g = h.find,
            v = h.findIndex,
            y = i([].splice),
            _ = 0,
            x = function (t) {
              return t.frozen || (t.frozen = new b());
            },
            b = function () {
              this.entries = [];
            },
            w = function (t, e) {
              return g(t.entries, function (t) {
                return t[0] === e;
              });
            };
          (b.prototype = {
            get: function (t) {
              var e = w(this, t);
              if (e) return e[1];
            },
            has: function (t) {
              return !!w(this, t);
            },
            set: function (t, e) {
              var n = w(this, t);
              n ? (n[1] = e) : this.entries.push([t, e]);
            },
            delete: function (t) {
              var e = v(this.entries, function (e) {
                return e[0] === t;
              });
              return ~e && y(this.entries, e, 1), !!~e;
            },
          }),
            (t.exports = {
              getConstructor: function (t, e, n, i) {
                var h = t(function (t, r) {
                    o(t, p),
                      f(t, {
                        type: e,
                        id: _++,
                        frozen: void 0,
                      }),
                      l(r) ||
                        u(r, t[i], {
                          that: t,
                          AS_ENTRIES: n,
                        });
                  }),
                  p = h.prototype,
                  g = m(e),
                  v = function (t, e, n) {
                    var i = g(t),
                      r = s(a(e), !0);
                    return !0 === r ? x(i).set(e, n) : (r[i.id] = n), t;
                  };
                return (
                  r(p, {
                    delete: function (t) {
                      var e = g(this);
                      if (!c(t)) return !1;
                      var n = s(t);
                      return !0 === n
                        ? x(e).delete(t)
                        : n && d(n, e.id) && delete n[e.id];
                    },
                    has: function (t) {
                      var e = g(this);
                      if (!c(t)) return !1;
                      var n = s(t);
                      return !0 === n ? x(e).has(t) : n && d(n, e.id);
                    },
                  }),
                  r(
                    p,
                    n
                      ? {
                          get: function (t) {
                            var e = g(this);
                            if (c(t)) {
                              var n = s(t);
                              return !0 === n
                                ? x(e).get(t)
                                : n
                                ? n[e.id]
                                : void 0;
                            }
                          },
                          set: function (t, e) {
                            return v(this, t, e);
                          },
                        }
                      : {
                          add: function (t) {
                            return v(this, t, !0);
                          },
                        }
                  ),
                  h
                );
              },
            });
        },
        6468: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(4475),
            s = n(9504),
            o = n(2796),
            a = n(6840),
            l = n(3451),
            c = n(2652),
            u = n(679),
            h = n(4901),
            d = n(4117),
            p = n(34),
            f = n(9039),
            m = n(4428),
            g = n(687),
            v = n(3167);
          t.exports = function (t, e, n) {
            var y = -1 !== t.indexOf("Map"),
              _ = -1 !== t.indexOf("Weak"),
              x = y ? "set" : "add",
              b = r[t],
              w = b && b.prototype,
              E = b,
              S = {},
              M = function (t) {
                var e = s(w[t]);
                a(
                  w,
                  t,
                  "add" === t
                    ? function (t) {
                        return e(this, 0 === t ? 0 : t), this;
                      }
                    : "delete" === t
                    ? function (t) {
                        return !(_ && !p(t)) && e(this, 0 === t ? 0 : t);
                      }
                    : "get" === t
                    ? function (t) {
                        return _ && !p(t) ? void 0 : e(this, 0 === t ? 0 : t);
                      }
                    : "has" === t
                    ? function (t) {
                        return !(_ && !p(t)) && e(this, 0 === t ? 0 : t);
                      }
                    : function (t, n) {
                        return e(this, 0 === t ? 0 : t, n), this;
                      }
                );
              };
            if (
              o(
                t,
                !h(b) ||
                  !(
                    _ ||
                    (w.forEach &&
                      !f(function () {
                        new b().entries().next();
                      }))
                  )
              )
            )
              (E = n.getConstructor(e, t, y, x)), l.enable();
            else if (o(t, !0)) {
              var T = new E(),
                A = T[x](_ ? {} : -0, 1) !== T,
                R = f(function () {
                  T.has(1);
                }),
                C = m(function (t) {
                  new b(t);
                }),
                L =
                  !_ &&
                  f(function () {
                    for (var t = new b(), e = 5; e--; ) t[x](e, e);
                    return !t.has(-0);
                  });
              C ||
                (((E = e(function (t, e) {
                  u(t, w);
                  var n = v(new b(), t, E);
                  return (
                    d(e) ||
                      c(e, n[x], {
                        that: n,
                        AS_ENTRIES: y,
                      }),
                    n
                  );
                })).prototype = w),
                (w.constructor = E)),
                (R || L) && (M("delete"), M("has"), y && M("get")),
                (L || A) && M(x),
                _ && w.clear && delete w.clear;
            }
            return (
              (S[t] = E),
              i(
                {
                  global: !0,
                  constructor: !0,
                  forced: E !== b,
                },
                S
              ),
              g(E, t),
              _ || n.setStrong(E, t, y),
              E
            );
          };
        },
        7740: (t, e, n) => {
          "use strict";
          var i = n(9297),
            r = n(5031),
            s = n(7347),
            o = n(4913);
          t.exports = function (t, e, n) {
            for (var a = r(e), l = o.f, c = s.f, u = 0; u < a.length; u++) {
              var h = a[u];
              i(t, h) || (n && i(n, h)) || l(t, h, c(e, h));
            }
          };
        },
        2211: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = !i(function () {
            function t() {}
            return (
              (t.prototype.constructor = null),
              Object.getPrototypeOf(new t()) !== t.prototype
            );
          });
        },
        2529: (t) => {
          "use strict";
          t.exports = function (t, e) {
            return {
              value: t,
              done: e,
            };
          };
        },
        6699: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(4913),
            s = n(6980);
          t.exports = i
            ? function (t, e, n) {
                return r.f(t, e, s(1, n));
              }
            : function (t, e, n) {
                return (t[e] = n), t;
              };
        },
        6980: (t) => {
          "use strict";
          t.exports = function (t, e) {
            return {
              enumerable: !(1 & t),
              configurable: !(2 & t),
              writable: !(4 & t),
              value: e,
            };
          };
        },
        2106: (t, e, n) => {
          "use strict";
          var i = n(283),
            r = n(4913);
          t.exports = function (t, e, n) {
            return (
              n.get &&
                i(n.get, e, {
                  getter: !0,
                }),
              n.set &&
                i(n.set, e, {
                  setter: !0,
                }),
              r.f(t, e, n)
            );
          };
        },
        6840: (t, e, n) => {
          "use strict";
          var i = n(4901),
            r = n(4913),
            s = n(283),
            o = n(9433);
          t.exports = function (t, e, n, a) {
            a || (a = {});
            var l = a.enumerable,
              c = void 0 !== a.name ? a.name : e;
            if ((i(n) && s(n, c, a), a.global)) l ? (t[e] = n) : o(e, n);
            else {
              try {
                a.unsafe ? t[e] && (l = !0) : delete t[e];
              } catch (t) {}
              l
                ? (t[e] = n)
                : r.f(t, e, {
                    value: n,
                    enumerable: !1,
                    configurable: !a.nonConfigurable,
                    writable: !a.nonWritable,
                  });
            }
            return t;
          };
        },
        6279: (t, e, n) => {
          "use strict";
          var i = n(6840);
          t.exports = function (t, e, n) {
            for (var r in e) i(t, r, e[r], n);
            return t;
          };
        },
        9433: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = Object.defineProperty;
          t.exports = function (t, e) {
            try {
              r(i, t, {
                value: e,
                configurable: !0,
                writable: !0,
              });
            } catch (n) {
              i[t] = e;
            }
            return e;
          };
        },
        3724: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = !i(function () {
            return (
              7 !==
              Object.defineProperty({}, 1, {
                get: function () {
                  return 7;
                },
              })[1]
            );
          });
        },
        4055: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(34),
            s = i.document,
            o = r(s) && r(s.createElement);
          t.exports = function (t) {
            return o ? s.createElement(t) : {};
          };
        },
        7400: (t) => {
          "use strict";
          t.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0,
          };
        },
        9296: (t, e, n) => {
          "use strict";
          var i = n(4055)("span").classList,
            r = i && i.constructor && i.constructor.prototype;
          t.exports = r === Object.prototype ? void 0 : r;
        },
        9088: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(4576);
          t.exports = "process" === r(i.process);
        },
        9392: (t) => {
          "use strict";
          t.exports =
            ("undefined" != typeof navigator && String(navigator.userAgent)) ||
            "";
        },
        7388: (t, e, n) => {
          "use strict";
          var i,
            r,
            s = n(4475),
            o = n(9392),
            a = s.process,
            l = s.Deno,
            c = (a && a.versions) || (l && l.version),
            u = c && c.v8;
          u && (r = (i = u.split("."))[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])),
            !r &&
              o &&
              (!(i = o.match(/Edge\/(\d+)/)) || i[1] >= 74) &&
              (i = o.match(/Chrome\/(\d+)/)) &&
              (r = +i[1]),
            (t.exports = r);
        },
        8727: (t) => {
          "use strict";
          t.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf",
          ];
        },
        6518: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(7347).f,
            s = n(6699),
            o = n(6840),
            a = n(9433),
            l = n(7740),
            c = n(2796);
          t.exports = function (t, e) {
            var n,
              u,
              h,
              d,
              p,
              f = t.target,
              m = t.global,
              g = t.stat;
            if ((n = m ? i : g ? i[f] || a(f, {}) : i[f] && i[f].prototype))
              for (u in e) {
                if (
                  ((d = e[u]),
                  (h = t.dontCallGetSet ? (p = r(n, u)) && p.value : n[u]),
                  !c(m ? u : f + (g ? "." : "#") + u, t.forced) && void 0 !== h)
                ) {
                  if (typeof d == typeof h) continue;
                  l(d, h);
                }
                (t.sham || (h && h.sham)) && s(d, "sham", !0), o(n, u, d, t);
              }
          };
        },
        9039: (t) => {
          "use strict";
          t.exports = function (t) {
            try {
              return !!t();
            } catch (t) {
              return !0;
            }
          };
        },
        9228: (t, e, n) => {
          "use strict";
          n(7495);
          var i = n(9565),
            r = n(6840),
            s = n(7323),
            o = n(9039),
            a = n(8227),
            l = n(6699),
            c = a("species"),
            u = RegExp.prototype;
          t.exports = function (t, e, n, h) {
            var d = a(t),
              p = !o(function () {
                var e = {};
                return (
                  (e[d] = function () {
                    return 7;
                  }),
                  7 !== ""[t](e)
                );
              }),
              f =
                p &&
                !o(function () {
                  var e = !1,
                    n = /a/;
                  return (
                    "split" === t &&
                      (((n = {}).constructor = {}),
                      (n.constructor[c] = function () {
                        return n;
                      }),
                      (n.flags = ""),
                      (n[d] = /./[d])),
                    (n.exec = function () {
                      return (e = !0), null;
                    }),
                    n[d](""),
                    !e
                  );
                });
            if (!p || !f || n) {
              var m = /./[d],
                g = e(d, ""[t], function (t, e, n, r, o) {
                  var a = e.exec;
                  return a === s || a === u.exec
                    ? p && !o
                      ? {
                          done: !0,
                          value: i(m, e, n, r),
                        }
                      : {
                          done: !0,
                          value: i(t, n, e, r),
                        }
                    : {
                        done: !1,
                      };
                });
              r(String.prototype, t, g[0]), r(u, d, g[1]);
            }
            h && l(u[d], "sham", !0);
          };
        },
        2744: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = !i(function () {
            return Object.isExtensible(Object.preventExtensions({}));
          });
        },
        8745: (t, e, n) => {
          "use strict";
          var i = n(616),
            r = Function.prototype,
            s = r.apply,
            o = r.call;
          t.exports =
            ("object" == typeof Reflect && Reflect.apply) ||
            (i
              ? o.bind(s)
              : function () {
                  return o.apply(s, arguments);
                });
        },
        6080: (t, e, n) => {
          "use strict";
          var i = n(7476),
            r = n(9306),
            s = n(616),
            o = i(i.bind);
          t.exports = function (t, e) {
            return (
              r(t),
              void 0 === e
                ? t
                : s
                ? o(t, e)
                : function () {
                    return t.apply(e, arguments);
                  }
            );
          };
        },
        616: (t, e, n) => {
          "use strict";
          var i = n(9039);
          t.exports = !i(function () {
            var t = function () {}.bind();
            return "function" != typeof t || t.hasOwnProperty("prototype");
          });
        },
        9565: (t, e, n) => {
          "use strict";
          var i = n(616),
            r = Function.prototype.call;
          t.exports = i
            ? r.bind(r)
            : function () {
                return r.apply(r, arguments);
              };
        },
        350: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(9297),
            s = Function.prototype,
            o = i && Object.getOwnPropertyDescriptor,
            a = r(s, "name"),
            l = a && "something" === function () {}.name,
            c = a && (!i || (i && o(s, "name").configurable));
          t.exports = {
            EXISTS: a,
            PROPER: l,
            CONFIGURABLE: c,
          };
        },
        6706: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(9306);
          t.exports = function (t, e, n) {
            try {
              return i(r(Object.getOwnPropertyDescriptor(t, e)[n]));
            } catch (t) {}
          };
        },
        7476: (t, e, n) => {
          "use strict";
          var i = n(4576),
            r = n(9504);
          t.exports = function (t) {
            if ("Function" === i(t)) return r(t);
          };
        },
        9504: (t, e, n) => {
          "use strict";
          var i = n(616),
            r = Function.prototype,
            s = r.call,
            o = i && r.bind.bind(s, s);
          t.exports = i
            ? o
            : function (t) {
                return function () {
                  return s.apply(t, arguments);
                };
              };
        },
        7751: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(4901);
          t.exports = function (t, e) {
            return arguments.length < 2
              ? ((n = i[t]), r(n) ? n : void 0)
              : i[t] && i[t][e];
            var n;
          };
        },
        851: (t, e, n) => {
          "use strict";
          var i = n(6955),
            r = n(5966),
            s = n(4117),
            o = n(6269),
            a = n(8227)("iterator");
          t.exports = function (t) {
            if (!s(t)) return r(t, a) || r(t, "@@iterator") || o[i(t)];
          };
        },
        81: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(9306),
            s = n(8551),
            o = n(6823),
            a = n(851),
            l = TypeError;
          t.exports = function (t, e) {
            var n = arguments.length < 2 ? a(t) : e;
            if (r(n)) return s(i(n, t));
            throw new l(o(t) + " is not iterable");
          };
        },
        5966: (t, e, n) => {
          "use strict";
          var i = n(9306),
            r = n(4117);
          t.exports = function (t, e) {
            var n = t[e];
            return r(n) ? void 0 : i(n);
          };
        },
        2478: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(8981),
            s = Math.floor,
            o = i("".charAt),
            a = i("".replace),
            l = i("".slice),
            c = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
            u = /\$([$&'`]|\d{1,2})/g;
          t.exports = function (t, e, n, i, h, d) {
            var p = n + t.length,
              f = i.length,
              m = u;
            return (
              void 0 !== h && ((h = r(h)), (m = c)),
              a(d, m, function (r, a) {
                var c;
                switch (o(a, 0)) {
                  case "$":
                    return "$";
                  case "&":
                    return t;
                  case "`":
                    return l(e, 0, n);
                  case "'":
                    return l(e, p);
                  case "<":
                    c = h[l(a, 1, -1)];
                    break;
                  default:
                    var u = +a;
                    if (0 === u) return r;
                    if (u > f) {
                      var d = s(u / 10);
                      return 0 === d
                        ? r
                        : d <= f
                        ? void 0 === i[d - 1]
                          ? o(a, 1)
                          : i[d - 1] + o(a, 1)
                        : r;
                    }
                    c = i[u - 1];
                }
                return void 0 === c ? "" : c;
              })
            );
          };
        },
        4475: function (t, e, n) {
          "use strict";
          var i = function (t) {
            return t && t.Math === Math && t;
          };
          t.exports =
            i("object" == typeof globalThis && globalThis) ||
            i("object" == typeof window && window) ||
            i("object" == typeof self && self) ||
            i("object" == typeof n.g && n.g) ||
            i("object" == typeof this && this) ||
            (function () {
              return this;
            })() ||
            Function("return this")();
        },
        9297: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(8981),
            s = i({}.hasOwnProperty);
          t.exports =
            Object.hasOwn ||
            function (t, e) {
              return s(r(t), e);
            };
        },
        421: (t) => {
          "use strict";
          t.exports = {};
        },
        397: (t, e, n) => {
          "use strict";
          var i = n(7751);
          t.exports = i("document", "documentElement");
        },
        5917: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(9039),
            s = n(4055);
          t.exports =
            !i &&
            !r(function () {
              return (
                7 !==
                Object.defineProperty(s("div"), "a", {
                  get: function () {
                    return 7;
                  },
                }).a
              );
            });
        },
        7055: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(9039),
            s = n(4576),
            o = Object,
            a = i("".split);
          t.exports = r(function () {
            return !o("z").propertyIsEnumerable(0);
          })
            ? function (t) {
                return "String" === s(t) ? a(t, "") : o(t);
              }
            : o;
        },
        3167: (t, e, n) => {
          "use strict";
          var i = n(4901),
            r = n(34),
            s = n(2967);
          t.exports = function (t, e, n) {
            var o, a;
            return (
              s &&
                i((o = e.constructor)) &&
                o !== n &&
                r((a = o.prototype)) &&
                a !== n.prototype &&
                s(t, a),
              t
            );
          };
        },
        3706: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(4901),
            s = n(7629),
            o = i(Function.toString);
          r(s.inspectSource) ||
            (s.inspectSource = function (t) {
              return o(t);
            }),
            (t.exports = s.inspectSource);
        },
        3451: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(9504),
            s = n(421),
            o = n(34),
            a = n(9297),
            l = n(4913).f,
            c = n(8480),
            u = n(298),
            h = n(4124),
            d = n(3392),
            p = n(2744),
            f = !1,
            m = d("meta"),
            g = 0,
            v = function (t) {
              l(t, m, {
                value: {
                  objectID: "O" + g++,
                  weakData: {},
                },
              });
            },
            y = (t.exports = {
              enable: function () {
                (y.enable = function () {}), (f = !0);
                var t = c.f,
                  e = r([].splice),
                  n = {};
                (n[m] = 1),
                  t(n).length &&
                    ((c.f = function (n) {
                      for (var i = t(n), r = 0, s = i.length; r < s; r++)
                        if (i[r] === m) {
                          e(i, r, 1);
                          break;
                        }
                      return i;
                    }),
                    i(
                      {
                        target: "Object",
                        stat: !0,
                        forced: !0,
                      },
                      {
                        getOwnPropertyNames: u.f,
                      }
                    ));
              },
              fastKey: function (t, e) {
                if (!o(t))
                  return "symbol" == typeof t
                    ? t
                    : ("string" == typeof t ? "S" : "P") + t;
                if (!a(t, m)) {
                  if (!h(t)) return "F";
                  if (!e) return "E";
                  v(t);
                }
                return t[m].objectID;
              },
              getWeakData: function (t, e) {
                if (!a(t, m)) {
                  if (!h(t)) return !0;
                  if (!e) return !1;
                  v(t);
                }
                return t[m].weakData;
              },
              onFreeze: function (t) {
                return p && f && h(t) && !a(t, m) && v(t), t;
              },
            });
          s[m] = !0;
        },
        1181: (t, e, n) => {
          "use strict";
          var i,
            r,
            s,
            o = n(8622),
            a = n(4475),
            l = n(34),
            c = n(6699),
            u = n(9297),
            h = n(7629),
            d = n(6119),
            p = n(421),
            f = "Object already initialized",
            m = a.TypeError,
            g = a.WeakMap;
          if (o || h.state) {
            var v = h.state || (h.state = new g());
            (v.get = v.get),
              (v.has = v.has),
              (v.set = v.set),
              (i = function (t, e) {
                if (v.has(t)) throw new m(f);
                return (e.facade = t), v.set(t, e), e;
              }),
              (r = function (t) {
                return v.get(t) || {};
              }),
              (s = function (t) {
                return v.has(t);
              });
          } else {
            var y = d("state");
            (p[y] = !0),
              (i = function (t, e) {
                if (u(t, y)) throw new m(f);
                return (e.facade = t), c(t, y, e), e;
              }),
              (r = function (t) {
                return u(t, y) ? t[y] : {};
              }),
              (s = function (t) {
                return u(t, y);
              });
          }
          t.exports = {
            set: i,
            get: r,
            has: s,
            enforce: function (t) {
              return s(t) ? r(t) : i(t, {});
            },
            getterFor: function (t) {
              return function (e) {
                var n;
                if (!l(e) || (n = r(e)).type !== t)
                  throw new m("Incompatible receiver, " + t + " required");
                return n;
              };
            },
          };
        },
        4209: (t, e, n) => {
          "use strict";
          var i = n(8227),
            r = n(6269),
            s = i("iterator"),
            o = Array.prototype;
          t.exports = function (t) {
            return void 0 !== t && (r.Array === t || o[s] === t);
          };
        },
        4376: (t, e, n) => {
          "use strict";
          var i = n(4576);
          t.exports =
            Array.isArray ||
            function (t) {
              return "Array" === i(t);
            };
        },
        4901: (t) => {
          "use strict";
          var e = "object" == typeof document && document.all;
          t.exports =
            void 0 === e && void 0 !== e
              ? function (t) {
                  return "function" == typeof t || t === e;
                }
              : function (t) {
                  return "function" == typeof t;
                };
        },
        3517: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(9039),
            s = n(4901),
            o = n(6955),
            a = n(7751),
            l = n(3706),
            c = function () {},
            u = a("Reflect", "construct"),
            h = /^\s*(?:class|function)\b/,
            d = i(h.exec),
            p = !h.test(c),
            f = function (t) {
              if (!s(t)) return !1;
              try {
                return u(c, [], t), !0;
              } catch (t) {
                return !1;
              }
            },
            m = function (t) {
              if (!s(t)) return !1;
              switch (o(t)) {
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                  return !1;
              }
              try {
                return p || !!d(h, l(t));
              } catch (t) {
                return !0;
              }
            };
          (m.sham = !0),
            (t.exports =
              !u ||
              r(function () {
                var t;
                return (
                  f(f.call) ||
                  !f(Object) ||
                  !f(function () {
                    t = !0;
                  }) ||
                  t
                );
              })
                ? m
                : f);
        },
        2796: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(4901),
            s = /#|\.prototype\./,
            o = function (t, e) {
              var n = l[a(t)];
              return n === u || (n !== c && (r(e) ? i(e) : !!e));
            },
            a = (o.normalize = function (t) {
              return String(t).replace(s, ".").toLowerCase();
            }),
            l = (o.data = {}),
            c = (o.NATIVE = "N"),
            u = (o.POLYFILL = "P");
          t.exports = o;
        },
        4117: (t) => {
          "use strict";
          t.exports = function (t) {
            return null == t;
          };
        },
        34: (t, e, n) => {
          "use strict";
          var i = n(4901);
          t.exports = function (t) {
            return "object" == typeof t ? null !== t : i(t);
          };
        },
        3925: (t, e, n) => {
          "use strict";
          var i = n(34);
          t.exports = function (t) {
            return i(t) || null === t;
          };
        },
        6395: (t) => {
          "use strict";
          t.exports = !1;
        },
        757: (t, e, n) => {
          "use strict";
          var i = n(7751),
            r = n(4901),
            s = n(1625),
            o = n(7040),
            a = Object;
          t.exports = o
            ? function (t) {
                return "symbol" == typeof t;
              }
            : function (t) {
                var e = i("Symbol");
                return r(e) && s(e.prototype, a(t));
              };
        },
        2652: (t, e, n) => {
          "use strict";
          var i = n(6080),
            r = n(9565),
            s = n(8551),
            o = n(6823),
            a = n(4209),
            l = n(6198),
            c = n(1625),
            u = n(81),
            h = n(851),
            d = n(9539),
            p = TypeError,
            f = function (t, e) {
              (this.stopped = t), (this.result = e);
            },
            m = f.prototype;
          t.exports = function (t, e, n) {
            var g,
              v,
              y,
              _,
              x,
              b,
              w,
              E = n && n.that,
              S = !(!n || !n.AS_ENTRIES),
              M = !(!n || !n.IS_RECORD),
              T = !(!n || !n.IS_ITERATOR),
              A = !(!n || !n.INTERRUPTED),
              R = i(e, E),
              C = function (t) {
                return g && d(g, "normal", t), new f(!0, t);
              },
              L = function (t) {
                return S
                  ? (s(t), A ? R(t[0], t[1], C) : R(t[0], t[1]))
                  : A
                  ? R(t, C)
                  : R(t);
              };
            if (M) g = t.iterator;
            else if (T) g = t;
            else {
              if (!(v = h(t))) throw new p(o(t) + " is not iterable");
              if (a(v)) {
                for (y = 0, _ = l(t); _ > y; y++)
                  if ((x = L(t[y])) && c(m, x)) return x;
                return new f(!1);
              }
              g = u(t, v);
            }
            for (b = M ? t.next : g.next; !(w = r(b, g)).done; ) {
              try {
                x = L(w.value);
              } catch (t) {
                d(g, "throw", t);
              }
              if ("object" == typeof x && x && c(m, x)) return x;
            }
            return new f(!1);
          };
        },
        9539: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(8551),
            s = n(5966);
          t.exports = function (t, e, n) {
            var o, a;
            r(t);
            try {
              if (!(o = s(t, "return"))) {
                if ("throw" === e) throw n;
                return n;
              }
              o = i(o, t);
            } catch (t) {
              (a = !0), (o = t);
            }
            if ("throw" === e) throw n;
            if (a) throw o;
            return r(o), n;
          };
        },
        3994: (t, e, n) => {
          "use strict";
          var i = n(7657).IteratorPrototype,
            r = n(2360),
            s = n(6980),
            o = n(687),
            a = n(6269),
            l = function () {
              return this;
            };
          t.exports = function (t, e, n, c) {
            var u = e + " Iterator";
            return (
              (t.prototype = r(i, {
                next: s(+!c, n),
              })),
              o(t, u, !1, !0),
              (a[u] = l),
              t
            );
          };
        },
        1088: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(9565),
            s = n(6395),
            o = n(350),
            a = n(4901),
            l = n(3994),
            c = n(2787),
            u = n(2967),
            h = n(687),
            d = n(6699),
            p = n(6840),
            f = n(8227),
            m = n(6269),
            g = n(7657),
            v = o.PROPER,
            y = o.CONFIGURABLE,
            _ = g.IteratorPrototype,
            x = g.BUGGY_SAFARI_ITERATORS,
            b = f("iterator"),
            w = "keys",
            E = "values",
            S = "entries",
            M = function () {
              return this;
            };
          t.exports = function (t, e, n, o, f, g, T) {
            l(n, e, o);
            var A,
              R,
              C,
              L = function (t) {
                if (t === f && D) return D;
                if (!x && t && t in I) return I[t];
                switch (t) {
                  case w:
                  case E:
                  case S:
                    return function () {
                      return new n(this, t);
                    };
                }
                return function () {
                  return new n(this);
                };
              },
              P = e + " Iterator",
              O = !1,
              I = t.prototype,
              N = I[b] || I["@@iterator"] || (f && I[f]),
              D = (!x && N) || L(f),
              U = ("Array" === e && I.entries) || N;
            if (
              (U &&
                (A = c(U.call(new t()))) !== Object.prototype &&
                A.next &&
                (s || c(A) === _ || (u ? u(A, _) : a(A[b]) || p(A, b, M)),
                h(A, P, !0, !0),
                s && (m[P] = M)),
              v &&
                f === E &&
                N &&
                N.name !== E &&
                (!s && y
                  ? d(I, "name", E)
                  : ((O = !0),
                    (D = function () {
                      return r(N, this);
                    }))),
              f)
            )
              if (
                ((R = {
                  values: L(E),
                  keys: g ? D : L(w),
                  entries: L(S),
                }),
                T)
              )
                for (C in R) (x || O || !(C in I)) && p(I, C, R[C]);
              else
                i(
                  {
                    target: e,
                    proto: !0,
                    forced: x || O,
                  },
                  R
                );
            return (
              (s && !T) ||
                I[b] === D ||
                p(I, b, D, {
                  name: f,
                }),
              (m[e] = D),
              R
            );
          };
        },
        7657: (t, e, n) => {
          "use strict";
          var i,
            r,
            s,
            o = n(9039),
            a = n(4901),
            l = n(34),
            c = n(2360),
            u = n(2787),
            h = n(6840),
            d = n(8227),
            p = n(6395),
            f = d("iterator"),
            m = !1;
          [].keys &&
            ("next" in (s = [].keys())
              ? (r = u(u(s))) !== Object.prototype && (i = r)
              : (m = !0)),
            !l(i) ||
            o(function () {
              var t = {};
              return i[f].call(t) !== t;
            })
              ? (i = {})
              : p && (i = c(i)),
            a(i[f]) ||
              h(i, f, function () {
                return this;
              }),
            (t.exports = {
              IteratorPrototype: i,
              BUGGY_SAFARI_ITERATORS: m,
            });
        },
        6269: (t) => {
          "use strict";
          t.exports = {};
        },
        6198: (t, e, n) => {
          "use strict";
          var i = n(8014);
          t.exports = function (t) {
            return i(t.length);
          };
        },
        283: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(9039),
            s = n(4901),
            o = n(9297),
            a = n(3724),
            l = n(350).CONFIGURABLE,
            c = n(3706),
            u = n(1181),
            h = u.enforce,
            d = u.get,
            p = String,
            f = Object.defineProperty,
            m = i("".slice),
            g = i("".replace),
            v = i([].join),
            y =
              a &&
              !r(function () {
                return (
                  8 !==
                  f(function () {}, "length", {
                    value: 8,
                  }).length
                );
              }),
            _ = String(String).split("String"),
            x = (t.exports = function (t, e, n) {
              "Symbol(" === m(p(e), 0, 7) &&
                (e = "[" + g(p(e), /^Symbol\(([^)]*)\).*$/, "$1") + "]"),
                n && n.getter && (e = "get " + e),
                n && n.setter && (e = "set " + e),
                (!o(t, "name") || (l && t.name !== e)) &&
                  (a
                    ? f(t, "name", {
                        value: e,
                        configurable: !0,
                      })
                    : (t.name = e)),
                y &&
                  n &&
                  o(n, "arity") &&
                  t.length !== n.arity &&
                  f(t, "length", {
                    value: n.arity,
                  });
              try {
                n && o(n, "constructor") && n.constructor
                  ? a &&
                    f(t, "prototype", {
                      writable: !1,
                    })
                  : t.prototype && (t.prototype = void 0);
              } catch (t) {}
              var i = h(t);
              return (
                o(i, "source") ||
                  (i.source = v(_, "string" == typeof e ? e : "")),
                t
              );
            });
          Function.prototype.toString = x(function () {
            return (s(this) && d(this).source) || c(this);
          }, "toString");
        },
        741: (t) => {
          "use strict";
          var e = Math.ceil,
            n = Math.floor;
          t.exports =
            Math.trunc ||
            function (t) {
              var i = +t;
              return (i > 0 ? n : e)(i);
            };
        },
        2703: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(9039),
            s = n(9504),
            o = n(655),
            a = n(3802).trim,
            l = n(7452),
            c = i.parseInt,
            u = i.Symbol,
            h = u && u.iterator,
            d = /^[+-]?0x/i,
            p = s(d.exec),
            f =
              8 !== c(l + "08") ||
              22 !== c(l + "0x16") ||
              (h &&
                !r(function () {
                  c(Object(h));
                }));
          t.exports = f
            ? function (t, e) {
                var n = a(o(t));
                return c(n, e >>> 0 || (p(d, n) ? 16 : 10));
              }
            : c;
        },
        4213: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(9504),
            s = n(9565),
            o = n(9039),
            a = n(1072),
            l = n(3717),
            c = n(8773),
            u = n(8981),
            h = n(7055),
            d = Object.assign,
            p = Object.defineProperty,
            f = r([].concat);
          t.exports =
            !d ||
            o(function () {
              if (
                i &&
                1 !==
                  d(
                    {
                      b: 1,
                    },
                    d(
                      p({}, "a", {
                        enumerable: !0,
                        get: function () {
                          p(this, "b", {
                            value: 3,
                            enumerable: !1,
                          });
                        },
                      }),
                      {
                        b: 2,
                      }
                    )
                  ).b
              )
                return !0;
              var t = {},
                e = {},
                n = Symbol("assign detection"),
                r = "abcdefghijklmnopqrst";
              return (
                (t[n] = 7),
                r.split("").forEach(function (t) {
                  e[t] = t;
                }),
                7 !== d({}, t)[n] || a(d({}, e)).join("") !== r
              );
            })
              ? function (t, e) {
                  for (
                    var n = u(t), r = arguments.length, o = 1, d = l.f, p = c.f;
                    r > o;

                  )
                    for (
                      var m,
                        g = h(arguments[o++]),
                        v = d ? f(a(g), d(g)) : a(g),
                        y = v.length,
                        _ = 0;
                      y > _;

                    )
                      (m = v[_++]), (i && !s(p, g, m)) || (n[m] = g[m]);
                  return n;
                }
              : d;
        },
        2360: (t, e, n) => {
          "use strict";
          var i,
            r = n(8551),
            s = n(6801),
            o = n(8727),
            a = n(421),
            l = n(397),
            c = n(4055),
            u = n(6119),
            h = "prototype",
            d = "script",
            p = u("IE_PROTO"),
            f = function () {},
            m = function (t) {
              return "<" + d + ">" + t + "</" + d + ">";
            },
            g = function (t) {
              t.write(m("")), t.close();
              var e = t.parentWindow.Object;
              return (t = null), e;
            },
            v = function () {
              try {
                i = new ActiveXObject("htmlfile");
              } catch (t) {}
              var t, e, n;
              v =
                "undefined" != typeof document
                  ? document.domain && i
                    ? g(i)
                    : ((e = c("iframe")),
                      (n = "java" + d + ":"),
                      (e.style.display = "none"),
                      l.appendChild(e),
                      (e.src = String(n)),
                      (t = e.contentWindow.document).open(),
                      t.write(m("document.F=Object")),
                      t.close(),
                      t.F)
                  : g(i);
              for (var r = o.length; r--; ) delete v[h][o[r]];
              return v();
            };
          (a[p] = !0),
            (t.exports =
              Object.create ||
              function (t, e) {
                var n;
                return (
                  null !== t
                    ? ((f[h] = r(t)), (n = new f()), (f[h] = null), (n[p] = t))
                    : (n = v()),
                  void 0 === e ? n : s.f(n, e)
                );
              });
        },
        6801: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(8686),
            s = n(4913),
            o = n(8551),
            a = n(5397),
            l = n(1072);
          e.f =
            i && !r
              ? Object.defineProperties
              : function (t, e) {
                  o(t);
                  for (var n, i = a(e), r = l(e), c = r.length, u = 0; c > u; )
                    s.f(t, (n = r[u++]), i[n]);
                  return t;
                };
        },
        4913: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(5917),
            s = n(8686),
            o = n(8551),
            a = n(6969),
            l = TypeError,
            c = Object.defineProperty,
            u = Object.getOwnPropertyDescriptor,
            h = "enumerable",
            d = "configurable",
            p = "writable";
          e.f = i
            ? s
              ? function (t, e, n) {
                  if (
                    (o(t),
                    (e = a(e)),
                    o(n),
                    "function" == typeof t &&
                      "prototype" === e &&
                      "value" in n &&
                      p in n &&
                      !n[p])
                  ) {
                    var i = u(t, e);
                    i &&
                      i[p] &&
                      ((t[e] = n.value),
                      (n = {
                        configurable: d in n ? n[d] : i[d],
                        enumerable: h in n ? n[h] : i[h],
                        writable: !1,
                      }));
                  }
                  return c(t, e, n);
                }
              : c
            : function (t, e, n) {
                if ((o(t), (e = a(e)), o(n), r))
                  try {
                    return c(t, e, n);
                  } catch (t) {}
                if ("get" in n || "set" in n)
                  throw new l("Accessors not supported");
                return "value" in n && (t[e] = n.value), t;
              };
        },
        7347: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(9565),
            s = n(8773),
            o = n(6980),
            a = n(5397),
            l = n(6969),
            c = n(9297),
            u = n(5917),
            h = Object.getOwnPropertyDescriptor;
          e.f = i
            ? h
            : function (t, e) {
                if (((t = a(t)), (e = l(e)), u))
                  try {
                    return h(t, e);
                  } catch (t) {}
                if (c(t, e)) return o(!r(s.f, t, e), t[e]);
              };
        },
        298: (t, e, n) => {
          "use strict";
          var i = n(4576),
            r = n(5397),
            s = n(8480).f,
            o = n(7680),
            a =
              "object" == typeof window && window && Object.getOwnPropertyNames
                ? Object.getOwnPropertyNames(window)
                : [];
          t.exports.f = function (t) {
            return a && "Window" === i(t)
              ? (function (t) {
                  try {
                    return s(t);
                  } catch (t) {
                    return o(a);
                  }
                })(t)
              : s(r(t));
          };
        },
        8480: (t, e, n) => {
          "use strict";
          var i = n(1828),
            r = n(8727).concat("length", "prototype");
          e.f =
            Object.getOwnPropertyNames ||
            function (t) {
              return i(t, r);
            };
        },
        3717: (t, e) => {
          "use strict";
          e.f = Object.getOwnPropertySymbols;
        },
        2787: (t, e, n) => {
          "use strict";
          var i = n(9297),
            r = n(4901),
            s = n(8981),
            o = n(6119),
            a = n(2211),
            l = o("IE_PROTO"),
            c = Object,
            u = c.prototype;
          t.exports = a
            ? c.getPrototypeOf
            : function (t) {
                var e = s(t);
                if (i(e, l)) return e[l];
                var n = e.constructor;
                return r(n) && e instanceof n
                  ? n.prototype
                  : e instanceof c
                  ? u
                  : null;
              };
        },
        4124: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(34),
            s = n(4576),
            o = n(5652),
            a = Object.isExtensible,
            l = i(function () {
              a(1);
            });
          t.exports =
            l || o
              ? function (t) {
                  return (
                    !!r(t) && (!o || "ArrayBuffer" !== s(t)) && (!a || a(t))
                  );
                }
              : a;
        },
        1625: (t, e, n) => {
          "use strict";
          var i = n(9504);
          t.exports = i({}.isPrototypeOf);
        },
        1828: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(9297),
            s = n(5397),
            o = n(9617).indexOf,
            a = n(421),
            l = i([].push);
          t.exports = function (t, e) {
            var n,
              i = s(t),
              c = 0,
              u = [];
            for (n in i) !r(a, n) && r(i, n) && l(u, n);
            for (; e.length > c; ) r(i, (n = e[c++])) && (~o(u, n) || l(u, n));
            return u;
          };
        },
        1072: (t, e, n) => {
          "use strict";
          var i = n(1828),
            r = n(8727);
          t.exports =
            Object.keys ||
            function (t) {
              return i(t, r);
            };
        },
        8773: (t, e) => {
          "use strict";
          var n = {}.propertyIsEnumerable,
            i = Object.getOwnPropertyDescriptor,
            r =
              i &&
              !n.call(
                {
                  1: 2,
                },
                1
              );
          e.f = r
            ? function (t) {
                var e = i(this, t);
                return !!e && e.enumerable;
              }
            : n;
        },
        2967: (t, e, n) => {
          "use strict";
          var i = n(6706),
            r = n(34),
            s = n(7750),
            o = n(3506);
          t.exports =
            Object.setPrototypeOf ||
            ("__proto__" in {}
              ? (function () {
                  var t,
                    e = !1,
                    n = {};
                  try {
                    (t = i(Object.prototype, "__proto__", "set"))(n, []),
                      (e = n instanceof Array);
                  } catch (t) {}
                  return function (n, i) {
                    return (
                      s(n),
                      o(i),
                      r(n) ? (e ? t(n, i) : (n.__proto__ = i), n) : n
                    );
                  };
                })()
              : void 0);
        },
        3179: (t, e, n) => {
          "use strict";
          var i = n(2140),
            r = n(6955);
          t.exports = i
            ? {}.toString
            : function () {
                return "[object " + r(this) + "]";
              };
        },
        4270: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(4901),
            s = n(34),
            o = TypeError;
          t.exports = function (t, e) {
            var n, a;
            if ("string" === e && r((n = t.toString)) && !s((a = i(n, t))))
              return a;
            if (r((n = t.valueOf)) && !s((a = i(n, t)))) return a;
            if ("string" !== e && r((n = t.toString)) && !s((a = i(n, t))))
              return a;
            throw new o("Can't convert object to primitive value");
          };
        },
        5031: (t, e, n) => {
          "use strict";
          var i = n(7751),
            r = n(9504),
            s = n(8480),
            o = n(3717),
            a = n(8551),
            l = r([].concat);
          t.exports =
            i("Reflect", "ownKeys") ||
            function (t) {
              var e = s.f(a(t)),
                n = o.f;
              return n ? l(e, n(t)) : e;
            };
        },
        6682: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(8551),
            s = n(4901),
            o = n(4576),
            a = n(7323),
            l = TypeError;
          t.exports = function (t, e) {
            var n = t.exec;
            if (s(n)) {
              var c = i(n, t, e);
              return null !== c && r(c), c;
            }
            if ("RegExp" === o(t)) return i(a, t, e);
            throw new l("RegExp#exec called on incompatible receiver");
          };
        },
        7323: (t, e, n) => {
          "use strict";
          var i,
            r,
            s = n(9565),
            o = n(9504),
            a = n(655),
            l = n(7979),
            c = n(8429),
            u = n(5745),
            h = n(2360),
            d = n(1181).get,
            p = n(3635),
            f = n(8814),
            m = u("native-string-replace", String.prototype.replace),
            g = RegExp.prototype.exec,
            v = g,
            y = o("".charAt),
            _ = o("".indexOf),
            x = o("".replace),
            b = o("".slice),
            w =
              ((r = /b*/g),
              s(g, (i = /a/), "a"),
              s(g, r, "a"),
              0 !== i.lastIndex || 0 !== r.lastIndex),
            E = c.BROKEN_CARET,
            S = void 0 !== /()??/.exec("")[1];
          (w || S || E || p || f) &&
            (v = function (t) {
              var e,
                n,
                i,
                r,
                o,
                c,
                u,
                p = this,
                f = d(p),
                M = a(t),
                T = f.raw;
              if (T)
                return (
                  (T.lastIndex = p.lastIndex),
                  (e = s(v, T, M)),
                  (p.lastIndex = T.lastIndex),
                  e
                );
              var A = f.groups,
                R = E && p.sticky,
                C = s(l, p),
                L = p.source,
                P = 0,
                O = M;
              if (
                (R &&
                  ((C = x(C, "y", "")),
                  -1 === _(C, "g") && (C += "g"),
                  (O = b(M, p.lastIndex)),
                  p.lastIndex > 0 &&
                    (!p.multiline ||
                      (p.multiline && "\n" !== y(M, p.lastIndex - 1))) &&
                    ((L = "(?: " + L + ")"), (O = " " + O), P++),
                  (n = new RegExp("^(?:" + L + ")", C))),
                S && (n = new RegExp("^" + L + "$(?!\\s)", C)),
                w && (i = p.lastIndex),
                (r = s(g, R ? n : p, O)),
                R
                  ? r
                    ? ((r.input = b(r.input, P)),
                      (r[0] = b(r[0], P)),
                      (r.index = p.lastIndex),
                      (p.lastIndex += r[0].length))
                    : (p.lastIndex = 0)
                  : w &&
                    r &&
                    (p.lastIndex = p.global ? r.index + r[0].length : i),
                S &&
                  r &&
                  r.length > 1 &&
                  s(m, r[0], n, function () {
                    for (o = 1; o < arguments.length - 2; o++)
                      void 0 === arguments[o] && (r[o] = void 0);
                  }),
                r && A)
              )
                for (r.groups = c = h(null), o = 0; o < A.length; o++)
                  c[(u = A[o])[0]] = r[u[1]];
              return r;
            }),
            (t.exports = v);
        },
        7979: (t, e, n) => {
          "use strict";
          var i = n(8551);
          t.exports = function () {
            var t = i(this),
              e = "";
            return (
              t.hasIndices && (e += "d"),
              t.global && (e += "g"),
              t.ignoreCase && (e += "i"),
              t.multiline && (e += "m"),
              t.dotAll && (e += "s"),
              t.unicode && (e += "u"),
              t.unicodeSets && (e += "v"),
              t.sticky && (e += "y"),
              e
            );
          };
        },
        8429: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(4475).RegExp,
            s = i(function () {
              var t = r("a", "y");
              return (t.lastIndex = 2), null !== t.exec("abcd");
            }),
            o =
              s ||
              i(function () {
                return !r("a", "y").sticky;
              }),
            a =
              s ||
              i(function () {
                var t = r("^r", "gy");
                return (t.lastIndex = 2), null !== t.exec("str");
              });
          t.exports = {
            BROKEN_CARET: a,
            MISSED_STICKY: o,
            UNSUPPORTED_Y: s,
          };
        },
        3635: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(4475).RegExp;
          t.exports = i(function () {
            var t = r(".", "s");
            return !(t.dotAll && t.test("\n") && "s" === t.flags);
          });
        },
        8814: (t, e, n) => {
          "use strict";
          var i = n(9039),
            r = n(4475).RegExp;
          t.exports = i(function () {
            var t = r("(?<a>b)", "g");
            return (
              "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c")
            );
          });
        },
        7750: (t, e, n) => {
          "use strict";
          var i = n(4117),
            r = TypeError;
          t.exports = function (t) {
            if (i(t)) throw new r("Can't call method on " + t);
            return t;
          };
        },
        687: (t, e, n) => {
          "use strict";
          var i = n(4913).f,
            r = n(9297),
            s = n(8227)("toStringTag");
          t.exports = function (t, e, n) {
            t && !n && (t = t.prototype),
              t &&
                !r(t, s) &&
                i(t, s, {
                  configurable: !0,
                  value: e,
                });
          };
        },
        6119: (t, e, n) => {
          "use strict";
          var i = n(5745),
            r = n(3392),
            s = i("keys");
          t.exports = function (t) {
            return s[t] || (s[t] = r(t));
          };
        },
        7629: (t, e, n) => {
          "use strict";
          var i = n(6395),
            r = n(4475),
            s = n(9433),
            o = "__core-js_shared__",
            a = (t.exports = r[o] || s(o, {}));
          (a.versions || (a.versions = [])).push({
            version: "3.37.1",
            mode: i ? "pure" : "global",
            copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
            source: "https://github.com/zloirock/core-js",
          });
        },
        5745: (t, e, n) => {
          "use strict";
          var i = n(7629);
          t.exports = function (t, e) {
            return i[t] || (i[t] = e || {});
          };
        },
        8183: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(1291),
            s = n(655),
            o = n(7750),
            a = i("".charAt),
            l = i("".charCodeAt),
            c = i("".slice),
            u = function (t) {
              return function (e, n) {
                var i,
                  u,
                  h = s(o(e)),
                  d = r(n),
                  p = h.length;
                return d < 0 || d >= p
                  ? t
                    ? ""
                    : void 0
                  : (i = l(h, d)) < 55296 ||
                    i > 56319 ||
                    d + 1 === p ||
                    (u = l(h, d + 1)) < 56320 ||
                    u > 57343
                  ? t
                    ? a(h, d)
                    : i
                  : t
                  ? c(h, d, d + 2)
                  : u - 56320 + ((i - 55296) << 10) + 65536;
              };
            };
          t.exports = {
            codeAt: u(!1),
            charAt: u(!0),
          };
        },
        3802: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = n(7750),
            s = n(655),
            o = n(7452),
            a = i("".replace),
            l = RegExp("^[" + o + "]+"),
            c = RegExp("(^|[^" + o + "])[" + o + "]+$"),
            u = function (t) {
              return function (e) {
                var n = s(r(e));
                return (
                  1 & t && (n = a(n, l, "")), 2 & t && (n = a(n, c, "$1")), n
                );
              };
            };
          t.exports = {
            start: u(1),
            end: u(2),
            trim: u(3),
          };
        },
        4495: (t, e, n) => {
          "use strict";
          var i = n(7388),
            r = n(9039),
            s = n(4475).String;
          t.exports =
            !!Object.getOwnPropertySymbols &&
            !r(function () {
              var t = Symbol("symbol detection");
              return (
                !s(t) ||
                !(Object(t) instanceof Symbol) ||
                (!Symbol.sham && i && i < 41)
              );
            });
        },
        5610: (t, e, n) => {
          "use strict";
          var i = n(1291),
            r = Math.max,
            s = Math.min;
          t.exports = function (t, e) {
            var n = i(t);
            return n < 0 ? r(n + e, 0) : s(n, e);
          };
        },
        5397: (t, e, n) => {
          "use strict";
          var i = n(7055),
            r = n(7750);
          t.exports = function (t) {
            return i(r(t));
          };
        },
        1291: (t, e, n) => {
          "use strict";
          var i = n(741);
          t.exports = function (t) {
            var e = +t;
            return e != e || 0 === e ? 0 : i(e);
          };
        },
        8014: (t, e, n) => {
          "use strict";
          var i = n(1291),
            r = Math.min;
          t.exports = function (t) {
            var e = i(t);
            return e > 0 ? r(e, 9007199254740991) : 0;
          };
        },
        8981: (t, e, n) => {
          "use strict";
          var i = n(7750),
            r = Object;
          t.exports = function (t) {
            return r(i(t));
          };
        },
        2777: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(34),
            s = n(757),
            o = n(5966),
            a = n(4270),
            l = n(8227),
            c = TypeError,
            u = l("toPrimitive");
          t.exports = function (t, e) {
            if (!r(t) || s(t)) return t;
            var n,
              l = o(t, u);
            if (l) {
              if (
                (void 0 === e && (e = "default"),
                (n = i(l, t, e)),
                !r(n) || s(n))
              )
                return n;
              throw new c("Can't convert object to primitive value");
            }
            return void 0 === e && (e = "number"), a(t, e);
          };
        },
        6969: (t, e, n) => {
          "use strict";
          var i = n(2777),
            r = n(757);
          t.exports = function (t) {
            var e = i(t, "string");
            return r(e) ? e : e + "";
          };
        },
        2140: (t, e, n) => {
          "use strict";
          var i = {};
          (i[n(8227)("toStringTag")] = "z"),
            (t.exports = "[object z]" === String(i));
        },
        655: (t, e, n) => {
          "use strict";
          var i = n(6955),
            r = String;
          t.exports = function (t) {
            if ("Symbol" === i(t))
              throw new TypeError("Cannot convert a Symbol value to a string");
            return r(t);
          };
        },
        6823: (t) => {
          "use strict";
          var e = String;
          t.exports = function (t) {
            try {
              return e(t);
            } catch (t) {
              return "Object";
            }
          };
        },
        3392: (t, e, n) => {
          "use strict";
          var i = n(9504),
            r = 0,
            s = Math.random(),
            o = i((1).toString);
          t.exports = function (t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + s, 36);
          };
        },
        7040: (t, e, n) => {
          "use strict";
          var i = n(4495);
          t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator;
        },
        8686: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(9039);
          t.exports =
            i &&
            r(function () {
              return (
                42 !==
                Object.defineProperty(function () {}, "prototype", {
                  value: 42,
                  writable: !1,
                }).prototype
              );
            });
        },
        8622: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(4901),
            s = i.WeakMap;
          t.exports = r(s) && /native code/.test(String(s));
        },
        8227: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(5745),
            s = n(9297),
            o = n(3392),
            a = n(4495),
            l = n(7040),
            c = i.Symbol,
            u = r("wks"),
            h = l ? c.for || c : (c && c.withoutSetter) || o;
          t.exports = function (t) {
            return (
              s(u, t) || (u[t] = a && s(c, t) ? c[t] : h("Symbol." + t)), u[t]
            );
          };
        },
        7452: (t) => {
          "use strict";
          t.exports = "\t\n\v\f\r                　\u2028\u2029\ufeff";
        },
        2008: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(9213).filter;
          i(
            {
              target: "Array",
              proto: !0,
              forced: !n(597)("filter"),
            },
            {
              filter: function (t) {
                return r(this, t, arguments.length > 1 ? arguments[1] : void 0);
              },
            }
          );
        },
        1629: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(235);
          i(
            {
              target: "Array",
              proto: !0,
              forced: [].forEach !== r,
            },
            {
              forEach: r,
            }
          );
        },
        3792: (t, e, n) => {
          "use strict";
          var i = n(5397),
            r = n(6469),
            s = n(6269),
            o = n(1181),
            a = n(4913).f,
            l = n(1088),
            c = n(2529),
            u = n(6395),
            h = n(3724),
            d = "Array Iterator",
            p = o.set,
            f = o.getterFor(d);
          t.exports = l(
            Array,
            "Array",
            function (t, e) {
              p(this, {
                type: d,
                target: i(t),
                index: 0,
                kind: e,
              });
            },
            function () {
              var t = f(this),
                e = t.target,
                n = t.index++;
              if (!e || n >= e.length)
                return (t.target = void 0), c(void 0, !0);
              switch (t.kind) {
                case "keys":
                  return c(n, !1);
                case "values":
                  return c(e[n], !1);
              }
              return c([n, e[n]], !1);
            },
            "values"
          );
          var m = (s.Arguments = s.Array);
          if (
            (r("keys"),
            r("values"),
            r("entries"),
            !u && h && "values" !== m.name)
          )
            try {
              a(m, "name", {
                value: "values",
              });
            } catch (t) {}
        },
        2712: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(926).left,
            s = n(4598),
            o = n(7388);
          i(
            {
              target: "Array",
              proto: !0,
              forced: (!n(9088) && o > 79 && o < 83) || !s("reduce"),
            },
            {
              reduce: function (t) {
                var e = arguments.length;
                return r(this, t, e, e > 1 ? arguments[1] : void 0);
              },
            }
          );
        },
        2010: (t, e, n) => {
          "use strict";
          var i = n(3724),
            r = n(350).EXISTS,
            s = n(9504),
            o = n(2106),
            a = Function.prototype,
            l = s(a.toString),
            c =
              /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,
            u = s(c.exec);
          i &&
            !r &&
            o(a, "name", {
              configurable: !0,
              get: function () {
                try {
                  return u(c, l(this))[1];
                } catch (t) {
                  return "";
                }
              },
            });
        },
        9085: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(4213);
          i(
            {
              target: "Object",
              stat: !0,
              arity: 2,
              forced: Object.assign !== r,
            },
            {
              assign: r,
            }
          );
        },
        6099: (t, e, n) => {
          "use strict";
          var i = n(2140),
            r = n(6840),
            s = n(3179);
          i ||
            r(Object.prototype, "toString", s, {
              unsafe: !0,
            });
        },
        8940: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(2703);
          i(
            {
              global: !0,
              forced: parseInt !== r,
            },
            {
              parseInt: r,
            }
          );
        },
        7495: (t, e, n) => {
          "use strict";
          var i = n(6518),
            r = n(7323);
          i(
            {
              target: "RegExp",
              proto: !0,
              forced: /./.exec !== r,
            },
            {
              exec: r,
            }
          );
        },
        7764: (t, e, n) => {
          "use strict";
          var i = n(8183).charAt,
            r = n(655),
            s = n(1181),
            o = n(1088),
            a = n(2529),
            l = "String Iterator",
            c = s.set,
            u = s.getterFor(l);
          o(
            String,
            "String",
            function (t) {
              c(this, {
                type: l,
                string: r(t),
                index: 0,
              });
            },
            function () {
              var t,
                e = u(this),
                n = e.string,
                r = e.index;
              return r >= n.length
                ? a(void 0, !0)
                : ((t = i(n, r)), (e.index += t.length), a(t, !1));
            }
          );
        },
        1761: (t, e, n) => {
          "use strict";
          var i = n(9565),
            r = n(9228),
            s = n(8551),
            o = n(4117),
            a = n(8014),
            l = n(655),
            c = n(7750),
            u = n(5966),
            h = n(7829),
            d = n(6682);
          r("match", function (t, e, n) {
            return [
              function (e) {
                var n = c(this),
                  r = o(e) ? void 0 : u(e, t);
                return r ? i(r, e, n) : new RegExp(e)[t](l(n));
              },
              function (t) {
                var i = s(this),
                  r = l(t),
                  o = n(e, i, r);
                if (o.done) return o.value;
                if (!i.global) return d(i, r);
                var c = i.unicode;
                i.lastIndex = 0;
                for (var u, p = [], f = 0; null !== (u = d(i, r)); ) {
                  var m = l(u[0]);
                  (p[f] = m),
                    "" === m && (i.lastIndex = h(r, a(i.lastIndex), c)),
                    f++;
                }
                return 0 === f ? null : p;
              },
            ];
          });
        },
        5440: (t, e, n) => {
          "use strict";
          var i = n(8745),
            r = n(9565),
            s = n(9504),
            o = n(9228),
            a = n(9039),
            l = n(8551),
            c = n(4901),
            u = n(4117),
            h = n(1291),
            d = n(8014),
            p = n(655),
            f = n(7750),
            m = n(7829),
            g = n(5966),
            v = n(2478),
            y = n(6682),
            _ = n(8227)("replace"),
            x = Math.max,
            b = Math.min,
            w = s([].concat),
            E = s([].push),
            S = s("".indexOf),
            M = s("".slice),
            T = "$0" === "a".replace(/./, "$0"),
            A = !!/./[_] && "" === /./[_]("a", "$0");
          o(
            "replace",
            function (t, e, n) {
              var s = A ? "$" : "$0";
              return [
                function (t, n) {
                  var i = f(this),
                    s = u(t) ? void 0 : g(t, _);
                  return s ? r(s, t, i, n) : r(e, p(i), t, n);
                },
                function (t, r) {
                  var o = l(this),
                    a = p(t);
                  if (
                    "string" == typeof r &&
                    -1 === S(r, s) &&
                    -1 === S(r, "$<")
                  ) {
                    var u = n(e, o, a, r);
                    if (u.done) return u.value;
                  }
                  var f = c(r);
                  f || (r = p(r));
                  var g,
                    _ = o.global;
                  _ && ((g = o.unicode), (o.lastIndex = 0));
                  for (
                    var T, A = [];
                    null !== (T = y(o, a)) && (E(A, T), _);

                  ) {
                    "" === p(T[0]) && (o.lastIndex = m(a, d(o.lastIndex), g));
                  }
                  for (var R, C = "", L = 0, P = 0; P < A.length; P++) {
                    for (
                      var O,
                        I = p((T = A[P])[0]),
                        N = x(b(h(T.index), a.length), 0),
                        D = [],
                        U = 1;
                      U < T.length;
                      U++
                    )
                      E(D, void 0 === (R = T[U]) ? R : String(R));
                    var F = T.groups;
                    if (f) {
                      var k = w([I], D, N, a);
                      void 0 !== F && E(k, F), (O = p(i(r, void 0, k)));
                    } else O = v(I, a, N, D, F, r);
                    N >= L && ((C += M(a, L, N) + O), (L = N + I.length));
                  }
                  return C + M(a, L);
                },
              ];
            },
            !!a(function () {
              var t = /./;
              return (
                (t.exec = function () {
                  var t = [];
                  return (
                    (t.groups = {
                      a: "7",
                    }),
                    t
                  );
                }),
                "7" !== "".replace(t, "$<a>")
              );
            }) ||
              !T ||
              A
          );
        },
        5746: (t, e, n) => {
          "use strict";
          var i,
            r = n(2744),
            s = n(4475),
            o = n(9504),
            a = n(6279),
            l = n(3451),
            c = n(6468),
            u = n(4006),
            h = n(34),
            d = n(1181).enforce,
            p = n(9039),
            f = n(8622),
            m = Object,
            g = Array.isArray,
            v = m.isExtensible,
            y = m.isFrozen,
            _ = m.isSealed,
            x = m.freeze,
            b = m.seal,
            w = !s.ActiveXObject && "ActiveXObject" in s,
            E = function (t) {
              return function () {
                return t(this, arguments.length ? arguments[0] : void 0);
              };
            },
            S = c("WeakMap", E, u),
            M = S.prototype,
            T = o(M.set);
          if (f)
            if (w) {
              (i = u.getConstructor(E, "WeakMap", !0)), l.enable();
              var A = o(M.delete),
                R = o(M.has),
                C = o(M.get);
              a(M, {
                delete: function (t) {
                  if (h(t) && !v(t)) {
                    var e = d(this);
                    return (
                      e.frozen || (e.frozen = new i()),
                      A(this, t) || e.frozen.delete(t)
                    );
                  }
                  return A(this, t);
                },
                has: function (t) {
                  if (h(t) && !v(t)) {
                    var e = d(this);
                    return (
                      e.frozen || (e.frozen = new i()),
                      R(this, t) || e.frozen.has(t)
                    );
                  }
                  return R(this, t);
                },
                get: function (t) {
                  if (h(t) && !v(t)) {
                    var e = d(this);
                    return (
                      e.frozen || (e.frozen = new i()),
                      R(this, t) ? C(this, t) : e.frozen.get(t)
                    );
                  }
                  return C(this, t);
                },
                set: function (t, e) {
                  if (h(t) && !v(t)) {
                    var n = d(this);
                    n.frozen || (n.frozen = new i()),
                      R(this, t) ? T(this, t, e) : n.frozen.set(t, e);
                  } else T(this, t, e);
                  return this;
                },
              });
            } else
              r &&
                p(function () {
                  var t = x([]);
                  return T(new S(), t, 1), !y(t);
                }) &&
                a(M, {
                  set: function (t, e) {
                    var n;
                    return (
                      g(t) && (y(t) ? (n = x) : _(t) && (n = b)),
                      T(this, t, e),
                      n && n(t),
                      this
                    );
                  },
                });
        },
        3772: (t, e, n) => {
          "use strict";
          n(5746);
        },
        3500: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(7400),
            s = n(9296),
            o = n(235),
            a = n(6699),
            l = function (t) {
              if (t && t.forEach !== o)
                try {
                  a(t, "forEach", o);
                } catch (e) {
                  t.forEach = o;
                }
            };
          for (var c in r) r[c] && l(i[c] && i[c].prototype);
          l(s);
        },
        2953: (t, e, n) => {
          "use strict";
          var i = n(4475),
            r = n(7400),
            s = n(9296),
            o = n(3792),
            a = n(6699),
            l = n(687),
            c = n(8227)("iterator"),
            u = o.values,
            h = function (t, e) {
              if (t) {
                if (t[c] !== u)
                  try {
                    a(t, c, u);
                  } catch (e) {
                    t[c] = u;
                  }
                if ((l(t, e, !0), r[e]))
                  for (var n in o)
                    if (t[n] !== o[n])
                      try {
                        a(t, n, o[n]);
                      } catch (e) {
                        t[n] = o[n];
                      }
              }
            };
          for (var d in r) h(i[d] && i[d].prototype, d);
          h(s, "DOMTokenList");
        },
      },
      e = {};
    function n(i) {
      var r = e[i];
      if (void 0 !== r) return r.exports;
      var s = (e[i] = {
        exports: {},
      });
      return t[i].call(s.exports, s, s.exports, n), s.exports;
    }
    (n.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return (
        n.d(e, {
          a: e,
        }),
        e
      );
    }),
      (n.d = (t, e) => {
        for (var i in e)
          n.o(e, i) &&
            !n.o(t, i) &&
            Object.defineProperty(t, i, {
              enumerable: !0,
              get: e[i],
            });
      }),
      (n.g = (function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (t) {
          if ("object" == typeof window) return window;
        }
      })()),
      (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
      (() => {
        "use strict";
        var t = n(6714),
          e = n.n(t),
          i = n(3824),
          r = n.n(i),
          s = n(2212),
          o = n.n(s);
        function a(t) {
          if (void 0 === t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return t;
        }
        function l(t, e) {
          (t.prototype = Object.create(e.prototype)),
            (t.prototype.constructor = t),
            (t.__proto__ = e);
        }
        /*!
         * GSAP 3.12.5
         * https://gsap.com
         *
         * @license Copyright 2008-2024, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v,
          y,
          _,
          x = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
              lineHeight: "",
            },
          },
          b = {
            duration: 0.5,
            overwrite: !1,
            delay: 0,
          },
          w = 1e8,
          E = 1e-8,
          S = 2 * Math.PI,
          M = S / 4,
          T = 0,
          A = Math.sqrt,
          R = Math.cos,
          C = Math.sin,
          L = function (t) {
            return "string" == typeof t;
          },
          P = function (t) {
            return "function" == typeof t;
          },
          O = function (t) {
            return "number" == typeof t;
          },
          I = function (t) {
            return void 0 === t;
          },
          N = function (t) {
            return "object" == typeof t;
          },
          D = function (t) {
            return !1 !== t;
          },
          U = function () {
            return "undefined" != typeof window;
          },
          F = function (t) {
            return P(t) || L(t);
          },
          k =
            ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
            function () {},
          B = Array.isArray,
          z = /(?:-?\.?\d|\.)+/gi,
          H = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
          V = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
          G = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
          W = /[+-]=-?[.\d]+/,
          j = /[^,'"\[\]\s]+/gi,
          q = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
          X = {},
          Y = {},
          K = function (t) {
            return (Y = St(t, X)) && Tn;
          },
          $ = function (t, e) {
            return console.warn(
              "Invalid property",
              t,
              "set to",
              e,
              "Missing plugin? gsap.registerPlugin()"
            );
          },
          Z = function (t, e) {
            return !e && console.warn(t);
          },
          J = function (t, e) {
            return (t && (X[t] = e) && Y && (Y[t] = e)) || X;
          },
          Q = function () {
            return 0;
          },
          tt = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1,
          },
          et = {
            suppressEvents: !0,
            kill: !1,
          },
          nt = {
            suppressEvents: !0,
          },
          it = {},
          rt = [],
          st = {},
          ot = {},
          at = {},
          lt = 30,
          ct = [],
          ut = "",
          ht = function (t) {
            var e,
              n,
              i = t[0];
            if ((N(i) || P(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
              for (n = ct.length; n-- && !ct[n].targetTest(i); );
              e = ct[n];
            }
            for (n = t.length; n--; )
              (t[n] && (t[n]._gsap || (t[n]._gsap = new Be(t[n], e)))) ||
                t.splice(n, 1);
            return t;
          },
          dt = function (t) {
            return t._gsap || ht(ne(t))[0]._gsap;
          },
          pt = function (t, e, n) {
            return (n = t[e]) && P(n)
              ? t[e]()
              : (I(n) && t.getAttribute && t.getAttribute(e)) || n;
          },
          ft = function (t, e) {
            return (t = t.split(",")).forEach(e) || t;
          },
          mt = function (t) {
            return Math.round(1e5 * t) / 1e5 || 0;
          },
          gt = function (t) {
            return Math.round(1e7 * t) / 1e7 || 0;
          },
          vt = function (t, e) {
            var n = e.charAt(0),
              i = parseFloat(e.substr(2));
            return (
              (t = parseFloat(t)),
              "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
            );
          },
          yt = function (t, e) {
            for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
            return i < n;
          },
          _t = function () {
            var t,
              e,
              n = rt.length,
              i = rt.slice(0);
            for (st = {}, rt.length = 0, t = 0; t < n; t++)
              (e = i[t]) &&
                e._lazy &&
                (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
          },
          xt = function (t, e, n, i) {
            rt.length && !u && _t(),
              t.render(e, n, i || (u && e < 0 && (t._initted || t._startAt))),
              rt.length && !u && _t();
          },
          bt = function (t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(j).length < 2
              ? e
              : L(t)
              ? t.trim()
              : t;
          },
          wt = function (t) {
            return t;
          },
          Et = function (t, e) {
            for (var n in e) n in t || (t[n] = e[n]);
            return t;
          },
          St = function (t, e) {
            for (var n in e) t[n] = e[n];
            return t;
          },
          Mt = function t(e, n) {
            for (var i in n)
              "__proto__" !== i &&
                "constructor" !== i &&
                "prototype" !== i &&
                (e[i] = N(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
            return e;
          },
          Tt = function (t, e) {
            var n,
              i = {};
            for (n in t) n in e || (i[n] = t[n]);
            return i;
          },
          At = function (t) {
            var e,
              n = t.parent || d,
              i = t.keyframes
                ? ((e = B(t.keyframes)),
                  function (t, n) {
                    for (var i in n)
                      i in t ||
                        ("duration" === i && e) ||
                        "ease" === i ||
                        (t[i] = n[i]);
                  })
                : Et;
            if (D(t.inherit))
              for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
            return t;
          },
          Rt = function (t, e, n, i, r) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var s,
              o = t[i];
            if (r) for (s = e[r]; o && o[r] > s; ) o = o._prev;
            return (
              o
                ? ((e._next = o._next), (o._next = e))
                : ((e._next = t[n]), (t[n] = e)),
              e._next ? (e._next._prev = e) : (t[i] = e),
              (e._prev = o),
              (e.parent = e._dp = t),
              e
            );
          },
          Ct = function (t, e, n, i) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var r = e._prev,
              s = e._next;
            r ? (r._next = s) : t[n] === e && (t[n] = s),
              s ? (s._prev = r) : t[i] === e && (t[i] = r),
              (e._next = e._prev = e.parent = null);
          },
          Lt = function (t, e) {
            t.parent &&
              (!e || t.parent.autoRemoveChildren) &&
              t.parent.remove &&
              t.parent.remove(t),
              (t._act = 0);
          },
          Pt = function (t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
              for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
            return t;
          },
          Ot = function (t, e, n, i) {
            return (
              t._startAt &&
              (u
                ? t._startAt.revert(et)
                : (t.vars.immediateRender && !t.vars.autoRevert) ||
                  t._startAt.render(e, !0, i))
            );
          },
          It = function t(e) {
            return !e || (e._ts && t(e.parent));
          },
          Nt = function (t) {
            return t._repeat
              ? Dt(t._tTime, (t = t.duration() + t._rDelay)) * t
              : 0;
          },
          Dt = function (t, e) {
            var n = Math.floor((t /= e));
            return t && n === t ? n - 1 : n;
          },
          Ut = function (t, e) {
            return (
              (t - e._start) * e._ts +
              (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            );
          },
          Ft = function (t) {
            return (t._end = gt(
              t._start + (t._tDur / Math.abs(t._ts || t._rts || E) || 0)
            ));
          },
          kt = function (t, e) {
            var n = t._dp;
            return (
              n &&
                n.smoothChildTiming &&
                t._ts &&
                ((t._start = gt(
                  n._time -
                    (t._ts > 0
                      ? e / t._ts
                      : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
                )),
                Ft(t),
                n._dirty || Pt(n, t)),
              t
            );
          },
          Bt = function (t, e) {
            var n;
            if (
              ((e._time ||
                (!e._dur && e._initted) ||
                (e._start < t._time && (e._dur || !e.add))) &&
                ((n = Ut(t.rawTime(), e)),
                (!e._dur || Zt(0, e.totalDuration(), n) - e._tTime > E) &&
                  e.render(n, !0)),
              Pt(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
            ) {
              if (t._dur < t.duration())
                for (n = t; n._dp; )
                  n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
              t._zTime = -1e-8;
            }
          },
          zt = function (t, e, n, i) {
            return (
              e.parent && Lt(e),
              (e._start = gt(
                (O(n) ? n : n || t !== d ? Yt(t, n, e) : t._time) + e._delay
              )),
              (e._end = gt(
                e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
              )),
              Rt(t, e, "_first", "_last", t._sort ? "_start" : 0),
              Wt(e) || (t._recent = e),
              i || Bt(t, e),
              t._ts < 0 && kt(t, t._tTime),
              t
            );
          },
          Ht = function (t, e) {
            return (
              (X.ScrollTrigger || $("scrollTrigger", e)) &&
              X.ScrollTrigger.create(e, t)
            );
          },
          Vt = function (t, e, n, i, r) {
            return (
              Xe(t, e, r),
              t._initted
                ? !n &&
                  t._pt &&
                  !u &&
                  ((t._dur && !1 !== t.vars.lazy) ||
                    (!t._dur && t.vars.lazy)) &&
                  v !== Te.frame
                  ? (rt.push(t), (t._lazy = [r, i]), 1)
                  : void 0
                : 1
            );
          },
          Gt = function t(e) {
            var n = e.parent;
            return (
              n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            );
          },
          Wt = function (t) {
            var e = t.data;
            return "isFromStart" === e || "isStart" === e;
          },
          jt = function (t, e, n, i) {
            var r = t._repeat,
              s = gt(e) || 0,
              o = t._tTime / t._tDur;
            return (
              o && !i && (t._time *= s / t._dur),
              (t._dur = s),
              (t._tDur = r
                ? r < 0
                  ? 1e10
                  : gt(s * (r + 1) + t._rDelay * r)
                : s),
              o > 0 && !i && kt(t, (t._tTime = t._tDur * o)),
              t.parent && Ft(t),
              n || Pt(t.parent, t),
              t
            );
          },
          qt = function (t) {
            return t instanceof He ? Pt(t) : jt(t, t._dur);
          },
          Xt = {
            _start: 0,
            endTime: Q,
            totalDuration: Q,
          },
          Yt = function t(e, n, i) {
            var r,
              s,
              o,
              a = e.labels,
              l = e._recent || Xt,
              c = e.duration() >= w ? l.endTime(!1) : e._dur;
            return L(n) && (isNaN(n) || n in a)
              ? ((s = n.charAt(0)),
                (o = "%" === n.substr(-1)),
                (r = n.indexOf("=")),
                "<" === s || ">" === s
                  ? (r >= 0 && (n = n.replace(/=/, "")),
                    ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                      (parseFloat(n.substr(1)) || 0) *
                        (o ? (r < 0 ? l : i).totalDuration() / 100 : 1))
                  : r < 0
                  ? (n in a || (a[n] = c), a[n])
                  : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                    o &&
                      i &&
                      (s = (s / 100) * (B(i) ? i[0] : i).totalDuration()),
                    r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
              : null == n
              ? c
              : +n;
          },
          Kt = function (t, e, n) {
            var i,
              r,
              s = O(e[1]),
              o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
              a = e[o];
            if ((s && (a.duration = e[1]), (a.parent = n), t)) {
              for (i = a, r = n; r && !("immediateRender" in i); )
                (i = r.vars.defaults || {}),
                  (r = D(r.vars.inherit) && r.parent);
              (a.immediateRender = D(i.immediateRender)),
                t < 2 ? (a.runBackwards = 1) : (a.startAt = e[o - 1]);
            }
            return new Je(e[0], a, e[o + 1]);
          },
          $t = function (t, e) {
            return t || 0 === t ? e(t) : e;
          },
          Zt = function (t, e, n) {
            return n < t ? t : n > e ? e : n;
          },
          Jt = function (t, e) {
            return L(t) && (e = q.exec(t)) ? e[1] : "";
          },
          Qt = [].slice,
          te = function (t, e) {
            return (
              t &&
              N(t) &&
              "length" in t &&
              ((!e && !t.length) || (t.length - 1 in t && N(t[0]))) &&
              !t.nodeType &&
              t !== p
            );
          },
          ee = function (t, e, n) {
            return (
              void 0 === n && (n = []),
              t.forEach(function (t) {
                var i;
                return (L(t) && !e) || te(t, 1)
                  ? (i = n).push.apply(i, ne(t))
                  : n.push(t);
              }) || n
            );
          },
          ne = function (t, e, n) {
            return h && !e && h.selector
              ? h.selector(t)
              : !L(t) || n || (!f && Ae())
              ? B(t)
                ? ee(t, n)
                : te(t)
                ? Qt.call(t, 0)
                : t
                ? [t]
                : []
              : Qt.call((e || m).querySelectorAll(t), 0);
          },
          ie = function (t) {
            return (
              (t = ne(t)[0] || Z("Invalid scope") || {}),
              function (e) {
                var n = t.current || t.nativeElement || t;
                return ne(
                  e,
                  n.querySelectorAll
                    ? n
                    : n === t
                    ? Z("Invalid scope") || m.createElement("div")
                    : t
                );
              }
            );
          },
          re = function (t) {
            return t.sort(function () {
              return 0.5 - Math.random();
            });
          },
          se = function (t) {
            if (P(t)) return t;
            var e = N(t)
                ? t
                : {
                    each: t,
                  },
              n = Ne(e.ease),
              i = e.from || 0,
              r = parseFloat(e.base) || 0,
              s = {},
              o = i > 0 && i < 1,
              a = isNaN(i) || o,
              l = e.axis,
              c = i,
              u = i;
            return (
              L(i)
                ? (c = u =
                    {
                      center: 0.5,
                      edges: 0.5,
                      end: 1,
                    }[i] || 0)
                : !o && a && ((c = i[0]), (u = i[1])),
              function (t, o, h) {
                var d,
                  p,
                  f,
                  m,
                  g,
                  v,
                  y,
                  _,
                  x,
                  b = (h || e).length,
                  E = s[b];
                if (!E) {
                  if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, w])[1])) {
                    for (
                      y = -w;
                      y < (y = h[x++].getBoundingClientRect().left) && x < b;

                    );
                    x < b && x--;
                  }
                  for (
                    E = s[b] = [],
                      d = a ? Math.min(x, b) * c - 0.5 : i % x,
                      p = x === w ? 0 : a ? (b * u) / x - 0.5 : (i / x) | 0,
                      y = 0,
                      _ = w,
                      v = 0;
                    v < b;
                    v++
                  )
                    (f = (v % x) - d),
                      (m = p - ((v / x) | 0)),
                      (E[v] = g =
                        l ? Math.abs("y" === l ? m : f) : A(f * f + m * m)),
                      g > y && (y = g),
                      g < _ && (_ = g);
                  "random" === i && re(E),
                    (E.max = y - _),
                    (E.min = _),
                    (E.v = b =
                      (parseFloat(e.amount) ||
                        parseFloat(e.each) *
                          (x > b
                            ? b - 1
                            : l
                            ? "y" === l
                              ? b / x
                              : x
                            : Math.max(x, b / x)) ||
                        0) * ("edges" === i ? -1 : 1)),
                    (E.b = b < 0 ? r - b : r),
                    (E.u = Jt(e.amount || e.each) || 0),
                    (n = n && b < 0 ? Oe(n) : n);
                }
                return (
                  (b = (E[t] - E.min) / E.max || 0),
                  gt(E.b + (n ? n(b) : b) * E.v) + E.u
                );
              }
            );
          },
          oe = function (t) {
            var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
            return function (n) {
              var i = gt(Math.round(parseFloat(n) / t) * t * e);
              return (i - (i % 1)) / e + (O(n) ? 0 : Jt(n));
            };
          },
          ae = function (t, e) {
            var n,
              i,
              r = B(t);
            return (
              !r &&
                N(t) &&
                ((n = r = t.radius || w),
                t.values
                  ? ((t = ne(t.values)), (i = !O(t[0])) && (n *= n))
                  : (t = oe(t.increment))),
              $t(
                e,
                r
                  ? P(t)
                    ? function (e) {
                        return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                      }
                    : function (e) {
                        for (
                          var r,
                            s,
                            o = parseFloat(i ? e.x : e),
                            a = parseFloat(i ? e.y : 0),
                            l = w,
                            c = 0,
                            u = t.length;
                          u--;

                        )
                          (r = i
                            ? (r = t[u].x - o) * r + (s = t[u].y - a) * s
                            : Math.abs(t[u] - o)) < l && ((l = r), (c = u));
                        return (
                          (c = !n || l <= n ? t[c] : e),
                          i || c === e || O(e) ? c : c + Jt(e)
                        );
                      }
                  : oe(t)
              )
            );
          },
          le = function (t, e, n, i) {
            return $t(B(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
              return B(t)
                ? t[~~(Math.random() * t.length)]
                : (n = n || 1e-5) &&
                    (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                    Math.floor(
                      Math.round(
                        (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                      ) *
                        n *
                        i
                    ) / i;
            });
          },
          ce = function (t, e, n) {
            return $t(n, function (n) {
              return t[~~e(n)];
            });
          },
          ue = function (t) {
            for (
              var e, n, i, r, s = 0, o = "";
              ~(e = t.indexOf("random(", s));

            )
              (i = t.indexOf(")", e)),
                (r = "[" === t.charAt(e + 7)),
                (n = t.substr(e + 7, i - e - 7).match(r ? j : z)),
                (o +=
                  t.substr(s, e - s) +
                  le(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
                (s = i + 1);
            return o + t.substr(s, t.length - s);
          },
          he = function (t, e, n, i, r) {
            var s = e - t,
              o = i - n;
            return $t(r, function (e) {
              return n + (((e - t) / s) * o || 0);
            });
          },
          de = function (t, e, n) {
            var i,
              r,
              s,
              o = t.labels,
              a = w;
            for (i in o)
              (r = o[i] - e) < 0 == !!n &&
                r &&
                a > (r = Math.abs(r)) &&
                ((s = i), (a = r));
            return s;
          },
          pe = function (t, e, n) {
            var i,
              r,
              s,
              o = t.vars,
              a = o[e],
              l = h,
              c = t._ctx;
            if (a)
              return (
                (i = o[e + "Params"]),
                (r = o.callbackScope || t),
                n && rt.length && _t(),
                c && (h = c),
                (s = i ? a.apply(r, i) : a.call(r)),
                (h = l),
                s
              );
          },
          fe = function (t) {
            return (
              Lt(t),
              t.scrollTrigger && t.scrollTrigger.kill(!!u),
              t.progress() < 1 && pe(t, "onInterrupt"),
              t
            );
          },
          me = [],
          ge = function (t) {
            if (t)
              if (((t = (!t.name && t.default) || t), U() || t.headless)) {
                var e = t.name,
                  n = P(t),
                  i =
                    e && !n && t.init
                      ? function () {
                          this._props = [];
                        }
                      : t,
                  r = {
                    init: Q,
                    render: ln,
                    add: je,
                    kill: un,
                    modifier: cn,
                    rawVars: 0,
                  },
                  s = {
                    targetTest: 0,
                    get: 0,
                    getSetter: rn,
                    aliases: {},
                    register: 0,
                  };
                if ((Ae(), t !== i)) {
                  if (ot[e]) return;
                  Et(i, Et(Tt(t, r), s)),
                    St(i.prototype, St(r, Tt(t, s))),
                    (ot[(i.prop = e)] = i),
                    t.targetTest && (ct.push(i), (it[e] = 1)),
                    (e =
                      ("css" === e
                        ? "CSS"
                        : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
                }
                J(e, i), t.register && t.register(Tn, i, pn);
              } else me.push(t);
          },
          ve = 255,
          ye = {
            aqua: [0, ve, ve],
            lime: [0, ve, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, ve],
            navy: [0, 0, 128],
            white: [ve, ve, ve],
            olive: [128, 128, 0],
            yellow: [ve, ve, 0],
            orange: [ve, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [ve, 0, 0],
            pink: [ve, 192, 203],
            cyan: [0, ve, ve],
            transparent: [ve, ve, ve, 0],
          },
          _e = function (t, e, n) {
            return (
              ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
                ? e + (n - e) * t * 6
                : t < 0.5
                ? n
                : 3 * t < 2
                ? e + (n - e) * (2 / 3 - t) * 6
                : e) *
                ve +
                0.5) |
              0
            );
          },
          xe = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p = t ? (O(t) ? [t >> 16, (t >> 8) & ve, t & ve] : 0) : ye.black;
            if (!p) {
              if (
                ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ye[t])
              )
                p = ye[t];
              else if ("#" === t.charAt(0)) {
                if (
                  (t.length < 6 &&
                    ((i = t.charAt(1)),
                    (r = t.charAt(2)),
                    (s = t.charAt(3)),
                    (t =
                      "#" +
                      i +
                      i +
                      r +
                      r +
                      s +
                      s +
                      (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
                  9 === t.length)
                )
                  return [
                    (p = parseInt(t.substr(1, 6), 16)) >> 16,
                    (p >> 8) & ve,
                    p & ve,
                    parseInt(t.substr(7), 16) / 255,
                  ];
                p = [
                  (t = parseInt(t.substr(1), 16)) >> 16,
                  (t >> 8) & ve,
                  t & ve,
                ];
              } else if ("hsl" === t.substr(0, 3))
                if (((p = d = t.match(z)), e)) {
                  if (~t.indexOf("="))
                    return (p = t.match(H)), n && p.length < 4 && (p[3] = 1), p;
                } else
                  (o = (+p[0] % 360) / 360),
                    (a = +p[1] / 100),
                    (i =
                      2 * (l = +p[2] / 100) -
                      (r = l <= 0.5 ? l * (a + 1) : l + a - l * a)),
                    p.length > 3 && (p[3] *= 1),
                    (p[0] = _e(o + 1 / 3, i, r)),
                    (p[1] = _e(o, i, r)),
                    (p[2] = _e(o - 1 / 3, i, r));
              else p = t.match(z) || ye.transparent;
              p = p.map(Number);
            }
            return (
              e &&
                !d &&
                ((i = p[0] / ve),
                (r = p[1] / ve),
                (s = p[2] / ve),
                (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
                c === u
                  ? (o = a = 0)
                  : ((h = c - u),
                    (a = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
                    (o =
                      c === i
                        ? (r - s) / h + (r < s ? 6 : 0)
                        : c === r
                        ? (s - i) / h + 2
                        : (i - r) / h + 4),
                    (o *= 60)),
                (p[0] = ~~(o + 0.5)),
                (p[1] = ~~(100 * a + 0.5)),
                (p[2] = ~~(100 * l + 0.5))),
              n && p.length < 4 && (p[3] = 1),
              p
            );
          },
          be = function (t) {
            var e = [],
              n = [],
              i = -1;
            return (
              t.split(Ee).forEach(function (t) {
                var r = t.match(V) || [];
                e.push.apply(e, r), n.push((i += r.length + 1));
              }),
              (e.c = n),
              e
            );
          },
          we = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a = "",
              l = (t + a).match(Ee),
              c = e ? "hsla(" : "rgba(",
              u = 0;
            if (!l) return t;
            if (
              ((l = l.map(function (t) {
                return (
                  (t = xe(t, e, 1)) &&
                  c +
                    (e
                      ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                      : t.join(",")) +
                    ")"
                );
              })),
              n && ((s = be(t)), (i = n.c).join(a) !== s.c.join(a)))
            )
              for (o = (r = t.replace(Ee, "1").split(V)).length - 1; u < o; u++)
                a +=
                  r[u] +
                  (~i.indexOf(u)
                    ? l.shift() || c + "0,0,0,0)"
                    : (s.length ? s : l.length ? l : n).shift());
            if (!r)
              for (o = (r = t.split(Ee)).length - 1; u < o; u++)
                a += r[u] + l[u];
            return a + r[o];
          },
          Ee = (function () {
            var t,
              e =
                "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (t in ye) e += "|" + t + "\\b";
            return new RegExp(e + ")", "gi");
          })(),
          Se = /hsl[a]?\(/,
          Me = function (t) {
            var e,
              n = t.join(" ");
            if (((Ee.lastIndex = 0), Ee.test(n)))
              return (
                (e = Se.test(n)),
                (t[1] = we(t[1], e)),
                (t[0] = we(t[0], e, be(t[1]))),
                !0
              );
          },
          Te = (function () {
            var t,
              e,
              n,
              i,
              r,
              s,
              o = Date.now,
              a = 500,
              l = 33,
              c = o(),
              u = c,
              h = 1e3 / 240,
              d = h,
              v = [],
              y = function n(p) {
                var f,
                  m,
                  g,
                  y,
                  _ = o() - u,
                  x = !0 === p;
                if (
                  ((_ > a || _ < 0) && (c += _ - l),
                  ((f = (g = (u += _) - c) - d) > 0 || x) &&
                    ((y = ++i.frame),
                    (r = g - 1e3 * i.time),
                    (i.time = g /= 1e3),
                    (d += f + (f >= h ? 4 : h - f)),
                    (m = 1)),
                  x || (t = e(n)),
                  m)
                )
                  for (s = 0; s < v.length; s++) v[s](g, r, y, p);
              };
            return (
              (i = {
                time: 0,
                frame: 0,
                tick: function () {
                  y(!0);
                },
                deltaRatio: function (t) {
                  return r / (1e3 / (t || 60));
                },
                wake: function () {
                  g &&
                    (!f &&
                      U() &&
                      ((p = f = window),
                      (m = p.document || {}),
                      (X.gsap = Tn),
                      (p.gsapVersions || (p.gsapVersions = [])).push(
                        Tn.version
                      ),
                      K(Y || p.GreenSockGlobals || (!p.gsap && p) || {}),
                      me.forEach(ge)),
                    (n =
                      "undefined" != typeof requestAnimationFrame &&
                      requestAnimationFrame),
                    t && i.sleep(),
                    (e =
                      n ||
                      function (t) {
                        return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
                      }),
                    (_ = 1),
                    y(2));
                },
                sleep: function () {
                  (n ? cancelAnimationFrame : clearTimeout)(t),
                    (_ = 0),
                    (e = Q);
                },
                lagSmoothing: function (t, e) {
                  (a = t || 1 / 0), (l = Math.min(e || 33, a));
                },
                fps: function (t) {
                  (h = 1e3 / (t || 240)), (d = 1e3 * i.time + h);
                },
                add: function (t, e, n) {
                  var r = e
                    ? function (e, n, s, o) {
                        t(e, n, s, o), i.remove(r);
                      }
                    : t;
                  return i.remove(t), v[n ? "unshift" : "push"](r), Ae(), r;
                },
                remove: function (t, e) {
                  ~(e = v.indexOf(t)) && v.splice(e, 1) && s >= e && s--;
                },
                _listeners: v,
              }),
              i
            );
          })(),
          Ae = function () {
            return !_ && Te.wake();
          },
          Re = {},
          Ce = /^[\d.\-M][\d.\-,\s]/,
          Le = /["']/g,
          Pe = function (t) {
            for (
              var e,
                n,
                i,
                r = {},
                s = t.substr(1, t.length - 3).split(":"),
                o = s[0],
                a = 1,
                l = s.length;
              a < l;
              a++
            )
              (n = s[a]),
                (e = a !== l - 1 ? n.lastIndexOf(",") : n.length),
                (i = n.substr(0, e)),
                (r[o] = isNaN(i) ? i.replace(Le, "").trim() : +i),
                (o = n.substr(e + 1).trim());
            return r;
          },
          Oe = function (t) {
            return function (e) {
              return 1 - t(1 - e);
            };
          },
          Ie = function t(e, n) {
            for (var i, r = e._first; r; )
              r instanceof He
                ? t(r, n)
                : !r.vars.yoyoEase ||
                  (r._yoyo && r._repeat) ||
                  r._yoyo === n ||
                  (r.timeline
                    ? t(r.timeline, n)
                    : ((i = r._ease),
                      (r._ease = r._yEase),
                      (r._yEase = i),
                      (r._yoyo = n))),
                (r = r._next);
          },
          Ne = function (t, e) {
            return (
              (t &&
                (P(t)
                  ? t
                  : Re[t] ||
                    (function (t) {
                      var e,
                        n,
                        i,
                        r,
                        s = (t + "").split("("),
                        o = Re[s[0]];
                      return o && s.length > 1 && o.config
                        ? o.config.apply(
                            null,
                            ~t.indexOf("{")
                              ? [Pe(s[1])]
                              : ((e = t),
                                (n = e.indexOf("(") + 1),
                                (i = e.indexOf(")")),
                                (r = e.indexOf("(", n)),
                                e.substring(
                                  n,
                                  ~r && r < i ? e.indexOf(")", i + 1) : i
                                ))
                                  .split(",")
                                  .map(bt)
                          )
                        : Re._CE && Ce.test(t)
                        ? Re._CE("", t)
                        : o;
                    })(t))) ||
              e
            );
          },
          De = function (t, e, n, i) {
            void 0 === n &&
              (n = function (t) {
                return 1 - e(1 - t);
              }),
              void 0 === i &&
                (i = function (t) {
                  return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
                });
            var r,
              s = {
                easeIn: e,
                easeOut: n,
                easeInOut: i,
              };
            return (
              ft(t, function (t) {
                for (var e in ((Re[t] = X[t] = s),
                (Re[(r = t.toLowerCase())] = n),
                s))
                  Re[
                    r +
                      ("easeIn" === e
                        ? ".in"
                        : "easeOut" === e
                        ? ".out"
                        : ".inOut")
                  ] = Re[t + "." + e] = s[e];
              }),
              s
            );
          },
          Ue = function (t) {
            return function (e) {
              return e < 0.5
                ? (1 - t(1 - 2 * e)) / 2
                : 0.5 + t(2 * (e - 0.5)) / 2;
            };
          },
          Fe = function t(e, n, i) {
            var r = n >= 1 ? n : 1,
              s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
              o = (s / S) * (Math.asin(1 / r) || 0),
              a = function (t) {
                return 1 === t
                  ? 1
                  : r * Math.pow(2, -10 * t) * C((t - o) * s) + 1;
              },
              l =
                "out" === e
                  ? a
                  : "in" === e
                  ? function (t) {
                      return 1 - a(1 - t);
                    }
                  : Ue(a);
            return (
              (s = S / s),
              (l.config = function (n, i) {
                return t(e, n, i);
              }),
              l
            );
          },
          ke = function t(e, n) {
            void 0 === n && (n = 1.70158);
            var i = function (t) {
                return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
              },
              r =
                "out" === e
                  ? i
                  : "in" === e
                  ? function (t) {
                      return 1 - i(1 - t);
                    }
                  : Ue(i);
            return (
              (r.config = function (n) {
                return t(e, n);
              }),
              r
            );
          };
        ft("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
          var n = e < 5 ? e + 1 : e;
          De(
            t + ",Power" + (n - 1),
            e
              ? function (t) {
                  return Math.pow(t, n);
                }
              : function (t) {
                  return t;
                },
            function (t) {
              return 1 - Math.pow(1 - t, n);
            },
            function (t) {
              return t < 0.5
                ? Math.pow(2 * t, n) / 2
                : 1 - Math.pow(2 * (1 - t), n) / 2;
            }
          );
        }),
          (Re.Linear.easeNone = Re.none = Re.Linear.easeIn),
          De("Elastic", Fe("in"), Fe("out"), Fe()),
          (function (t, e) {
            var n = 1 / e,
              i = 2 * n,
              r = 2.5 * n,
              s = function (s) {
                return s < n
                  ? t * s * s
                  : s < i
                  ? t * Math.pow(s - 1.5 / e, 2) + 0.75
                  : s < r
                  ? t * (s -= 2.25 / e) * s + 0.9375
                  : t * Math.pow(s - 2.625 / e, 2) + 0.984375;
              };
            De(
              "Bounce",
              function (t) {
                return 1 - s(1 - t);
              },
              s
            );
          })(7.5625, 2.75),
          De("Expo", function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0;
          }),
          De("Circ", function (t) {
            return -(A(1 - t * t) - 1);
          }),
          De("Sine", function (t) {
            return 1 === t ? 1 : 1 - R(t * M);
          }),
          De("Back", ke("in"), ke("out"), ke()),
          (Re.SteppedEase =
            Re.steps =
            X.SteppedEase =
              {
                config: function (t, e) {
                  void 0 === t && (t = 1);
                  var n = 1 / t,
                    i = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                  return function (t) {
                    return (((i * Zt(0, 0.99999999, t)) | 0) + r) * n;
                  };
                },
              }),
          (b.ease = Re["quad.out"]),
          ft(
            "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
            function (t) {
              return (ut += t + "," + t + "Params,");
            }
          );
        var Be = function (t, e) {
            (this.id = T++),
              (t._gsap = this),
              (this.target = t),
              (this.harness = e),
              (this.get = e ? e.get : pt),
              (this.set = e ? e.getSetter : rn);
          },
          ze = (function () {
            function t(t) {
              (this.vars = t),
                (this._delay = +t.delay || 0),
                (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
                  ((this._rDelay = t.repeatDelay || 0),
                  (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
                (this._ts = 1),
                jt(this, +t.duration, 1, 1),
                (this.data = t.data),
                h && ((this._ctx = h), h.data.push(this)),
                _ || Te.wake();
            }
            var e = t.prototype;
            return (
              (e.delay = function (t) {
                return t || 0 === t
                  ? (this.parent &&
                      this.parent.smoothChildTiming &&
                      this.startTime(this._start + t - this._delay),
                    (this._delay = t),
                    this)
                  : this._delay;
              }),
              (e.duration = function (t) {
                return arguments.length
                  ? this.totalDuration(
                      this._repeat > 0
                        ? t + (t + this._rDelay) * this._repeat
                        : t
                    )
                  : this.totalDuration() && this._dur;
              }),
              (e.totalDuration = function (t) {
                return arguments.length
                  ? ((this._dirty = 0),
                    jt(
                      this,
                      this._repeat < 0
                        ? t
                        : (t - this._repeat * this._rDelay) / (this._repeat + 1)
                    ))
                  : this._tDur;
              }),
              (e.totalTime = function (t, e) {
                if ((Ae(), !arguments.length)) return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                  for (
                    kt(this, t), !n._dp || n.parent || Bt(n, this);
                    n && n.parent;

                  )
                    n.parent._time !==
                      n._start +
                        (n._ts >= 0
                          ? n._tTime / n._ts
                          : (n.totalDuration() - n._tTime) / -n._ts) &&
                      n.totalTime(n._tTime, !0),
                      (n = n.parent);
                  !this.parent &&
                    this._dp.autoRemoveChildren &&
                    ((this._ts > 0 && t < this._tDur) ||
                      (this._ts < 0 && t > 0) ||
                      (!this._tDur && !t)) &&
                    zt(this._dp, this, this._start - this._delay);
                }
                return (
                  (this._tTime !== t ||
                    (!this._dur && !e) ||
                    (this._initted && Math.abs(this._zTime) === E) ||
                    (!t && !this._initted && (this.add || this._ptLookup))) &&
                    (this._ts || (this._pTime = t), xt(this, t, e)),
                  this
                );
              }),
              (e.time = function (t, e) {
                return arguments.length
                  ? this.totalTime(
                      Math.min(this.totalDuration(), t + Nt(this)) %
                        (this._dur + this._rDelay) || (t ? this._dur : 0),
                      e
                    )
                  : this._time;
              }),
              (e.totalProgress = function (t, e) {
                return arguments.length
                  ? this.totalTime(this.totalDuration() * t, e)
                  : this.totalDuration()
                  ? Math.min(1, this._tTime / this._tDur)
                  : this.rawTime() > 0
                  ? 1
                  : 0;
              }),
              (e.progress = function (t, e) {
                return arguments.length
                  ? this.totalTime(
                      this.duration() *
                        (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                        Nt(this),
                      e
                    )
                  : this.duration()
                  ? Math.min(1, this._time / this._dur)
                  : this.rawTime() > 0
                  ? 1
                  : 0;
              }),
              (e.iteration = function (t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length
                  ? this.totalTime(this._time + (t - 1) * n, e)
                  : this._repeat
                  ? Dt(this._tTime, n) + 1
                  : 1;
              }),
              (e.timeScale = function (t, e) {
                if (!arguments.length)
                  return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t) return this;
                var n =
                  this.parent && this._ts
                    ? Ut(this.parent._time, this)
                    : this._tTime;
                return (
                  (this._rts = +t || 0),
                  (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
                  this.totalTime(
                    Zt(-Math.abs(this._delay), this._tDur, n),
                    !1 !== e
                  ),
                  Ft(this),
                  (function (t) {
                    for (var e = t.parent; e && e.parent; )
                      (e._dirty = 1), e.totalDuration(), (e = e.parent);
                    return t;
                  })(this)
                );
              }),
              (e.paused = function (t) {
                return arguments.length
                  ? (this._ps !== t &&
                      ((this._ps = t),
                      t
                        ? ((this._pTime =
                            this._tTime ||
                            Math.max(-this._delay, this.rawTime())),
                          (this._ts = this._act = 0))
                        : (Ae(),
                          (this._ts = this._rts),
                          this.totalTime(
                            this.parent && !this.parent.smoothChildTiming
                              ? this.rawTime()
                              : this._tTime || this._pTime,
                            1 === this.progress() &&
                              Math.abs(this._zTime) !== E &&
                              (this._tTime -= E)
                          ))),
                    this)
                  : this._ps;
              }),
              (e.startTime = function (t) {
                if (arguments.length) {
                  this._start = t;
                  var e = this.parent || this._dp;
                  return (
                    e &&
                      (e._sort || !this.parent) &&
                      zt(e, this, t - this._delay),
                    this
                  );
                }
                return this._start;
              }),
              (e.endTime = function (t) {
                return (
                  this._start +
                  (D(t) ? this.totalDuration() : this.duration()) /
                    Math.abs(this._ts || 1)
                );
              }),
              (e.rawTime = function (t) {
                var e = this.parent || this._dp;
                return e
                  ? t &&
                    (!this._ts ||
                      (this._repeat && this._time && this.totalProgress() < 1))
                    ? this._tTime % (this._dur + this._rDelay)
                    : this._ts
                    ? Ut(e.rawTime(t), this)
                    : this._tTime
                  : this._tTime;
              }),
              (e.revert = function (t) {
                void 0 === t && (t = nt);
                var e = u;
                return (
                  (u = t),
                  (this._initted || this._startAt) &&
                    (this.timeline && this.timeline.revert(t),
                    this.totalTime(-0.01, t.suppressEvents)),
                  "nested" !== this.data && !1 !== t.kill && this.kill(),
                  (u = e),
                  this
                );
              }),
              (e.globalTime = function (t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                  (n = e._start + n / (Math.abs(e._ts) || 1)), (e = e._dp);
                return !this.parent && this._sat ? this._sat.globalTime(t) : n;
              }),
              (e.repeat = function (t) {
                return arguments.length
                  ? ((this._repeat = t === 1 / 0 ? -2 : t), qt(this))
                  : -2 === this._repeat
                  ? 1 / 0
                  : this._repeat;
              }),
              (e.repeatDelay = function (t) {
                if (arguments.length) {
                  var e = this._time;
                  return (this._rDelay = t), qt(this), e ? this.time(e) : this;
                }
                return this._rDelay;
              }),
              (e.yoyo = function (t) {
                return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
              }),
              (e.seek = function (t, e) {
                return this.totalTime(Yt(this, t), D(e));
              }),
              (e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, D(e));
              }),
              (e.play = function (t, e) {
                return (
                  null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                );
              }),
              (e.reverse = function (t, e) {
                return (
                  null != t && this.seek(t || this.totalDuration(), e),
                  this.reversed(!0).paused(!1)
                );
              }),
              (e.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0);
              }),
              (e.resume = function () {
                return this.paused(!1);
              }),
              (e.reversed = function (t) {
                return arguments.length
                  ? (!!t !== this.reversed() &&
                      this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                    this)
                  : this._rts < 0;
              }),
              (e.invalidate = function () {
                return (
                  (this._initted = this._act = 0), (this._zTime = -1e-8), this
                );
              }),
              (e.isActive = function () {
                var t,
                  e = this.parent || this._dp,
                  n = this._start;
                return !(
                  e &&
                  !(
                    this._ts &&
                    this._initted &&
                    e.isActive() &&
                    (t = e.rawTime(!0)) >= n &&
                    t < this.endTime(!0) - E
                  )
                );
              }),
              (e.eventCallback = function (t, e, n) {
                var i = this.vars;
                return arguments.length > 1
                  ? (e
                      ? ((i[t] = e),
                        n && (i[t + "Params"] = n),
                        "onUpdate" === t && (this._onUpdate = e))
                      : delete i[t],
                    this)
                  : i[t];
              }),
              (e.then = function (t) {
                var e = this;
                return new Promise(function (n) {
                  var i = P(t) ? t : wt,
                    r = function () {
                      var t = e.then;
                      (e.then = null),
                        P(i) &&
                          (i = i(e)) &&
                          (i.then || i === e) &&
                          (e.then = t),
                        n(i),
                        (e.then = t);
                    };
                  (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
                  (!e._tTime && e._ts < 0)
                    ? r()
                    : (e._prom = r);
                });
              }),
              (e.kill = function () {
                fe(this);
              }),
              t
            );
          })();
        Et(ze.prototype, {
          _time: 0,
          _start: 0,
          _end: 0,
          _tTime: 0,
          _tDur: 0,
          _dirty: 0,
          _repeat: 0,
          _yoyo: !1,
          parent: null,
          _initted: !1,
          _rDelay: 0,
          _ts: 1,
          _dp: 0,
          ratio: 0,
          _zTime: -1e-8,
          _prom: 0,
          _ps: !1,
          _rts: 1,
        });
        var He = (function (t) {
          function e(e, n) {
            var i;
            return (
              void 0 === e && (e = {}),
              ((i = t.call(this, e) || this).labels = {}),
              (i.smoothChildTiming = !!e.smoothChildTiming),
              (i.autoRemoveChildren = !!e.autoRemoveChildren),
              (i._sort = D(e.sortChildren)),
              d && zt(e.parent || d, a(i), n),
              e.reversed && i.reverse(),
              e.paused && i.paused(!0),
              e.scrollTrigger && Ht(a(i), e.scrollTrigger),
              i
            );
          }
          l(e, t);
          var n = e.prototype;
          return (
            (n.to = function (t, e, n) {
              return Kt(0, arguments, this), this;
            }),
            (n.from = function (t, e, n) {
              return Kt(1, arguments, this), this;
            }),
            (n.fromTo = function (t, e, n, i) {
              return Kt(2, arguments, this), this;
            }),
            (n.set = function (t, e, n) {
              return (
                (e.duration = 0),
                (e.parent = this),
                At(e).repeatDelay || (e.repeat = 0),
                (e.immediateRender = !!e.immediateRender),
                new Je(t, e, Yt(this, n), 1),
                this
              );
            }),
            (n.call = function (t, e, n) {
              return zt(this, Je.delayedCall(0, t, e), n);
            }),
            (n.staggerTo = function (t, e, n, i, r, s, o) {
              return (
                (n.duration = e),
                (n.stagger = n.stagger || i),
                (n.onComplete = s),
                (n.onCompleteParams = o),
                (n.parent = this),
                new Je(t, n, Yt(this, r)),
                this
              );
            }),
            (n.staggerFrom = function (t, e, n, i, r, s, o) {
              return (
                (n.runBackwards = 1),
                (At(n).immediateRender = D(n.immediateRender)),
                this.staggerTo(t, e, n, i, r, s, o)
              );
            }),
            (n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
              return (
                (i.startAt = n),
                (At(i).immediateRender = D(i.immediateRender)),
                this.staggerTo(t, e, i, r, s, o, a)
              );
            }),
            (n.render = function (t, e, n) {
              var i,
                r,
                s,
                o,
                a,
                l,
                c,
                h,
                p,
                f,
                m,
                g,
                v = this._time,
                y = this._dirty ? this.totalDuration() : this._tDur,
                _ = this._dur,
                x = t <= 0 ? 0 : gt(t),
                b = this._zTime < 0 != t < 0 && (this._initted || !_);
              if (
                (this !== d && x > y && t >= 0 && (x = y),
                x !== this._tTime || n || b)
              ) {
                if (
                  (v !== this._time &&
                    _ &&
                    ((x += this._time - v), (t += this._time - v)),
                  (i = x),
                  (p = this._start),
                  (l = !(h = this._ts)),
                  b && (_ || (v = this._zTime), (t || !e) && (this._zTime = t)),
                  this._repeat)
                ) {
                  if (
                    ((m = this._yoyo),
                    (a = _ + this._rDelay),
                    this._repeat < -1 && t < 0)
                  )
                    return this.totalTime(100 * a + t, e, n);
                  if (
                    ((i = gt(x % a)),
                    x === y
                      ? ((o = this._repeat), (i = _))
                      : ((o = ~~(x / a)) && o === x / a && ((i = _), o--),
                        i > _ && (i = _)),
                    (f = Dt(this._tTime, a)),
                    !v &&
                      this._tTime &&
                      f !== o &&
                      this._tTime - f * a - this._dur <= 0 &&
                      (f = o),
                    m && 1 & o && ((i = _ - i), (g = 1)),
                    o !== f && !this._lock)
                  ) {
                    var w = m && 1 & f,
                      S = w === (m && 1 & o);
                    if (
                      (o < f && (w = !w),
                      (v = w ? 0 : x % _ ? _ : x),
                      (this._lock = 1),
                      (this.render(v || (g ? 0 : gt(o * a)), e, !_)._lock = 0),
                      (this._tTime = x),
                      !e && this.parent && pe(this, "onRepeat"),
                      this.vars.repeatRefresh &&
                        !g &&
                        (this.invalidate()._lock = 1),
                      (v && v !== this._time) ||
                        l !== !this._ts ||
                        (this.vars.onRepeat && !this.parent && !this._act))
                    )
                      return this;
                    if (
                      ((_ = this._dur),
                      (y = this._tDur),
                      S &&
                        ((this._lock = 2),
                        (v = w ? _ : -1e-4),
                        this.render(v, !0),
                        this.vars.repeatRefresh && !g && this.invalidate()),
                      (this._lock = 0),
                      !this._ts && !l)
                    )
                      return this;
                    Ie(this, g);
                  }
                }
                if (
                  (this._hasPause &&
                    !this._forcing &&
                    this._lock < 2 &&
                    ((c = (function (t, e, n) {
                      var i;
                      if (n > e)
                        for (i = t._first; i && i._start <= n; ) {
                          if ("isPause" === i.data && i._start > e) return i;
                          i = i._next;
                        }
                      else
                        for (i = t._last; i && i._start >= n; ) {
                          if ("isPause" === i.data && i._start < e) return i;
                          i = i._prev;
                        }
                    })(this, gt(v), gt(i))),
                    c && (x -= i - (i = c._start))),
                  (this._tTime = x),
                  (this._time = i),
                  (this._act = !h),
                  this._initted ||
                    ((this._onUpdate = this.vars.onUpdate),
                    (this._initted = 1),
                    (this._zTime = t),
                    (v = 0)),
                  !v &&
                    i &&
                    !e &&
                    !o &&
                    (pe(this, "onStart"), this._tTime !== x))
                )
                  return this;
                if (i >= v && t >= 0)
                  for (r = this._first; r; ) {
                    if (
                      ((s = r._next),
                      (r._act || i >= r._start) && r._ts && c !== r)
                    ) {
                      if (r.parent !== this) return this.render(t, e, n);
                      if (
                        (r.render(
                          r._ts > 0
                            ? (i - r._start) * r._ts
                            : (r._dirty ? r.totalDuration() : r._tDur) +
                                (i - r._start) * r._ts,
                          e,
                          n
                        ),
                        i !== this._time || (!this._ts && !l))
                      ) {
                        (c = 0), s && (x += this._zTime = -1e-8);
                        break;
                      }
                    }
                    r = s;
                  }
                else {
                  r = this._last;
                  for (var M = t < 0 ? t : i; r; ) {
                    if (
                      ((s = r._prev),
                      (r._act || M <= r._end) && r._ts && c !== r)
                    ) {
                      if (r.parent !== this) return this.render(t, e, n);
                      if (
                        (r.render(
                          r._ts > 0
                            ? (M - r._start) * r._ts
                            : (r._dirty ? r.totalDuration() : r._tDur) +
                                (M - r._start) * r._ts,
                          e,
                          n || (u && (r._initted || r._startAt))
                        ),
                        i !== this._time || (!this._ts && !l))
                      ) {
                        (c = 0), s && (x += this._zTime = M ? -1e-8 : E);
                        break;
                      }
                    }
                    r = s;
                  }
                }
                if (
                  c &&
                  !e &&
                  (this.pause(),
                  (c.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
                  this._ts)
                )
                  return (this._start = p), Ft(this), this.render(t, e, n);
                this._onUpdate && !e && pe(this, "onUpdate", !0),
                  ((x === y && this._tTime >= this.totalDuration()) ||
                    (!x && v)) &&
                    ((p !== this._start &&
                      Math.abs(h) === Math.abs(this._ts)) ||
                      this._lock ||
                      ((t || !_) &&
                        ((x === y && this._ts > 0) || (!x && this._ts < 0)) &&
                        Lt(this, 1),
                      e ||
                        (t < 0 && !v) ||
                        (!x && !v && y) ||
                        (pe(
                          this,
                          x === y && t >= 0
                            ? "onComplete"
                            : "onReverseComplete",
                          !0
                        ),
                        this._prom &&
                          !(x < y && this.timeScale() > 0) &&
                          this._prom())));
              }
              return this;
            }),
            (n.add = function (t, e) {
              var n = this;
              if ((O(e) || (e = Yt(this, e, t)), !(t instanceof ze))) {
                if (B(t))
                  return (
                    t.forEach(function (t) {
                      return n.add(t, e);
                    }),
                    this
                  );
                if (L(t)) return this.addLabel(t, e);
                if (!P(t)) return this;
                t = Je.delayedCall(0, t);
              }
              return this !== t ? zt(this, t, e) : this;
            }),
            (n.getChildren = function (t, e, n, i) {
              void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === n && (n = !0),
                void 0 === i && (i = -w);
              for (var r = [], s = this._first; s; )
                s._start >= i &&
                  (s instanceof Je
                    ? e && r.push(s)
                    : (n && r.push(s),
                      t && r.push.apply(r, s.getChildren(!0, e, n)))),
                  (s = s._next);
              return r;
            }),
            (n.getById = function (t) {
              for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
                if (e[n].vars.id === t) return e[n];
            }),
            (n.remove = function (t) {
              return L(t)
                ? this.removeLabel(t)
                : P(t)
                ? this.killTweensOf(t)
                : (Ct(this, t),
                  t === this._recent && (this._recent = this._last),
                  Pt(this));
            }),
            (n.totalTime = function (e, n) {
              return arguments.length
                ? ((this._forcing = 1),
                  !this._dp &&
                    this._ts &&
                    (this._start = gt(
                      Te.time -
                        (this._ts > 0
                          ? e / this._ts
                          : (this.totalDuration() - e) / -this._ts)
                    )),
                  t.prototype.totalTime.call(this, e, n),
                  (this._forcing = 0),
                  this)
                : this._tTime;
            }),
            (n.addLabel = function (t, e) {
              return (this.labels[t] = Yt(this, e)), this;
            }),
            (n.removeLabel = function (t) {
              return delete this.labels[t], this;
            }),
            (n.addPause = function (t, e, n) {
              var i = Je.delayedCall(0, e || Q, n);
              return (
                (i.data = "isPause"),
                (this._hasPause = 1),
                zt(this, i, Yt(this, t))
              );
            }),
            (n.removePause = function (t) {
              var e = this._first;
              for (t = Yt(this, t); e; )
                e._start === t && "isPause" === e.data && Lt(e), (e = e._next);
            }),
            (n.killTweensOf = function (t, e, n) {
              for (var i = this.getTweensOf(t, n), r = i.length; r--; )
                Ve !== i[r] && i[r].kill(t, e);
              return this;
            }),
            (n.getTweensOf = function (t, e) {
              for (var n, i = [], r = ne(t), s = this._first, o = O(e); s; )
                s instanceof Je
                  ? yt(s._targets, r) &&
                    (o
                      ? (!Ve || (s._initted && s._ts)) &&
                        s.globalTime(0) <= e &&
                        s.globalTime(s.totalDuration()) > e
                      : !e || s.isActive()) &&
                    i.push(s)
                  : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
                  (s = s._next);
              return i;
            }),
            (n.tweenTo = function (t, e) {
              e = e || {};
              var n,
                i = this,
                r = Yt(i, t),
                s = e,
                o = s.startAt,
                a = s.onStart,
                l = s.onStartParams,
                c = s.immediateRender,
                u = Je.to(
                  i,
                  Et(
                    {
                      ease: e.ease || "none",
                      lazy: !1,
                      immediateRender: !1,
                      time: r,
                      overwrite: "auto",
                      duration:
                        e.duration ||
                        Math.abs(
                          (r - (o && "time" in o ? o.time : i._time)) /
                            i.timeScale()
                        ) ||
                        E,
                      onStart: function () {
                        if ((i.pause(), !n)) {
                          var t =
                            e.duration ||
                            Math.abs(
                              (r - (o && "time" in o ? o.time : i._time)) /
                                i.timeScale()
                            );
                          u._dur !== t &&
                            jt(u, t, 0, 1).render(u._time, !0, !0),
                            (n = 1);
                        }
                        a && a.apply(u, l || []);
                      },
                    },
                    e
                  )
                );
              return c ? u.render(0) : u;
            }),
            (n.tweenFromTo = function (t, e, n) {
              return this.tweenTo(
                e,
                Et(
                  {
                    startAt: {
                      time: Yt(this, t),
                    },
                  },
                  n
                )
              );
            }),
            (n.recent = function () {
              return this._recent;
            }),
            (n.nextLabel = function (t) {
              return void 0 === t && (t = this._time), de(this, Yt(this, t));
            }),
            (n.previousLabel = function (t) {
              return void 0 === t && (t = this._time), de(this, Yt(this, t), 1);
            }),
            (n.currentLabel = function (t) {
              return arguments.length
                ? this.seek(t, !0)
                : this.previousLabel(this._time + E);
            }),
            (n.shiftChildren = function (t, e, n) {
              void 0 === n && (n = 0);
              for (var i, r = this._first, s = this.labels; r; )
                r._start >= n && ((r._start += t), (r._end += t)),
                  (r = r._next);
              if (e) for (i in s) s[i] >= n && (s[i] += t);
              return Pt(this);
            }),
            (n.invalidate = function (e) {
              var n = this._first;
              for (this._lock = 0; n; ) n.invalidate(e), (n = n._next);
              return t.prototype.invalidate.call(this, e);
            }),
            (n.clear = function (t) {
              void 0 === t && (t = !0);
              for (var e, n = this._first; n; )
                (e = n._next), this.remove(n), (n = e);
              return (
                this._dp && (this._time = this._tTime = this._pTime = 0),
                t && (this.labels = {}),
                Pt(this)
              );
            }),
            (n.totalDuration = function (t) {
              var e,
                n,
                i,
                r = 0,
                s = this,
                o = s._last,
                a = w;
              if (arguments.length)
                return s.timeScale(
                  (s._repeat < 0 ? s.duration() : s.totalDuration()) /
                    (s.reversed() ? -t : t)
                );
              if (s._dirty) {
                for (i = s.parent; o; )
                  (e = o._prev),
                    o._dirty && o.totalDuration(),
                    (n = o._start) > a && s._sort && o._ts && !s._lock
                      ? ((s._lock = 1), (zt(s, o, n - o._delay, 1)._lock = 0))
                      : (a = n),
                    n < 0 &&
                      o._ts &&
                      ((r -= n),
                      ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                        ((s._start += n / s._ts),
                        (s._time -= n),
                        (s._tTime -= n)),
                      s.shiftChildren(-n, !1, -Infinity),
                      (a = 0)),
                    o._end > r && o._ts && (r = o._end),
                    (o = e);
                jt(s, s === d && s._time > r ? s._time : r, 1, 1),
                  (s._dirty = 0);
              }
              return s._tDur;
            }),
            (e.updateRoot = function (t) {
              if (
                (d._ts && (xt(d, Ut(t, d)), (v = Te.frame)), Te.frame >= lt)
              ) {
                lt += x.autoSleep || 120;
                var e = d._first;
                if ((!e || !e._ts) && x.autoSleep && Te._listeners.length < 2) {
                  for (; e && !e._ts; ) e = e._next;
                  e || Te.sleep();
                }
              }
            }),
            e
          );
        })(ze);
        Et(He.prototype, {
          _lock: 0,
          _hasPause: 0,
          _forcing: 0,
        });
        var Ve,
          Ge,
          We = function (t, e, n, i, r, s, o) {
            var a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m = new pn(this._pt, t, e, 0, 1, an, null, r),
              g = 0,
              v = 0;
            for (
              m.b = n,
                m.e = i,
                n += "",
                (p = ~(i += "").indexOf("random(")) && (i = ue(i)),
                s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
                l = n.match(G) || [];
              (a = G.exec(i));

            )
              (u = a[0]),
                (h = i.substring(g, a.index)),
                c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1),
                u !== l[v++] &&
                  ((d = parseFloat(l[v - 1]) || 0),
                  (m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? vt(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0,
                  }),
                  (g = G.lastIndex));
            return (
              (m.c = g < i.length ? i.substring(g, i.length) : ""),
              (m.fp = o),
              (W.test(i) || p) && (m.e = 0),
              (this._pt = m),
              m
            );
          },
          je = function (t, e, n, i, r, s, o, a, l, c) {
            P(i) && (i = i(r || 0, t, s));
            var u,
              h = t[e],
              d =
                "get" !== n
                  ? n
                  : P(h)
                  ? l
                    ? t[
                        e.indexOf("set") || !P(t["get" + e.substr(3)])
                          ? e
                          : "get" + e.substr(3)
                      ](l)
                    : t[e]()
                  : h,
              p = P(h) ? (l ? en : tn) : Qe;
            if (
              (L(i) &&
                (~i.indexOf("random(") && (i = ue(i)),
                "=" === i.charAt(1) &&
                  ((u = vt(d, i) + (Jt(d) || 0)) || 0 === u) &&
                  (i = u)),
              !c || d !== i || Ge)
            )
              return isNaN(d * i) || "" === i
                ? (!h && !(e in t) && $(e, i),
                  We.call(this, t, e, d, i, p, a || x.stringFilter, l))
                : ((u = new pn(
                    this._pt,
                    t,
                    e,
                    +d || 0,
                    i - (d || 0),
                    "boolean" == typeof h ? on : sn,
                    0,
                    p
                  )),
                  l && (u.fp = l),
                  o && u.modifier(o, this, t),
                  (this._pt = u));
          },
          qe = function (t, e, n, i, r, s) {
            var o, a, l, c;
            if (
              ot[t] &&
              !1 !==
                (o = new ot[t]()).init(
                  r,
                  o.rawVars
                    ? e[t]
                    : (function (t, e, n, i, r) {
                        if (
                          (P(t) && (t = Ke(t, r, e, n, i)),
                          !N(t) || (t.style && t.nodeType) || B(t) || k(t))
                        )
                          return L(t) ? Ke(t, r, e, n, i) : t;
                        var s,
                          o = {};
                        for (s in t) o[s] = Ke(t[s], r, e, n, i);
                        return o;
                      })(e[t], i, r, s, n),
                  n,
                  i,
                  s
                ) &&
              ((n._pt = a =
                new pn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority)),
              n !== y)
            )
              for (
                l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length;
                c--;

              )
                l[o._props[c]] = a;
            return o;
          },
          Xe = function t(e, n, i) {
            var r,
              s,
              o,
              a,
              l,
              h,
              p,
              f,
              m,
              g,
              v,
              y,
              _,
              x = e.vars,
              S = x.ease,
              M = x.startAt,
              T = x.immediateRender,
              A = x.lazy,
              R = x.onUpdate,
              C = x.runBackwards,
              L = x.yoyoEase,
              P = x.keyframes,
              O = x.autoRevert,
              I = e._dur,
              N = e._startAt,
              U = e._targets,
              F = e.parent,
              k = F && "nested" === F.data ? F.vars.targets : U,
              B = "auto" === e._overwrite && !c,
              z = e.timeline;
            if (
              (z && (!P || !S) && (S = "none"),
              (e._ease = Ne(S, b.ease)),
              (e._yEase = L ? Oe(Ne(!0 === L ? S : L, b.ease)) : 0),
              L &&
                e._yoyo &&
                !e._repeat &&
                ((L = e._yEase), (e._yEase = e._ease), (e._ease = L)),
              (e._from = !z && !!x.runBackwards),
              !z || (P && !x.stagger))
            ) {
              if (
                ((y = (f = U[0] ? dt(U[0]).harness : 0) && x[f.prop]),
                (r = Tt(x, it)),
                N &&
                  (N._zTime < 0 && N.progress(1),
                  n < 0 && C && T && !O
                    ? N.render(-1, !0)
                    : N.revert(C && I ? et : tt),
                  (N._lazy = 0)),
                M)
              ) {
                if (
                  (Lt(
                    (e._startAt = Je.set(
                      U,
                      Et(
                        {
                          data: "isStart",
                          overwrite: !1,
                          parent: F,
                          immediateRender: !0,
                          lazy: !N && D(A),
                          startAt: null,
                          delay: 0,
                          onUpdate:
                            R &&
                            function () {
                              return pe(e, "onUpdate");
                            },
                          stagger: 0,
                        },
                        M
                      )
                    ))
                  ),
                  (e._startAt._dp = 0),
                  (e._startAt._sat = e),
                  n < 0 && (u || (!T && !O)) && e._startAt.revert(et),
                  T && I && n <= 0 && i <= 0)
                )
                  return void (n && (e._zTime = n));
              } else if (C && I && !N)
                if (
                  (n && (T = !1),
                  (o = Et(
                    {
                      overwrite: !1,
                      data: "isFromStart",
                      lazy: T && !N && D(A),
                      immediateRender: T,
                      stagger: 0,
                      parent: F,
                    },
                    r
                  )),
                  y && (o[f.prop] = y),
                  Lt((e._startAt = Je.set(U, o))),
                  (e._startAt._dp = 0),
                  (e._startAt._sat = e),
                  n < 0 &&
                    (u ? e._startAt.revert(et) : e._startAt.render(-1, !0)),
                  (e._zTime = n),
                  T)
                ) {
                  if (!n) return;
                } else t(e._startAt, E, E);
              for (
                e._pt = e._ptCache = 0, A = (I && D(A)) || (A && !I), s = 0;
                s < U.length;
                s++
              ) {
                if (
                  ((p = (l = U[s])._gsap || ht(U)[s]._gsap),
                  (e._ptLookup[s] = g = {}),
                  st[p.id] && rt.length && _t(),
                  (v = k === U ? s : k.indexOf(l)),
                  f &&
                    !1 !== (m = new f()).init(l, y || r, e, v, k) &&
                    ((e._pt = a =
                      new pn(
                        e._pt,
                        l,
                        m.name,
                        0,
                        1,
                        m.render,
                        m,
                        0,
                        m.priority
                      )),
                    m._props.forEach(function (t) {
                      g[t] = a;
                    }),
                    m.priority && (h = 1)),
                  !f || y)
                )
                  for (o in r)
                    ot[o] && (m = qe(o, r, e, v, l, k))
                      ? m.priority && (h = 1)
                      : (g[o] = a =
                          je.call(
                            e,
                            l,
                            o,
                            "get",
                            r[o],
                            v,
                            k,
                            0,
                            x.stringFilter
                          ));
                e._op && e._op[s] && e.kill(l, e._op[s]),
                  B &&
                    e._pt &&
                    ((Ve = e),
                    d.killTweensOf(l, g, e.globalTime(n)),
                    (_ = !e.parent),
                    (Ve = 0)),
                  e._pt && A && (st[p.id] = 1);
              }
              h && dn(e), e._onInit && e._onInit(e);
            }
            (e._onUpdate = R),
              (e._initted = (!e._op || e._pt) && !_),
              P && n <= 0 && z.render(w, !0, !0);
          },
          Ye = function (t, e, n, i) {
            var r,
              s,
              o = e.ease || i || "power1.inOut";
            if (B(e))
              (s = n[t] || (n[t] = [])),
                e.forEach(function (t, n) {
                  return s.push({
                    t: (n / (e.length - 1)) * 100,
                    v: t,
                    e: o,
                  });
                });
            else
              for (r in e)
                (s = n[r] || (n[r] = [])),
                  "ease" === r ||
                    s.push({
                      t: parseFloat(t),
                      v: e[r],
                      e: o,
                    });
          },
          Ke = function (t, e, n, i, r) {
            return P(t)
              ? t.call(e, n, i, r)
              : L(t) && ~t.indexOf("random(")
              ? ue(t)
              : t;
          },
          $e = ut + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
          Ze = {};
        ft(
          $e + ",id,stagger,delay,duration,paused,scrollTrigger",
          function (t) {
            return (Ze[t] = 1);
          }
        );
        var Je = (function (t) {
          function e(e, n, i, r) {
            var s;
            "number" == typeof n && ((i.duration = n), (n = i), (i = null));
            var o,
              l,
              u,
              h,
              p,
              f,
              m,
              g,
              v = (s = t.call(this, r ? n : At(n)) || this).vars,
              y = v.duration,
              _ = v.delay,
              b = v.immediateRender,
              w = v.stagger,
              E = v.overwrite,
              S = v.keyframes,
              M = v.defaults,
              T = v.scrollTrigger,
              A = v.yoyoEase,
              R = n.parent || d,
              C = (B(e) || k(e) ? O(e[0]) : "length" in n) ? [e] : ne(e);
            if (
              ((s._targets = C.length
                ? ht(C)
                : Z(
                    "GSAP target " + e + " not found. https://gsap.com",
                    !x.nullTargetWarn
                  ) || []),
              (s._ptLookup = []),
              (s._overwrite = E),
              S || w || F(y) || F(_))
            ) {
              if (
                ((n = s.vars),
                (o = s.timeline =
                  new He({
                    data: "nested",
                    defaults: M || {},
                    targets: R && "nested" === R.data ? R.vars.targets : C,
                  })).kill(),
                (o.parent = o._dp = a(s)),
                (o._start = 0),
                w || F(y) || F(_))
              ) {
                if (((h = C.length), (m = w && se(w)), N(w)))
                  for (p in w) ~$e.indexOf(p) && (g || (g = {}), (g[p] = w[p]));
                for (l = 0; l < h; l++)
                  ((u = Tt(n, Ze)).stagger = 0),
                    A && (u.yoyoEase = A),
                    g && St(u, g),
                    (f = C[l]),
                    (u.duration = +Ke(y, a(s), l, f, C)),
                    (u.delay = (+Ke(_, a(s), l, f, C) || 0) - s._delay),
                    !w &&
                      1 === h &&
                      u.delay &&
                      ((s._delay = _ = u.delay),
                      (s._start += _),
                      (u.delay = 0)),
                    o.to(f, u, m ? m(l, f, C) : 0),
                    (o._ease = Re.none);
                o.duration() ? (y = _ = 0) : (s.timeline = 0);
              } else if (S) {
                At(
                  Et(o.vars.defaults, {
                    ease: "none",
                  })
                ),
                  (o._ease = Ne(S.ease || n.ease || "none"));
                var L,
                  P,
                  I,
                  U = 0;
                if (B(S))
                  S.forEach(function (t) {
                    return o.to(C, t, ">");
                  }),
                    o.duration();
                else {
                  for (p in ((u = {}), S))
                    "ease" === p ||
                      "easeEach" === p ||
                      Ye(p, S[p], u, S.easeEach);
                  for (p in u)
                    for (
                      L = u[p].sort(function (t, e) {
                        return t.t - e.t;
                      }),
                        U = 0,
                        l = 0;
                      l < L.length;
                      l++
                    )
                      ((I = {
                        ease: (P = L[l]).e,
                        duration: ((P.t - (l ? L[l - 1].t : 0)) / 100) * y,
                      })[p] = P.v),
                        o.to(C, I, U),
                        (U += I.duration);
                  o.duration() < y &&
                    o.to(
                      {},
                      {
                        duration: y - o.duration(),
                      }
                    );
                }
              }
              y || s.duration((y = o.duration()));
            } else s.timeline = 0;
            return (
              !0 !== E || c || ((Ve = a(s)), d.killTweensOf(C), (Ve = 0)),
              zt(R, a(s), i),
              n.reversed && s.reverse(),
              n.paused && s.paused(!0),
              (b ||
                (!y &&
                  !S &&
                  s._start === gt(R._time) &&
                  D(b) &&
                  It(a(s)) &&
                  "nested" !== R.data)) &&
                ((s._tTime = -1e-8), s.render(Math.max(0, -_) || 0)),
              T && Ht(a(s), T),
              s
            );
          }
          l(e, t);
          var n = e.prototype;
          return (
            (n.render = function (t, e, n) {
              var i,
                r,
                s,
                o,
                a,
                l,
                c,
                h,
                d,
                p = this._time,
                f = this._tDur,
                m = this._dur,
                g = t < 0,
                v = t > f - E && !g ? f : t < E ? 0 : t;
              if (m) {
                if (
                  v !== this._tTime ||
                  !t ||
                  n ||
                  (!this._initted && this._tTime) ||
                  (this._startAt && this._zTime < 0 !== g)
                ) {
                  if (((i = v), (h = this.timeline), this._repeat)) {
                    if (((o = m + this._rDelay), this._repeat < -1 && g))
                      return this.totalTime(100 * o + t, e, n);
                    if (
                      ((i = gt(v % o)),
                      v === f
                        ? ((s = this._repeat), (i = m))
                        : ((s = ~~(v / o)) && s === gt(v / o) && ((i = m), s--),
                          i > m && (i = m)),
                      (l = this._yoyo && 1 & s) &&
                        ((d = this._yEase), (i = m - i)),
                      (a = Dt(this._tTime, o)),
                      i === p && !n && this._initted && s === a)
                    )
                      return (this._tTime = v), this;
                    s !== a &&
                      (h && this._yEase && Ie(h, l),
                      this.vars.repeatRefresh &&
                        !l &&
                        !this._lock &&
                        this._time !== o &&
                        this._initted &&
                        ((this._lock = n = 1),
                        (this.render(gt(o * s), !0).invalidate()._lock = 0)));
                  }
                  if (!this._initted) {
                    if (Vt(this, g ? t : i, n, e, v))
                      return (this._tTime = 0), this;
                    if (
                      !(
                        p === this._time ||
                        (n && this.vars.repeatRefresh && s !== a)
                      )
                    )
                      return this;
                    if (m !== this._dur) return this.render(t, e, n);
                  }
                  if (
                    ((this._tTime = v),
                    (this._time = i),
                    !this._act &&
                      this._ts &&
                      ((this._act = 1), (this._lazy = 0)),
                    (this.ratio = c = (d || this._ease)(i / m)),
                    this._from && (this.ratio = c = 1 - c),
                    i &&
                      !p &&
                      !e &&
                      !s &&
                      (pe(this, "onStart"), this._tTime !== v))
                  )
                    return this;
                  for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
                  (h &&
                    h.render(
                      t < 0 ? t : h._dur * h._ease(i / this._dur),
                      e,
                      n
                    )) ||
                    (this._startAt && (this._zTime = t)),
                    this._onUpdate &&
                      !e &&
                      (g && Ot(this, t, 0, n), pe(this, "onUpdate")),
                    this._repeat &&
                      s !== a &&
                      this.vars.onRepeat &&
                      !e &&
                      this.parent &&
                      pe(this, "onRepeat"),
                    (v !== this._tDur && v) ||
                      this._tTime !== v ||
                      (g && !this._onUpdate && Ot(this, t, 0, !0),
                      (t || !m) &&
                        ((v === this._tDur && this._ts > 0) ||
                          (!v && this._ts < 0)) &&
                        Lt(this, 1),
                      e ||
                        (g && !p) ||
                        !(v || p || l) ||
                        (pe(
                          this,
                          v === f ? "onComplete" : "onReverseComplete",
                          !0
                        ),
                        this._prom &&
                          !(v < f && this.timeScale() > 0) &&
                          this._prom()));
                }
              } else
                !(function (t, e, n, i) {
                  var r,
                    s,
                    o,
                    a = t.ratio,
                    l =
                      e < 0 ||
                      (!e &&
                        ((!t._start && Gt(t) && (t._initted || !Wt(t))) ||
                          ((t._ts < 0 || t._dp._ts < 0) && !Wt(t))))
                        ? 0
                        : 1,
                    c = t._rDelay,
                    h = 0;
                  if (
                    (c &&
                      t._repeat &&
                      ((h = Zt(0, t._tDur, e)),
                      (s = Dt(h, c)),
                      t._yoyo && 1 & s && (l = 1 - l),
                      s !== Dt(t._tTime, c) &&
                        ((a = 1 - l),
                        t.vars.repeatRefresh && t._initted && t.invalidate())),
                    l !== a || u || i || t._zTime === E || (!e && t._zTime))
                  ) {
                    if (!t._initted && Vt(t, e, i, n, h)) return;
                    for (
                      o = t._zTime,
                        t._zTime = e || (n ? E : 0),
                        n || (n = e && !o),
                        t.ratio = l,
                        t._from && (l = 1 - l),
                        t._time = 0,
                        t._tTime = h,
                        r = t._pt;
                      r;

                    )
                      r.r(l, r.d), (r = r._next);
                    e < 0 && Ot(t, e, 0, !0),
                      t._onUpdate && !n && pe(t, "onUpdate"),
                      h && t._repeat && !n && t.parent && pe(t, "onRepeat"),
                      (e >= t._tDur || e < 0) &&
                        t.ratio === l &&
                        (l && Lt(t, 1),
                        n ||
                          u ||
                          (pe(t, l ? "onComplete" : "onReverseComplete", !0),
                          t._prom && t._prom()));
                  } else t._zTime || (t._zTime = e);
                })(this, t, e, n);
              return this;
            }),
            (n.targets = function () {
              return this._targets;
            }),
            (n.invalidate = function (e) {
              return (
                (!e || !this.vars.runBackwards) && (this._startAt = 0),
                (this._pt =
                  this._op =
                  this._onUpdate =
                  this._lazy =
                  this.ratio =
                    0),
                (this._ptLookup = []),
                this.timeline && this.timeline.invalidate(e),
                t.prototype.invalidate.call(this, e)
              );
            }),
            (n.resetTo = function (t, e, n, i, r) {
              _ || Te.wake(), this._ts || this.play();
              var s = Math.min(
                this._dur,
                (this._dp._time - this._start) * this._ts
              );
              return (
                this._initted || Xe(this, s),
                (function (t, e, n, i, r, s, o, a) {
                  var l,
                    c,
                    u,
                    h,
                    d = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
                  if (!d)
                    for (
                      d = t._ptCache[e] = [],
                        u = t._ptLookup,
                        h = t._targets.length;
                      h--;

                    ) {
                      if ((l = u[h][e]) && l.d && l.d._pt)
                        for (l = l.d._pt; l && l.p !== e && l.fp !== e; )
                          l = l._next;
                      if (!l)
                        return (
                          (Ge = 1),
                          (t.vars[e] = "+=0"),
                          Xe(t, o),
                          (Ge = 0),
                          a ? Z(e + " not eligible for reset") : 1
                        );
                      d.push(l);
                    }
                  for (h = d.length; h--; )
                    ((l = (c = d[h])._pt || c).s =
                      (!i && 0 !== i) || r ? l.s + (i || 0) + s * l.c : i),
                      (l.c = n - l.s),
                      c.e && (c.e = mt(n) + Jt(c.e)),
                      c.b && (c.b = l.s + Jt(c.b));
                })(this, t, e, n, i, this._ease(s / this._dur), s, r)
                  ? this.resetTo(t, e, n, i, 1)
                  : (kt(this, 0),
                    this.parent ||
                      Rt(
                        this._dp,
                        this,
                        "_first",
                        "_last",
                        this._dp._sort ? "_start" : 0
                      ),
                    this.render(0))
              );
            }),
            (n.kill = function (t, e) {
              if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
                return (
                  (this._lazy = this._pt = 0), this.parent ? fe(this) : this
                );
              if (this.timeline) {
                var n = this.timeline.totalDuration();
                return (
                  this.timeline.killTweensOf(
                    t,
                    e,
                    Ve && !0 !== Ve.vars.overwrite
                  )._first || fe(this),
                  this.parent &&
                    n !== this.timeline.totalDuration() &&
                    jt(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                  this
                );
              }
              var i,
                r,
                s,
                o,
                a,
                l,
                c,
                u = this._targets,
                h = t ? ne(t) : u,
                d = this._ptLookup,
                p = this._pt;
              if (
                (!e || "all" === e) &&
                (function (t, e) {
                  for (
                    var n = t.length, i = n === e.length;
                    i && n-- && t[n] === e[n];

                  );
                  return n < 0;
                })(u, h)
              )
                return "all" === e && (this._pt = 0), fe(this);
              for (
                i = this._op = this._op || [],
                  "all" !== e &&
                    (L(e) &&
                      ((a = {}),
                      ft(e, function (t) {
                        return (a[t] = 1);
                      }),
                      (e = a)),
                    (e = (function (t, e) {
                      var n,
                        i,
                        r,
                        s,
                        o = t[0] ? dt(t[0]).harness : 0,
                        a = o && o.aliases;
                      if (!a) return e;
                      for (i in ((n = St({}, e)), a))
                        if ((i in n))
                          for (r = (s = a[i].split(",")).length; r--; )
                            n[s[r]] = n[i];
                      return n;
                    })(u, e))),
                  c = u.length;
                c--;

              )
                if (~h.indexOf(u[c]))
                  for (a in ((r = d[c]),
                  "all" === e
                    ? ((i[c] = e), (o = r), (s = {}))
                    : ((s = i[c] = i[c] || {}), (o = e)),
                  o))
                    (l = r && r[a]) &&
                      (("kill" in l.d && !0 !== l.d.kill(a)) ||
                        Ct(this, l, "_pt"),
                      delete r[a]),
                      "all" !== s && (s[a] = 1);
              return this._initted && !this._pt && p && fe(this), this;
            }),
            (e.to = function (t, n) {
              return new e(t, n, arguments[2]);
            }),
            (e.from = function (t, e) {
              return Kt(1, arguments);
            }),
            (e.delayedCall = function (t, n, i, r) {
              return new e(n, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: t,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: r,
              });
            }),
            (e.fromTo = function (t, e, n) {
              return Kt(2, arguments);
            }),
            (e.set = function (t, n) {
              return (
                (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n)
              );
            }),
            (e.killTweensOf = function (t, e, n) {
              return d.killTweensOf(t, e, n);
            }),
            e
          );
        })(ze);
        Et(Je.prototype, {
          _targets: [],
          _lazy: 0,
          _startAt: 0,
          _op: 0,
          _onInit: 0,
        }),
          ft("staggerTo,staggerFrom,staggerFromTo", function (t) {
            Je[t] = function () {
              var e = new He(),
                n = Qt.call(arguments, 0);
              return (
                n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
              );
            };
          });
        var Qe = function (t, e, n) {
            return (t[e] = n);
          },
          tn = function (t, e, n) {
            return t[e](n);
          },
          en = function (t, e, n, i) {
            return t[e](i.fp, n);
          },
          nn = function (t, e, n) {
            return t.setAttribute(e, n);
          },
          rn = function (t, e) {
            return P(t[e]) ? tn : I(t[e]) && t.setAttribute ? nn : Qe;
          },
          sn = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
          },
          on = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e);
          },
          an = function (t, e) {
            var n = e._pt,
              i = "";
            if (!t && e.b) i = e.b;
            else if (1 === t && e.e) i = e.e;
            else {
              for (; n; )
                (i =
                  n.p +
                  (n.m
                    ? n.m(n.s + n.c * t)
                    : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
                  i),
                  (n = n._next);
              i += e.c;
            }
            e.set(e.t, e.p, i, e);
          },
          ln = function (t, e) {
            for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
          },
          cn = function (t, e, n, i) {
            for (var r, s = this._pt; s; )
              (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
          },
          un = function (t) {
            for (var e, n, i = this._pt; i; )
              (n = i._next),
                (i.p === t && !i.op) || i.op === t
                  ? Ct(this, i, "_pt")
                  : i.dep || (e = 1),
                (i = n);
            return !e;
          },
          hn = function (t, e, n, i) {
            i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
          },
          dn = function (t) {
            for (var e, n, i, r, s = t._pt; s; ) {
              for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
              (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
                (s._next = n) ? (n._prev = s) : (r = s),
                (s = e);
            }
            t._pt = i;
          },
          pn = (function () {
            function t(t, e, n, i, r, s, o, a, l) {
              (this.t = e),
                (this.s = i),
                (this.c = r),
                (this.p = n),
                (this.r = s || sn),
                (this.d = o || this),
                (this.set = a || Qe),
                (this.pr = l || 0),
                (this._next = t),
                t && (t._prev = this);
            }
            return (
              (t.prototype.modifier = function (t, e, n) {
                (this.mSet = this.mSet || this.set),
                  (this.set = hn),
                  (this.m = t),
                  (this.mt = n),
                  (this.tween = e);
              }),
              t
            );
          })();
        ft(
          ut +
            "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
          function (t) {
            return (it[t] = 1);
          }
        ),
          (X.TweenMax = X.TweenLite = Je),
          (X.TimelineLite = X.TimelineMax = He),
          (d = new He({
            sortChildren: !1,
            defaults: b,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0,
          })),
          (x.stringFilter = Me);
        var fn = [],
          mn = {},
          gn = [],
          vn = 0,
          yn = 0,
          _n = function (t) {
            return (mn[t] || gn).map(function (t) {
              return t();
            });
          },
          xn = function () {
            var t = Date.now(),
              e = [];
            t - vn > 2 &&
              (_n("matchMediaInit"),
              fn.forEach(function (t) {
                var n,
                  i,
                  r,
                  s,
                  o = t.queries,
                  a = t.conditions;
                for (i in o)
                  (n = p.matchMedia(o[i]).matches) && (r = 1),
                    n !== a[i] && ((a[i] = n), (s = 1));
                s && (t.revert(), r && e.push(t));
              }),
              _n("matchMediaRevert"),
              e.forEach(function (t) {
                return t.onMatch(t, function (e) {
                  return t.add(null, e);
                });
              }),
              (vn = t),
              _n("matchMedia"));
          },
          bn = (function () {
            function t(t, e) {
              (this.selector = e && ie(e)),
                (this.data = []),
                (this._r = []),
                (this.isReverted = !1),
                (this.id = yn++),
                t && this.add(t);
            }
            var e = t.prototype;
            return (
              (e.add = function (t, e, n) {
                P(t) && ((n = e), (e = t), (t = P));
                var i = this,
                  r = function () {
                    var t,
                      r = h,
                      s = i.selector;
                    return (
                      r && r !== i && r.data.push(i),
                      n && (i.selector = ie(n)),
                      (h = i),
                      (t = e.apply(i, arguments)),
                      P(t) && i._r.push(t),
                      (h = r),
                      (i.selector = s),
                      (i.isReverted = !1),
                      t
                    );
                  };
                return (
                  (i.last = r),
                  t === P
                    ? r(i, function (t) {
                        return i.add(null, t);
                      })
                    : t
                    ? (i[t] = r)
                    : r
                );
              }),
              (e.ignore = function (t) {
                var e = h;
                (h = null), t(this), (h = e);
              }),
              (e.getTweens = function () {
                var e = [];
                return (
                  this.data.forEach(function (n) {
                    return n instanceof t
                      ? e.push.apply(e, n.getTweens())
                      : n instanceof Je &&
                          !(n.parent && "nested" === n.parent.data) &&
                          e.push(n);
                  }),
                  e
                );
              }),
              (e.clear = function () {
                this._r.length = this.data.length = 0;
              }),
              (e.kill = function (t, e) {
                var n = this;
                if (
                  (t
                    ? (function () {
                        for (var e, i = n.getTweens(), r = n.data.length; r--; )
                          "isFlip" === (e = n.data[r]).data &&
                            (e.revert(),
                            e.getChildren(!0, !0, !1).forEach(function (t) {
                              return i.splice(i.indexOf(t), 1);
                            }));
                        for (
                          i
                            .map(function (t) {
                              return {
                                g:
                                  t._dur ||
                                  t._delay ||
                                  (t._sat && !t._sat.vars.immediateRender)
                                    ? t.globalTime(0)
                                    : -1 / 0,
                                t,
                              };
                            })
                            .sort(function (t, e) {
                              return e.g - t.g || -1 / 0;
                            })
                            .forEach(function (e) {
                              return e.t.revert(t);
                            }),
                            r = n.data.length;
                          r--;

                        )
                          (e = n.data[r]) instanceof He
                            ? "nested" !== e.data &&
                              (e.scrollTrigger && e.scrollTrigger.revert(),
                              e.kill())
                            : !(e instanceof Je) && e.revert && e.revert(t);
                        n._r.forEach(function (e) {
                          return e(t, n);
                        }),
                          (n.isReverted = !0);
                      })()
                    : this.data.forEach(function (t) {
                        return t.kill && t.kill();
                      }),
                  this.clear(),
                  e)
                )
                  for (var i = fn.length; i--; )
                    fn[i].id === this.id && fn.splice(i, 1);
              }),
              (e.revert = function (t) {
                this.kill(t || {});
              }),
              t
            );
          })(),
          wn = (function () {
            function t(t) {
              (this.contexts = []), (this.scope = t), h && h.data.push(this);
            }
            var e = t.prototype;
            return (
              (e.add = function (t, e, n) {
                N(t) ||
                  (t = {
                    matches: t,
                  });
                var i,
                  r,
                  s,
                  o = new bn(0, n || this.scope),
                  a = (o.conditions = {});
                for (r in (h && !o.selector && (o.selector = h.selector),
                this.contexts.push(o),
                (e = o.add("onMatch", e)),
                (o.queries = t),
                t))
                  "all" === r
                    ? (s = 1)
                    : (i = p.matchMedia(t[r])) &&
                      (fn.indexOf(o) < 0 && fn.push(o),
                      (a[r] = i.matches) && (s = 1),
                      i.addListener
                        ? i.addListener(xn)
                        : i.addEventListener("change", xn));
                return (
                  s &&
                    e(o, function (t) {
                      return o.add(null, t);
                    }),
                  this
                );
              }),
              (e.revert = function (t) {
                this.kill(t || {});
              }),
              (e.kill = function (t) {
                this.contexts.forEach(function (e) {
                  return e.kill(t, !0);
                });
              }),
              t
            );
          })(),
          En = {
            registerPlugin: function () {
              for (
                var t = arguments.length, e = new Array(t), n = 0;
                n < t;
                n++
              )
                e[n] = arguments[n];
              e.forEach(function (t) {
                return ge(t);
              });
            },
            timeline: function (t) {
              return new He(t);
            },
            getTweensOf: function (t, e) {
              return d.getTweensOf(t, e);
            },
            getProperty: function (t, e, n, i) {
              L(t) && (t = ne(t)[0]);
              var r = dt(t || {}).get,
                s = n ? wt : bt;
              return (
                "native" === n && (n = ""),
                t
                  ? e
                    ? s(((ot[e] && ot[e].get) || r)(t, e, n, i))
                    : function (e, n, i) {
                        return s(((ot[e] && ot[e].get) || r)(t, e, n, i));
                      }
                  : t
              );
            },
            quickSetter: function (t, e, n) {
              if ((t = ne(t)).length > 1) {
                var i = t.map(function (t) {
                    return Tn.quickSetter(t, e, n);
                  }),
                  r = i.length;
                return function (t) {
                  for (var e = r; e--; ) i[e](t);
                };
              }
              t = t[0] || {};
              var s = ot[e],
                o = dt(t),
                a = (o.harness && (o.harness.aliases || {})[e]) || e,
                l = s
                  ? function (e) {
                      var i = new s();
                      (y._pt = 0),
                        i.init(t, n ? e + n : e, y, 0, [t]),
                        i.render(1, i),
                        y._pt && ln(1, y);
                    }
                  : o.set(t, a);
              return s
                ? l
                : function (e) {
                    return l(t, a, n ? e + n : e, o, 1);
                  };
            },
            quickTo: function (t, e, n) {
              var i,
                r = Tn.to(
                  t,
                  St((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
                ),
                s = function (t, n, i) {
                  return r.resetTo(e, t, n, i);
                };
              return (s.tween = r), s;
            },
            isTweening: function (t) {
              return d.getTweensOf(t, !0).length > 0;
            },
            defaults: function (t) {
              return (
                t && t.ease && (t.ease = Ne(t.ease, b.ease)), Mt(b, t || {})
              );
            },
            config: function (t) {
              return Mt(x, t || {});
            },
            registerEffect: function (t) {
              var e = t.name,
                n = t.effect,
                i = t.plugins,
                r = t.defaults,
                s = t.extendTimeline;
              (i || "").split(",").forEach(function (t) {
                return (
                  t &&
                  !ot[t] &&
                  !X[t] &&
                  Z(e + " effect requires " + t + " plugin.")
                );
              }),
                (at[e] = function (t, e, i) {
                  return n(ne(t), Et(e || {}, r), i);
                }),
                s &&
                  (He.prototype[e] = function (t, n, i) {
                    return this.add(
                      at[e](t, N(n) ? n : (i = n) && {}, this),
                      i
                    );
                  });
            },
            registerEase: function (t, e) {
              Re[t] = Ne(e);
            },
            parseEase: function (t, e) {
              return arguments.length ? Ne(t, e) : Re;
            },
            getById: function (t) {
              return d.getById(t);
            },
            exportRoot: function (t, e) {
              void 0 === t && (t = {});
              var n,
                i,
                r = new He(t);
              for (
                r.smoothChildTiming = D(t.smoothChildTiming),
                  d.remove(r),
                  r._dp = 0,
                  r._time = r._tTime = d._time,
                  n = d._first;
                n;

              )
                (i = n._next),
                  (!e &&
                    !n._dur &&
                    n instanceof Je &&
                    n.vars.onComplete === n._targets[0]) ||
                    zt(r, n, n._start - n._delay),
                  (n = i);
              return zt(d, r, 0), r;
            },
            context: function (t, e) {
              return t ? new bn(t, e) : h;
            },
            matchMedia: function (t) {
              return new wn(t);
            },
            matchMediaRefresh: function () {
              return (
                fn.forEach(function (t) {
                  var e,
                    n,
                    i = t.conditions;
                  for (n in i) i[n] && ((i[n] = !1), (e = 1));
                  e && t.revert();
                }) || xn()
              );
            },
            addEventListener: function (t, e) {
              var n = mn[t] || (mn[t] = []);
              ~n.indexOf(e) || n.push(e);
            },
            removeEventListener: function (t, e) {
              var n = mn[t],
                i = n && n.indexOf(e);
              i >= 0 && n.splice(i, 1);
            },
            utils: {
              wrap: function t(e, n, i) {
                var r = n - e;
                return B(e)
                  ? ce(e, t(0, e.length), n)
                  : $t(i, function (t) {
                      return ((r + ((t - e) % r)) % r) + e;
                    });
              },
              wrapYoyo: function t(e, n, i) {
                var r = n - e,
                  s = 2 * r;
                return B(e)
                  ? ce(e, t(0, e.length - 1), n)
                  : $t(i, function (t) {
                      return (
                        e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t)
                      );
                    });
              },
              distribute: se,
              random: le,
              snap: ae,
              normalize: function (t, e, n) {
                return he(t, e, 0, 1, n);
              },
              getUnit: Jt,
              clamp: function (t, e, n) {
                return $t(n, function (n) {
                  return Zt(t, e, n);
                });
              },
              splitColor: xe,
              toArray: ne,
              selector: ie,
              mapRange: he,
              pipe: function () {
                for (
                  var t = arguments.length, e = new Array(t), n = 0;
                  n < t;
                  n++
                )
                  e[n] = arguments[n];
                return function (t) {
                  return e.reduce(function (t, e) {
                    return e(t);
                  }, t);
                };
              },
              unitize: function (t, e) {
                return function (n) {
                  return t(parseFloat(n)) + (e || Jt(n));
                };
              },
              interpolate: function t(e, n, i, r) {
                var s = isNaN(e + n)
                  ? 0
                  : function (t) {
                      return (1 - t) * e + t * n;
                    };
                if (!s) {
                  var o,
                    a,
                    l,
                    c,
                    u,
                    h = L(e),
                    d = {};
                  if ((!0 === i && (r = 1) && (i = null), h))
                    (e = {
                      p: e,
                    }),
                      (n = {
                        p: n,
                      });
                  else if (B(e) && !B(n)) {
                    for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++)
                      l.push(t(e[a - 1], e[a]));
                    c--,
                      (s = function (t) {
                        t *= c;
                        var e = Math.min(u, ~~t);
                        return l[e](t - e);
                      }),
                      (i = n);
                  } else r || (e = St(B(e) ? [] : {}, e));
                  if (!l) {
                    for (o in n) je.call(d, e, o, "get", n[o]);
                    s = function (t) {
                      return ln(t, d) || (h ? e.p : e);
                    };
                  }
                }
                return $t(i, s);
              },
              shuffle: re,
            },
            install: K,
            effects: at,
            ticker: Te,
            updateRoot: He.updateRoot,
            plugins: ot,
            globalTimeline: d,
            core: {
              PropTween: pn,
              globals: J,
              Tween: Je,
              Timeline: He,
              Animation: ze,
              getCache: dt,
              _removeLinkedListItem: Ct,
              reverting: function () {
                return u;
              },
              context: function (t) {
                return t && h && (h.data.push(t), (t._ctx = h)), h;
              },
              suppressOverwrites: function (t) {
                return (c = t);
              },
            },
          };
        ft("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
          return (En[t] = Je[t]);
        }),
          Te.add(He.updateRoot),
          (y = En.to(
            {},
            {
              duration: 0,
            }
          ));
        var Sn = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
              n = n._next;
            return n;
          },
          Mn = function (t, e) {
            return {
              name: t,
              rawVars: 1,
              init: function (t, n, i) {
                i._onInit = function (t) {
                  var i, r;
                  if (
                    (L(n) &&
                      ((i = {}),
                      ft(n, function (t) {
                        return (i[t] = 1);
                      }),
                      (n = i)),
                    e)
                  ) {
                    for (r in ((i = {}), n)) i[r] = e(n[r]);
                    n = i;
                  }
                  !(function (t, e) {
                    var n,
                      i,
                      r,
                      s = t._targets;
                    for (n in e)
                      for (i = s.length; i--; )
                        (r = t._ptLookup[i][n]) &&
                          (r = r.d) &&
                          (r._pt && (r = Sn(r, n)),
                          r && r.modifier && r.modifier(e[n], t, s[i], n));
                  })(t, n);
                };
              },
            };
          },
          Tn =
            En.registerPlugin(
              {
                name: "attr",
                init: function (t, e, n, i, r) {
                  var s, o, a;
                  for (s in ((this.tween = n), e))
                    (a = t.getAttribute(s) || ""),
                      ((o = this.add(
                        t,
                        "setAttribute",
                        (a || 0) + "",
                        e[s],
                        i,
                        r,
                        0,
                        0,
                        s
                      )).op = s),
                      (o.b = a),
                      this._props.push(s);
                },
                render: function (t, e) {
                  for (var n = e._pt; n; )
                    u ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
                },
              },
              {
                name: "endArray",
                init: function (t, e) {
                  for (var n = e.length; n--; )
                    this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
                },
              },
              Mn("roundProps", oe),
              Mn("modifiers"),
              Mn("snap", ae)
            ) || En;
        (Je.version = He.version = Tn.version = "3.12.5"), (g = 1), U() && Ae();
        Re.Power0,
          Re.Power1,
          Re.Power2,
          Re.Power3,
          Re.Power4,
          Re.Linear,
          Re.Quad,
          Re.Cubic,
          Re.Quart,
          Re.Quint,
          Re.Strong,
          Re.Elastic,
          Re.Back,
          Re.SteppedEase,
          Re.Bounce,
          Re.Sine,
          Re.Expo,
          Re.Circ;
        var An,
          Rn,
          Cn,
          Ln,
          Pn,
          On,
          In,
          Nn,
          Dn = {},
          Un = 180 / Math.PI,
          Fn = Math.PI / 180,
          kn = Math.atan2,
          Bn = /([A-Z])/g,
          zn = /(left|right|width|margin|padding|x)/i,
          Hn = /[\s,\(]\S/,
          Vn = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity",
          },
          Gn = function (t, e) {
            return e.set(
              e.t,
              e.p,
              Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
              e
            );
          },
          Wn = function (t, e) {
            return e.set(
              e.t,
              e.p,
              1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
              e
            );
          },
          jn = function (t, e) {
            return e.set(
              e.t,
              e.p,
              t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
              e
            );
          },
          qn = function (t, e) {
            var n = e.s + e.c * t;
            e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
          },
          Xn = function (t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e);
          },
          Yn = function (t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
          },
          Kn = function (t, e, n) {
            return (t.style[e] = n);
          },
          $n = function (t, e, n) {
            return t.style.setProperty(e, n);
          },
          Zn = function (t, e, n) {
            return (t._gsap[e] = n);
          },
          Jn = function (t, e, n) {
            return (t._gsap.scaleX = t._gsap.scaleY = n);
          },
          Qn = function (t, e, n, i, r) {
            var s = t._gsap;
            (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
          },
          ti = function (t, e, n, i, r) {
            var s = t._gsap;
            (s[e] = n), s.renderTransform(r, s);
          },
          ei = "transform",
          ni = ei + "Origin",
          ii = function t(e, n) {
            var i = this,
              r = this.target,
              s = r.style,
              o = r._gsap;
            if (e in Dn && s) {
              if (((this.tfm = this.tfm || {}), "transform" === e))
                return Vn.transform.split(",").forEach(function (e) {
                  return t.call(i, e, n);
                });
              if (
                (~(e = Vn[e] || e).indexOf(",")
                  ? e.split(",").forEach(function (t) {
                      return (i.tfm[t] = bi(r, t));
                    })
                  : (this.tfm[e] = o.x ? o[e] : bi(r, e)),
                e === ni && (this.tfm.zOrigin = o.zOrigin),
                this.props.indexOf(ei) >= 0)
              )
                return;
              o.svg &&
                ((this.svgo = r.getAttribute("data-svg-origin")),
                this.props.push(ni, n, "")),
                (e = ei);
            }
            (s || n) && this.props.push(e, n, s[e]);
          },
          ri = function (t) {
            t.translate &&
              (t.removeProperty("translate"),
              t.removeProperty("scale"),
              t.removeProperty("rotate"));
          },
          si = function () {
            var t,
              e,
              n = this.props,
              i = this.target,
              r = i.style,
              s = i._gsap;
            for (t = 0; t < n.length; t += 3)
              n[t + 1]
                ? (i[n[t]] = n[t + 2])
                : n[t + 2]
                ? (r[n[t]] = n[t + 2])
                : r.removeProperty(
                    "--" === n[t].substr(0, 2)
                      ? n[t]
                      : n[t].replace(Bn, "-$1").toLowerCase()
                  );
            if (this.tfm) {
              for (e in this.tfm) s[e] = this.tfm[e];
              s.svg &&
                (s.renderTransform(),
                i.setAttribute("data-svg-origin", this.svgo || "")),
                ((t = In()) && t.isStart) ||
                  r[ei] ||
                  (ri(r),
                  s.zOrigin &&
                    r[ni] &&
                    ((r[ni] += " " + s.zOrigin + "px"),
                    (s.zOrigin = 0),
                    s.renderTransform()),
                  (s.uncache = 1));
            }
          },
          oi = function (t, e) {
            var n = {
              target: t,
              props: [],
              revert: si,
              save: ii,
            };
            return (
              t._gsap || Tn.core.getCache(t),
              e &&
                e.split(",").forEach(function (t) {
                  return n.save(t);
                }),
              n
            );
          },
          ai = function (t, e) {
            var n = Rn.createElementNS
              ? Rn.createElementNS(
                  (e || "http://www.w3.org/1999/xhtml").replace(
                    /^https/,
                    "http"
                  ),
                  t
                )
              : Rn.createElement(t);
            return n && n.style ? n : Rn.createElement(t);
          },
          li = function t(e, n, i) {
            var r = getComputedStyle(e);
            return (
              r[n] ||
              r.getPropertyValue(n.replace(Bn, "-$1").toLowerCase()) ||
              r.getPropertyValue(n) ||
              (!i && t(e, ui(n) || n, 1)) ||
              ""
            );
          },
          ci = "O,Moz,ms,Ms,Webkit".split(","),
          ui = function (t, e, n) {
            var i = (e || Pn).style,
              r = 5;
            if (t in i && !n) return t;
            for (
              t = t.charAt(0).toUpperCase() + t.substr(1);
              r-- && !(ci[r] + t in i);

            );
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ci[r] : "") + t;
          },
          hi = function () {
            "undefined" != typeof window &&
              window.document &&
              ((An = window),
              (Rn = An.document),
              (Cn = Rn.documentElement),
              (Pn = ai("div") || {
                style: {},
              }),
              ai("div"),
              (ei = ui(ei)),
              (ni = ei + "Origin"),
              (Pn.style.cssText =
                "border-width:0;line-height:0;position:absolute;padding:0"),
              (Nn = !!ui("perspective")),
              (In = Tn.core.reverting),
              (Ln = 1));
          },
          di = function t(e) {
            var n,
              i = ai(
                "svg",
                (this.ownerSVGElement &&
                  this.ownerSVGElement.getAttribute("xmlns")) ||
                  "http://www.w3.org/2000/svg"
              ),
              r = this.parentNode,
              s = this.nextSibling,
              o = this.style.cssText;
            if (
              (Cn.appendChild(i),
              i.appendChild(this),
              (this.style.display = "block"),
              e)
            )
              try {
                (n = this.getBBox()),
                  (this._gsapBBox = this.getBBox),
                  (this.getBBox = t);
              } catch (t) {}
            else this._gsapBBox && (n = this._gsapBBox());
            return (
              r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
              Cn.removeChild(i),
              (this.style.cssText = o),
              n
            );
          },
          pi = function (t, e) {
            for (var n = e.length; n--; )
              if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
          },
          fi = function (t) {
            var e;
            try {
              e = t.getBBox();
            } catch (n) {
              e = di.call(t, !0);
            }
            return (
              (e && (e.width || e.height)) ||
                t.getBBox === di ||
                (e = di.call(t, !0)),
              !e || e.width || e.x || e.y
                ? e
                : {
                    x: +pi(t, ["x", "cx", "x1"]) || 0,
                    y: +pi(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0,
                  }
            );
          },
          mi = function (t) {
            return !(
              !t.getCTM ||
              (t.parentNode && !t.ownerSVGElement) ||
              !fi(t)
            );
          },
          gi = function (t, e) {
            if (e) {
              var n,
                i = t.style;
              e in Dn && e !== ni && (e = ei),
                i.removeProperty
                  ? (("ms" !== (n = e.substr(0, 2)) &&
                      "webkit" !== e.substr(0, 6)) ||
                      (e = "-" + e),
                    i.removeProperty(
                      "--" === n ? e : e.replace(Bn, "-$1").toLowerCase()
                    ))
                  : i.removeAttribute(e);
            }
          },
          vi = function (t, e, n, i, r, s) {
            var o = new pn(t._pt, e, n, 0, 1, s ? Yn : Xn);
            return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o;
          },
          yi = {
            deg: 1,
            rad: 1,
            turn: 1,
          },
          _i = {
            grid: 1,
            flex: 1,
          },
          xi = function t(e, n, i, r) {
            var s,
              o,
              a,
              l,
              c = parseFloat(i) || 0,
              u = (i + "").trim().substr((c + "").length) || "px",
              h = Pn.style,
              d = zn.test(n),
              p = "svg" === e.tagName.toLowerCase(),
              f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
              m = 100,
              g = "px" === r,
              v = "%" === r;
            if (r === u || !c || yi[r] || yi[u]) return c;
            if (
              ("px" !== u && !g && (c = t(e, n, i, "px")),
              (l = e.getCTM && mi(e)),
              (v || "%" === u) && (Dn[n] || ~n.indexOf("adius")))
            )
              return (
                (s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
                mt(v ? (c / s) * m : (c / 100) * s)
              );
            if (
              ((h[d ? "width" : "height"] = m + (g ? u : r)),
              (o =
                ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
                  ? e
                  : e.parentNode),
              l && (o = (e.ownerSVGElement || {}).parentNode),
              (o && o !== Rn && o.appendChild) || (o = Rn.body),
              (a = o._gsap) &&
                v &&
                a.width &&
                d &&
                a.time === Te.time &&
                !a.uncache)
            )
              return mt((c / a.width) * m);
            if (!v || ("height" !== n && "width" !== n))
              (v || "%" === u) &&
                !_i[li(o, "display")] &&
                (h.position = li(e, "position")),
                o === e && (h.position = "static"),
                o.appendChild(Pn),
                (s = Pn[f]),
                o.removeChild(Pn),
                (h.position = "absolute");
            else {
              var y = e.style[n];
              (e.style[n] = m + r), (s = e[f]), y ? (e.style[n] = y) : gi(e, n);
            }
            return (
              d && v && (((a = dt(o)).time = Te.time), (a.width = o[f])),
              mt(g ? (s * c) / m : s && c ? (m / s) * c : 0)
            );
          },
          bi = function (t, e, n, i) {
            var r;
            return (
              Ln || hi(),
              e in Vn &&
                "transform" !== e &&
                ~(e = Vn[e]).indexOf(",") &&
                (e = e.split(",")[0]),
              Dn[e] && "transform" !== e
                ? ((r = Oi(t, i)),
                  (r =
                    "transformOrigin" !== e
                      ? r[e]
                      : r.svg
                      ? r.origin
                      : Ii(li(t, ni)) + " " + r.zOrigin + "px"))
                : (!(r = t.style[e]) ||
                    "auto" === r ||
                    i ||
                    ~(r + "").indexOf("calc(")) &&
                  (r =
                    (Mi[e] && Mi[e](t, e, n)) ||
                    li(t, e) ||
                    pt(t, e) ||
                    ("opacity" === e ? 1 : 0)),
              n && !~(r + "").trim().indexOf(" ") ? xi(t, e, r, n) + n : r
            );
          },
          wi = function (t, e, n, i) {
            if (!n || "none" === n) {
              var r = ui(e, t, 1),
                s = r && li(t, r, 1);
              s && s !== n
                ? ((e = r), (n = s))
                : "borderColor" === e && (n = li(t, "borderTopColor"));
            }
            var o,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              v = new pn(this._pt, t.style, e, 0, 1, an),
              y = 0,
              _ = 0;
            if (
              ((v.b = n),
              (v.e = i),
              (n += ""),
              "auto" === (i += "") &&
                ((h = t.style[e]),
                (t.style[e] = i),
                (i = li(t, e) || i),
                h ? (t.style[e] = h) : gi(t, e)),
              Me((o = [n, i])),
              (i = o[1]),
              (l = (n = o[0]).match(V) || []),
              (i.match(V) || []).length)
            ) {
              for (; (a = V.exec(i)); )
                (d = a[0]),
                  (f = i.substring(y, a.index)),
                  u
                    ? (u = (u + 1) % 5)
                    : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                      (u = 1),
                  d !== (h = l[_++] || "") &&
                    ((c = parseFloat(h) || 0),
                    (g = h.substr((c + "").length)),
                    "=" === d.charAt(1) && (d = vt(c, d) + g),
                    (p = parseFloat(d)),
                    (m = d.substr((p + "").length)),
                    (y = V.lastIndex - m.length),
                    m ||
                      ((m = m || x.units[e] || g),
                      y === i.length && ((i += m), (v.e += m))),
                    g !== m && (c = xi(t, e, h, m) || 0),
                    (v._pt = {
                      _next: v._pt,
                      p: f || 1 === _ ? f : ",",
                      s: c,
                      c: p - c,
                      m: (u && u < 4) || "zIndex" === e ? Math.round : 0,
                    }));
              v.c = y < i.length ? i.substring(y, i.length) : "";
            } else v.r = "display" === e && "none" === i ? Yn : Xn;
            return W.test(i) && (v.e = 0), (this._pt = v), v;
          },
          Ei = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%",
          },
          Si = function (t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
              var n,
                i,
                r,
                s = e.t,
                o = s.style,
                a = e.u,
                l = s._gsap;
              if ("all" === a || !0 === a) (o.cssText = ""), (i = 1);
              else
                for (r = (a = a.split(",")).length; --r > -1; )
                  (n = a[r]),
                    Dn[n] && ((i = 1), (n = "transformOrigin" === n ? ni : ei)),
                    gi(s, n);
              i &&
                (gi(s, ei),
                l &&
                  (l.svg && s.removeAttribute("transform"),
                  Oi(s, 1),
                  (l.uncache = 1),
                  ri(o)));
            }
          },
          Mi = {
            clearProps: function (t, e, n, i, r) {
              if ("isFromStart" !== r.data) {
                var s = (t._pt = new pn(t._pt, e, n, 0, 0, Si));
                return (
                  (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1
                );
              }
            },
          },
          Ti = [1, 0, 0, 1, 0, 0],
          Ai = {},
          Ri = function (t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
          },
          Ci = function (t) {
            var e = li(t, ei);
            return Ri(e) ? Ti : e.substr(7).match(H).map(mt);
          },
          Li = function (t, e) {
            var n,
              i,
              r,
              s,
              o = t._gsap || dt(t),
              a = t.style,
              l = Ci(t);
            return o.svg && t.getAttribute("transform")
              ? "1,0,0,1,0,0" ===
                (l = [
                  (r = t.transform.baseVal.consolidate().matrix).a,
                  r.b,
                  r.c,
                  r.d,
                  r.e,
                  r.f,
                ]).join(",")
                ? Ti
                : l
              : (l !== Ti ||
                  t.offsetParent ||
                  t === Cn ||
                  o.svg ||
                  ((r = a.display),
                  (a.display = "block"),
                  ((n = t.parentNode) && t.offsetParent) ||
                    ((s = 1), (i = t.nextElementSibling), Cn.appendChild(t)),
                  (l = Ci(t)),
                  r ? (a.display = r) : gi(t, "display"),
                  s &&
                    (i
                      ? n.insertBefore(t, i)
                      : n
                      ? n.appendChild(t)
                      : Cn.removeChild(t))),
                e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
          },
          Pi = function (t, e, n, i, r, s) {
            var o,
              a,
              l,
              c = t._gsap,
              u = r || Li(t, !0),
              h = c.xOrigin || 0,
              d = c.yOrigin || 0,
              p = c.xOffset || 0,
              f = c.yOffset || 0,
              m = u[0],
              g = u[1],
              v = u[2],
              y = u[3],
              _ = u[4],
              x = u[5],
              b = e.split(" "),
              w = parseFloat(b[0]) || 0,
              E = parseFloat(b[1]) || 0;
            n
              ? u !== Ti &&
                (a = m * y - g * v) &&
                ((l = w * (-g / a) + E * (m / a) - (m * x - g * _) / a),
                (w = w * (y / a) + E * (-v / a) + (v * x - y * _) / a),
                (E = l))
              : ((w =
                  (o = fi(t)).x +
                  (~b[0].indexOf("%") ? (w / 100) * o.width : w)),
                (E =
                  o.y +
                  (~(b[1] || b[0]).indexOf("%") ? (E / 100) * o.height : E))),
              i || (!1 !== i && c.smooth)
                ? ((_ = w - h),
                  (x = E - d),
                  (c.xOffset = p + (_ * m + x * v) - _),
                  (c.yOffset = f + (_ * g + x * y) - x))
                : (c.xOffset = c.yOffset = 0),
              (c.xOrigin = w),
              (c.yOrigin = E),
              (c.smooth = !!i),
              (c.origin = e),
              (c.originIsAbsolute = !!n),
              (t.style[ni] = "0px 0px"),
              s &&
                (vi(s, c, "xOrigin", h, w),
                vi(s, c, "yOrigin", d, E),
                vi(s, c, "xOffset", p, c.xOffset),
                vi(s, c, "yOffset", f, c.yOffset)),
              t.setAttribute("data-svg-origin", w + " " + E);
          },
          Oi = function (t, e) {
            var n = t._gsap || new Be(t);
            if ("x" in n && !e && !n.uncache) return n;
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              _,
              b,
              w,
              E,
              S,
              M,
              T,
              A,
              R,
              C,
              L,
              P,
              O,
              I,
              N,
              D,
              U = t.style,
              F = n.scaleX < 0,
              k = "px",
              B = "deg",
              z = getComputedStyle(t),
              H = li(t, ni) || "0";
            return (
              (i = r = s = l = c = u = h = d = p = 0),
              (o = a = 1),
              (n.svg = !(!t.getCTM || !mi(t))),
              z.translate &&
                (("none" === z.translate &&
                  "none" === z.scale &&
                  "none" === z.rotate) ||
                  (U[ei] =
                    ("none" !== z.translate
                      ? "translate3d(" +
                        (z.translate + " 0 0")
                          .split(" ")
                          .slice(0, 3)
                          .join(", ") +
                        ") "
                      : "") +
                    ("none" !== z.rotate ? "rotate(" + z.rotate + ") " : "") +
                    ("none" !== z.scale
                      ? "scale(" + z.scale.split(" ").join(",") + ") "
                      : "") +
                    ("none" !== z[ei] ? z[ei] : "")),
                (U.scale = U.rotate = U.translate = "none")),
              (g = Li(t, n.svg)),
              n.svg &&
                (n.uncache
                  ? ((R = t.getBBox()),
                    (H = n.xOrigin - R.x + "px " + (n.yOrigin - R.y) + "px"),
                    (A = ""))
                  : (A = !e && t.getAttribute("data-svg-origin")),
                Pi(t, A || H, !!A || n.originIsAbsolute, !1 !== n.smooth, g)),
              (f = n.xOrigin || 0),
              (m = n.yOrigin || 0),
              g !== Ti &&
                ((b = g[0]),
                (w = g[1]),
                (E = g[2]),
                (S = g[3]),
                (i = M = g[4]),
                (r = T = g[5]),
                6 === g.length
                  ? ((o = Math.sqrt(b * b + w * w)),
                    (a = Math.sqrt(S * S + E * E)),
                    (l = b || w ? kn(w, b) * Un : 0),
                    (h = E || S ? kn(E, S) * Un + l : 0) &&
                      (a *= Math.abs(Math.cos(h * Fn))),
                    n.svg &&
                      ((i -= f - (f * b + m * E)), (r -= m - (f * w + m * S))))
                  : ((D = g[6]),
                    (I = g[7]),
                    (L = g[8]),
                    (P = g[9]),
                    (O = g[10]),
                    (N = g[11]),
                    (i = g[12]),
                    (r = g[13]),
                    (s = g[14]),
                    (c = (v = kn(D, O)) * Un),
                    v &&
                      ((A = M * (y = Math.cos(-v)) + L * (_ = Math.sin(-v))),
                      (R = T * y + P * _),
                      (C = D * y + O * _),
                      (L = M * -_ + L * y),
                      (P = T * -_ + P * y),
                      (O = D * -_ + O * y),
                      (N = I * -_ + N * y),
                      (M = A),
                      (T = R),
                      (D = C)),
                    (u = (v = kn(-E, O)) * Un),
                    v &&
                      ((y = Math.cos(-v)),
                      (N = S * (_ = Math.sin(-v)) + N * y),
                      (b = A = b * y - L * _),
                      (w = R = w * y - P * _),
                      (E = C = E * y - O * _)),
                    (l = (v = kn(w, b)) * Un),
                    v &&
                      ((A = b * (y = Math.cos(v)) + w * (_ = Math.sin(v))),
                      (R = M * y + T * _),
                      (w = w * y - b * _),
                      (T = T * y - M * _),
                      (b = A),
                      (M = R)),
                    c &&
                      Math.abs(c) + Math.abs(l) > 359.9 &&
                      ((c = l = 0), (u = 180 - u)),
                    (o = mt(Math.sqrt(b * b + w * w + E * E))),
                    (a = mt(Math.sqrt(T * T + D * D))),
                    (v = kn(M, T)),
                    (h = Math.abs(v) > 2e-4 ? v * Un : 0),
                    (p = N ? 1 / (N < 0 ? -N : N) : 0)),
                n.svg &&
                  ((A = t.getAttribute("transform")),
                  (n.forceCSS =
                    t.setAttribute("transform", "") || !Ri(li(t, ei))),
                  A && t.setAttribute("transform", A))),
              Math.abs(h) > 90 &&
                Math.abs(h) < 270 &&
                (F
                  ? ((o *= -1),
                    (h += l <= 0 ? 180 : -180),
                    (l += l <= 0 ? 180 : -180))
                  : ((a *= -1), (h += h <= 0 ? 180 : -180))),
              (e = e || n.uncache),
              (n.x =
                i -
                ((n.xPercent =
                  i &&
                  ((!e && n.xPercent) ||
                    (Math.round(t.offsetWidth / 2) === Math.round(-i)
                      ? -50
                      : 0)))
                  ? (t.offsetWidth * n.xPercent) / 100
                  : 0) +
                k),
              (n.y =
                r -
                ((n.yPercent =
                  r &&
                  ((!e && n.yPercent) ||
                    (Math.round(t.offsetHeight / 2) === Math.round(-r)
                      ? -50
                      : 0)))
                  ? (t.offsetHeight * n.yPercent) / 100
                  : 0) +
                k),
              (n.z = s + k),
              (n.scaleX = mt(o)),
              (n.scaleY = mt(a)),
              (n.rotation = mt(l) + B),
              (n.rotationX = mt(c) + B),
              (n.rotationY = mt(u) + B),
              (n.skewX = h + B),
              (n.skewY = d + B),
              (n.transformPerspective = p + k),
              (n.zOrigin =
                parseFloat(H.split(" ")[2]) || (!e && n.zOrigin) || 0) &&
                (U[ni] = Ii(H)),
              (n.xOffset = n.yOffset = 0),
              (n.force3D = x.force3D),
              (n.renderTransform = n.svg ? zi : Nn ? Bi : Di),
              (n.uncache = 0),
              n
            );
          },
          Ii = function (t) {
            return (t = t.split(" "))[0] + " " + t[1];
          },
          Ni = function (t, e, n) {
            var i = Jt(e);
            return mt(parseFloat(e) + parseFloat(xi(t, "x", n + "px", i))) + i;
          },
          Di = function (t, e) {
            (e.z = "0px"),
              (e.rotationY = e.rotationX = "0deg"),
              (e.force3D = 0),
              Bi(t, e);
          },
          Ui = "0deg",
          Fi = "0px",
          ki = ") ",
          Bi = function (t, e) {
            var n = e || this,
              i = n.xPercent,
              r = n.yPercent,
              s = n.x,
              o = n.y,
              a = n.z,
              l = n.rotation,
              c = n.rotationY,
              u = n.rotationX,
              h = n.skewX,
              d = n.skewY,
              p = n.scaleX,
              f = n.scaleY,
              m = n.transformPerspective,
              g = n.force3D,
              v = n.target,
              y = n.zOrigin,
              _ = "",
              x = ("auto" === g && t && 1 !== t) || !0 === g;
            if (y && (u !== Ui || c !== Ui)) {
              var b,
                w = parseFloat(c) * Fn,
                E = Math.sin(w),
                S = Math.cos(w);
              (w = parseFloat(u) * Fn),
                (b = Math.cos(w)),
                (s = Ni(v, s, E * b * -y)),
                (o = Ni(v, o, -Math.sin(w) * -y)),
                (a = Ni(v, a, S * b * -y + y));
            }
            m !== Fi && (_ += "perspective(" + m + ki),
              (i || r) && (_ += "translate(" + i + "%, " + r + "%) "),
              (x || s !== Fi || o !== Fi || a !== Fi) &&
                (_ +=
                  a !== Fi || x
                    ? "translate3d(" + s + ", " + o + ", " + a + ") "
                    : "translate(" + s + ", " + o + ki),
              l !== Ui && (_ += "rotate(" + l + ki),
              c !== Ui && (_ += "rotateY(" + c + ki),
              u !== Ui && (_ += "rotateX(" + u + ki),
              (h === Ui && d === Ui) || (_ += "skew(" + h + ", " + d + ki),
              (1 === p && 1 === f) || (_ += "scale(" + p + ", " + f + ki),
              (v.style[ei] = _ || "translate(0, 0)");
          },
          zi = function (t, e) {
            var n,
              i,
              r,
              s,
              o,
              a = e || this,
              l = a.xPercent,
              c = a.yPercent,
              u = a.x,
              h = a.y,
              d = a.rotation,
              p = a.skewX,
              f = a.skewY,
              m = a.scaleX,
              g = a.scaleY,
              v = a.target,
              y = a.xOrigin,
              _ = a.yOrigin,
              x = a.xOffset,
              b = a.yOffset,
              w = a.forceCSS,
              E = parseFloat(u),
              S = parseFloat(h);
            (d = parseFloat(d)),
              (p = parseFloat(p)),
              (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
              d || p
                ? ((d *= Fn),
                  (p *= Fn),
                  (n = Math.cos(d) * m),
                  (i = Math.sin(d) * m),
                  (r = Math.sin(d - p) * -g),
                  (s = Math.cos(d - p) * g),
                  p &&
                    ((f *= Fn),
                    (o = Math.tan(p - f)),
                    (r *= o = Math.sqrt(1 + o * o)),
                    (s *= o),
                    f &&
                      ((o = Math.tan(f)),
                      (n *= o = Math.sqrt(1 + o * o)),
                      (i *= o))),
                  (n = mt(n)),
                  (i = mt(i)),
                  (r = mt(r)),
                  (s = mt(s)))
                : ((n = m), (s = g), (i = r = 0)),
              ((E && !~(u + "").indexOf("px")) ||
                (S && !~(h + "").indexOf("px"))) &&
                ((E = xi(v, "x", u, "px")), (S = xi(v, "y", h, "px"))),
              (y || _ || x || b) &&
                ((E = mt(E + y - (y * n + _ * r) + x)),
                (S = mt(S + _ - (y * i + _ * s) + b))),
              (l || c) &&
                ((o = v.getBBox()),
                (E = mt(E + (l / 100) * o.width)),
                (S = mt(S + (c / 100) * o.height))),
              (o =
                "matrix(" +
                n +
                "," +
                i +
                "," +
                r +
                "," +
                s +
                "," +
                E +
                "," +
                S +
                ")"),
              v.setAttribute("transform", o),
              w && (v.style[ei] = o);
          },
          Hi = function (t, e, n, i, r) {
            var s,
              o,
              a = 360,
              l = L(r),
              c = parseFloat(r) * (l && ~r.indexOf("rad") ? Un : 1) - i,
              u = i + c + "deg";
            return (
              l &&
                ("short" === (s = r.split("_")[1]) &&
                  (c %= a) !== c % 180 &&
                  (c += c < 0 ? a : -360),
                "cw" === s && c < 0
                  ? (c = ((c + 36e9) % a) - ~~(c / a) * a)
                  : "ccw" === s &&
                    c > 0 &&
                    (c = ((c - 36e9) % a) - ~~(c / a) * a)),
              (t._pt = o = new pn(t._pt, e, n, i, c, Wn)),
              (o.e = u),
              (o.u = "deg"),
              t._props.push(n),
              o
            );
          },
          Vi = function (t, e) {
            for (var n in e) t[n] = e[n];
            return t;
          },
          Gi = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u = Vi({}, n._gsap),
              h = n.style;
            for (r in (u.svg
              ? ((s = n.getAttribute("transform")),
                n.setAttribute("transform", ""),
                (h[ei] = e),
                (i = Oi(n, 1)),
                gi(n, ei),
                n.setAttribute("transform", s))
              : ((s = getComputedStyle(n)[ei]),
                (h[ei] = e),
                (i = Oi(n, 1)),
                (h[ei] = s)),
            Dn))
              (s = u[r]) !== (o = i[r]) &&
                "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) <
                  0 &&
                ((a = Jt(s) !== (c = Jt(o)) ? xi(n, r, s, c) : parseFloat(s)),
                (l = parseFloat(o)),
                (t._pt = new pn(t._pt, i, r, a, l - a, Gn)),
                (t._pt.u = c || 0),
                t._props.push(r));
            Vi(i, u);
          };
        ft("padding,margin,Width,Radius", function (t, e) {
          var n = "Top",
            i = "Right",
            r = "Bottom",
            s = "Left",
            o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(
              function (n) {
                return e < 2 ? t + n : "border" + n + t;
              }
            );
          Mi[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
            var s, a;
            if (arguments.length < 4)
              return (
                (s = o.map(function (e) {
                  return bi(t, e, n);
                })),
                5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a
              );
            (s = (i + "").split(" ")),
              (a = {}),
              o.forEach(function (t, e) {
                return (a[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
              }),
              t.init(e, a, r);
          };
        });
        var Wi,
          ji,
          qi,
          Xi = {
            name: "css",
            register: hi,
            targetTest: function (t) {
              return t.style && t.nodeType;
            },
            init: function (t, e, n, i, r) {
              var s,
                o,
                a,
                l,
                c,
                u,
                h,
                d,
                p,
                f,
                m,
                g,
                v,
                y,
                _,
                b,
                w,
                E,
                S,
                M,
                T = this._props,
                A = t.style,
                R = n.vars.startAt;
              for (h in (Ln || hi(),
              (this.styles = this.styles || oi(t)),
              (b = this.styles.props),
              (this.tween = n),
              e))
                if (
                  "autoRound" !== h &&
                  ((o = e[h]), !ot[h] || !qe(h, e, n, i, t, r))
                )
                  if (
                    ((c = typeof o),
                    (u = Mi[h]),
                    "function" === c && (c = typeof (o = o.call(n, i, t, r))),
                    "string" === c && ~o.indexOf("random(") && (o = ue(o)),
                    u)
                  )
                    u(this, t, h, o, n) && (_ = 1);
                  else if ("--" === h.substr(0, 2))
                    (s = (getComputedStyle(t).getPropertyValue(h) + "").trim()),
                      (o += ""),
                      (Ee.lastIndex = 0),
                      Ee.test(s) || ((d = Jt(s)), (p = Jt(o))),
                      p ? d !== p && (s = xi(t, h, s, p) + p) : d && (o += d),
                      this.add(A, "setProperty", s, o, i, r, 0, 0, h),
                      T.push(h),
                      b.push(h, 0, A[h]);
                  else if ("undefined" !== c) {
                    if (
                      (R && h in R
                        ? ((s =
                            "function" == typeof R[h]
                              ? R[h].call(n, i, t, r)
                              : R[h]),
                          L(s) && ~s.indexOf("random(") && (s = ue(s)),
                          Jt(s + "") ||
                            "auto" === s ||
                            (s += x.units[h] || Jt(bi(t, h)) || ""),
                          "=" === (s + "").charAt(1) && (s = bi(t, h)))
                        : (s = bi(t, h)),
                      (l = parseFloat(s)),
                      (f =
                        "string" === c &&
                        "=" === o.charAt(1) &&
                        o.substr(0, 2)) && (o = o.substr(2)),
                      (a = parseFloat(o)),
                      h in Vn &&
                        ("autoAlpha" === h &&
                          (1 === l &&
                            "hidden" === bi(t, "visibility") &&
                            a &&
                            (l = 0),
                          b.push("visibility", 0, A.visibility),
                          vi(
                            this,
                            A,
                            "visibility",
                            l ? "inherit" : "hidden",
                            a ? "inherit" : "hidden",
                            !a
                          )),
                        "scale" !== h &&
                          "transform" !== h &&
                          ~(h = Vn[h]).indexOf(",") &&
                          (h = h.split(",")[0])),
                      (m = h in Dn))
                    )
                      if (
                        (this.styles.save(h),
                        g ||
                          (((v = t._gsap).renderTransform &&
                            !e.parseTransform) ||
                            Oi(t, e.parseTransform),
                          (y = !1 !== e.smoothOrigin && v.smooth),
                          ((g = this._pt =
                            new pn(
                              this._pt,
                              A,
                              ei,
                              0,
                              1,
                              v.renderTransform,
                              v,
                              0,
                              -1
                            )).dep = 1)),
                        "scale" === h)
                      )
                        (this._pt = new pn(
                          this._pt,
                          v,
                          "scaleY",
                          v.scaleY,
                          (f ? vt(v.scaleY, f + a) : a) - v.scaleY || 0,
                          Gn
                        )),
                          (this._pt.u = 0),
                          T.push("scaleY", h),
                          (h += "X");
                      else {
                        if ("transformOrigin" === h) {
                          b.push(ni, 0, A[ni]),
                            (E = void 0),
                            (S = void 0),
                            (M = void 0),
                            (E = (w = o).split(" ")),
                            (S = E[0]),
                            (M = E[1] || "50%"),
                            ("top" !== S &&
                              "bottom" !== S &&
                              "left" !== M &&
                              "right" !== M) ||
                              ((w = S), (S = M), (M = w)),
                            (E[0] = Ei[S] || S),
                            (E[1] = Ei[M] || M),
                            (o = E.join(" ")),
                            v.svg
                              ? Pi(t, o, 0, y, 0, this)
                              : ((p = parseFloat(o.split(" ")[2]) || 0) !==
                                  v.zOrigin &&
                                  vi(this, v, "zOrigin", v.zOrigin, p),
                                vi(this, A, h, Ii(s), Ii(o)));
                          continue;
                        }
                        if ("svgOrigin" === h) {
                          Pi(t, o, 1, y, 0, this);
                          continue;
                        }
                        if (h in Ai) {
                          Hi(this, v, h, l, f ? vt(l, f + o) : o);
                          continue;
                        }
                        if ("smoothOrigin" === h) {
                          vi(this, v, "smooth", v.smooth, o);
                          continue;
                        }
                        if ("force3D" === h) {
                          v[h] = o;
                          continue;
                        }
                        if ("transform" === h) {
                          Gi(this, o, t);
                          continue;
                        }
                      }
                    else h in A || (h = ui(h) || h);
                    if (
                      m ||
                      ((a || 0 === a) &&
                        (l || 0 === l) &&
                        !Hn.test(o) &&
                        h in A)
                    )
                      a || (a = 0),
                        (d = (s + "").substr((l + "").length)) !==
                          (p = Jt(o) || (h in x.units ? x.units[h] : d)) &&
                          (l = xi(t, h, s, p)),
                        (this._pt = new pn(
                          this._pt,
                          m ? v : A,
                          h,
                          l,
                          (f ? vt(l, f + a) : a) - l,
                          m ||
                          ("px" !== p && "zIndex" !== h) ||
                          !1 === e.autoRound
                            ? Gn
                            : qn
                        )),
                        (this._pt.u = p || 0),
                        d !== p &&
                          "%" !== p &&
                          ((this._pt.b = s), (this._pt.r = jn));
                    else if (h in A) wi.call(this, t, h, s, f ? f + o : o);
                    else if (h in t)
                      this.add(t, h, s || t[h], f ? f + o : o, i, r);
                    else if ("parseTransform" !== h) {
                      $(h, o);
                      continue;
                    }
                    m ||
                      (h in A ? b.push(h, 0, A[h]) : b.push(h, 1, s || t[h])),
                      T.push(h);
                  }
              _ && dn(this);
            },
            render: function (t, e) {
              if (e.tween._time || !In())
                for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
              else e.styles.revert();
            },
            get: bi,
            aliases: Vn,
            getSetter: function (t, e, n) {
              var i = Vn[e];
              return (
                i && i.indexOf(",") < 0 && (e = i),
                e in Dn && e !== ni && (t._gsap.x || bi(t, "x"))
                  ? n && On === n
                    ? "scale" === e
                      ? Jn
                      : Zn
                    : (On = n || {}) && ("scale" === e ? Qn : ti)
                  : t.style && !I(t.style[e])
                  ? Kn
                  : ~e.indexOf("-")
                  ? $n
                  : rn(t, e)
              );
            },
            core: {
              _removeProperty: gi,
              _getMatrix: Li,
            },
          };
        (Tn.utils.checkPrefix = ui),
          (Tn.core.getStyleSaver = oi),
          (qi = ft(
            (Wi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") +
              "," +
              (ji = "rotation,rotationX,rotationY,skewX,skewY") +
              ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
            function (t) {
              Dn[t] = 1;
            }
          )),
          ft(ji, function (t) {
            (x.units[t] = "deg"), (Ai[t] = 1);
          }),
          (Vn[qi[13]] = Wi + "," + ji),
          ft(
            "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
            function (t) {
              var e = t.split(":");
              Vn[e[1]] = qi[e[0]];
            }
          ),
          ft(
            "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
            function (t) {
              x.units[t] = "px";
            }
          ),
          Tn.registerPlugin(Xi);
        var Yi = Tn.registerPlugin(Xi) || Tn;
        Yi.core.Tween;
        class Ki {
          constructor(t) {
            (this.tgt = t),
              (this.body = document.querySelector("body")),
              (this.world = document.getElementById("world")),
              (this.odometer = document.querySelector(".odometer")),
              (this.header = document.querySelector(".header-area")),
              (this.logo = document.querySelector(".logo-area")),
              (this.copy_detail = document.querySelector(".main-copy--detail")),
              (this.init_item1 = document.querySelectorAll(".anime-cp1--init")),
              (this.contact_cal = document.querySelector(
                ".contact-carousel-area"
              )),
              (this.lConfigMenu = document.querySelector(".lConfigMenu")),
              this.outputNum,
              (this.num = 0),
              (this.timeout_step1 = 500),
              (this.timeout_step2 = 2e3),
              (this.timeout_step3 = 5e3),
              (this.timeout_step4 = 9e3),
              (this.timeout_step5 = 11e3),
              (this.count_max_num = 100);
          }
          init() {
            return this.bind();
          }
          bind() {
            this.init();
          }
          init() {
            const t = this;
            setTimeout(() => {
              t.body.classList.add("load-init");
            }, 100),
              sessionStorage.getItem("access") || "/" != location.pathname
                ? (sessionStorage.setItem("access", 0),
                  (t.body.style.background = "none"),
                  "/" === location.pathname && (t.world.style.opacity = "1"),
                  setTimeout(() => {
                    t.header.classList.add("-in"),
                      t.logo.classList.add("-in"),
                      t.copy_detail && t.copy_detail.classList.add("-in"),
                      t.contact_cal.classList.add("-in"),
                      t.lConfigMenu.classList.add("-in"),
                      t.init_item1.forEach((t) => {
                        t.classList.add("-in");
                      });
                  }, t.timeout_step1))
                : (sessionStorage.setItem("access", 0),
                  t.loadingAction_step1());
          }
          loadingAction_step1() {
            const t = this;
            t.body.classList.add("is-loaded"),
              (this.promise = new Promise((e) => {
                (t.tgt.style.display = "flex"),
                  setTimeout(() => {
                    (t.tgt.style.opacity = "1"), e();
                  }, t.timeout_step1);
              })),
              t.promise.then(t.loadingAction_step2());
          }
          loadingAction_step2() {
            const t = this;
            (this.promise = new Promise((e) => {
              setTimeout(() => {
                (this.timerId = setInterval(() => {
                  t.num++,
                    (this.digits = t.num.toString().length),
                    t.num <= 100
                      ? (1 == this.digits
                          ? (t.outputNum = "00" + t.num)
                          : 2 == this.digits
                          ? (t.outputNum = "0" + t.num)
                          : (t.outputNum = t.num),
                        (t.odometer.innerHTML = t.outputNum))
                      : clearInterval(this.timerId);
                }, 35)),
                  t.tgt.classList.add("-in"),
                  e();
              }, t.timeout_step2);
            })),
              t.promise.then(t.loadingAction_step3());
          }
          loadingAction_step3() {
            const t = this;
            (this.promise = new Promise((e) => {
              setTimeout(() => {
                t.tgt.classList.add("-end"),
                  (t.body.style.background = "none"),
                  e();
              }, t.timeout_step3);
            })),
              t.promise.then(t.loadingAction_step4());
          }
          loadingAction_step4() {
            const t = this;
            (this.promise = new Promise((e) => {
              setTimeout(() => {
                (t.tgt.style.opacity = ""),
                  (t.world.style.opacity = "1"),
                  t.header.classList.add("-in"),
                  t.logo.classList.add("-in"),
                  t.copy_detail.classList.add("-in"),
                  t.contact_cal.classList.add("-in"),
                  t.lConfigMenu.classList.add("-in"),
                  t.init_item1.forEach((t) => {
                    t.classList.add("-in");
                  }),
                  e();
              }, t.timeout_step4);
            })),
              t.promise.then(t.loadingAction_step5());
          }
          loadingAction_step5() {
            const t = this;
            this.promise = new Promise((e) => {
              setTimeout(() => {
                t.body.classList.remove("is-loaded"),
                  (t.tgt.style.display = "none"),
                  e();
              }, t.timeout_step5);
            });
          }
        }
        class $i {
          constructor(t) {
            (this.tgt = t),
              (this.body = document.querySelector("body")),
              (this.header = document.querySelector("header")),
              (this.nav = document.querySelector("nav")),
              (this.links = document.querySelectorAll(
                "[data-js-inner-link] a"
              )),
              (this.positionPrev = 0),
              (this.buffer = 100),
              (this.scroll_buffer = 300),
              (this.timeout_start = 100),
              (this.timeout_end = 800),
              this.timer;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.toggleClass(), this.pageTranstion();
          }
          pageTranstion() {
            const t = this;
            t.links.forEach((e) => {
              e.addEventListener("click", () => {
                t.tgt.classList.remove("is-open"),
                  t.tgt.classList.add("is-disabled"),
                  t.body.classList.remove("is-disabled"),
                  t.header.classList.remove("is-open"),
                  (t.nav.style.opacity = ""),
                  t.tgt.classList.add("is-disabled"),
                  t.nav.classList.add("is-hide"),
                  setTimeout(() => {
                    (t.nav.style.display = ""),
                      t.tgt.classList.remove("is-disabled"),
                      t.nav.classList.remove("is-show", "is-hide");
                  }, t.timeout_end);
              });
            });
          }
          toggleClass() {
            const t = this;
            t.tgt.addEventListener("click", () => {
              t.tgt.classList.toggle("is-open"),
                t.tgt.classList.add("is-disabled"),
                t.body.classList.toggle("is-disabled"),
                t.header.classList.toggle("is-open"),
                t.tgt.classList.contains("is-open")
                  ? ((t.nav.style.display = "block"),
                    setTimeout(() => {
                      (t.nav.style.opacity = "1"),
                        t.nav.classList.add("is-show");
                    }, t.timeout_start),
                    setTimeout(() => {
                      t.tgt.classList.remove("is-disabled");
                    }, t.timeout_end))
                  : ((t.nav.style.opacity = ""),
                    t.tgt.classList.add("is-disabled"),
                    t.nav.classList.add("is-hide"),
                    setTimeout(() => {
                      (t.nav.style.display = ""),
                        t.tgt.classList.remove("is-disabled"),
                        t.nav.classList.remove("is-show", "is-hide");
                    }, t.timeout_end));
            });
          }
          toggleScrollVisibility() {
            const t = this;
            (this.scrollPos = window.scrollY),
              this.scrollPos > t.buffer &&
                !t.header.classList.contains("is-open") &&
                ((t.diff = this.scrollPos - t.positionPrev),
                t.diff > 0
                  ? t.header.classList.remove("-in")
                  : t.header.classList.add("-in"),
                (t.positionPrev = this.scrollPos));
          }
        }
        function Zi(t, e) {
          for (var n = 0; n < e.length; n++) {
            var i = e[n];
            (i.enumerable = i.enumerable || !1),
              (i.configurable = !0),
              "value" in i && (i.writable = !0),
              Object.defineProperty(t, i.key, i);
          }
        }
        /*!
         * Splide.js
         * Version  : 4.1.4
         * License  : MIT
         * Copyright: 2022 Naotoshi Fujita
         */
        var Ji = "(prefers-reduced-motion: reduce)",
          Qi = 4,
          tr = 5,
          er = {
            CREATED: 1,
            MOUNTED: 2,
            IDLE: 3,
            MOVING: Qi,
            SCROLLING: tr,
            DRAGGING: 6,
            DESTROYED: 7,
          };
        function nr(t) {
          t.length = 0;
        }
        function ir(t, e, n) {
          return Array.prototype.slice.call(t, e, n);
        }
        function rr(t) {
          return t.bind.apply(t, [null].concat(ir(arguments, 1)));
        }
        var sr = setTimeout,
          or = function () {};
        function ar(t) {
          return requestAnimationFrame(t);
        }
        function lr(t, e) {
          return typeof e === t;
        }
        function cr(t) {
          return !fr(t) && lr("object", t);
        }
        var ur = Array.isArray,
          hr = rr(lr, "function"),
          dr = rr(lr, "string"),
          pr = rr(lr, "undefined");
        function fr(t) {
          return null === t;
        }
        function mr(t) {
          try {
            return (
              t instanceof (t.ownerDocument.defaultView || window).HTMLElement
            );
          } catch (t) {
            return !1;
          }
        }
        function gr(t) {
          return ur(t) ? t : [t];
        }
        function vr(t, e) {
          gr(t).forEach(e);
        }
        function yr(t, e) {
          return t.indexOf(e) > -1;
        }
        function _r(t, e) {
          return t.push.apply(t, gr(e)), t;
        }
        function xr(t, e, n) {
          t &&
            vr(e, function (e) {
              e && t.classList[n ? "add" : "remove"](e);
            });
        }
        function br(t, e) {
          xr(t, dr(e) ? e.split(" ") : e, !0);
        }
        function wr(t, e) {
          vr(e, t.appendChild.bind(t));
        }
        function Er(t, e) {
          vr(t, function (t) {
            var n = (e || t).parentNode;
            n && n.insertBefore(t, e);
          });
        }
        function Sr(t, e) {
          return mr(t) && (t.msMatchesSelector || t.matches).call(t, e);
        }
        function Mr(t, e) {
          var n = t ? ir(t.children) : [];
          return e
            ? n.filter(function (t) {
                return Sr(t, e);
              })
            : n;
        }
        function Tr(t, e) {
          return e ? Mr(t, e)[0] : t.firstElementChild;
        }
        var Ar = Object.keys;
        function Rr(t, e, n) {
          return (
            t &&
              (n ? Ar(t).reverse() : Ar(t)).forEach(function (n) {
                "__proto__" !== n && e(t[n], n);
              }),
            t
          );
        }
        function Cr(t) {
          return (
            ir(arguments, 1).forEach(function (e) {
              Rr(e, function (n, i) {
                t[i] = e[i];
              });
            }),
            t
          );
        }
        function Lr(t) {
          return (
            ir(arguments, 1).forEach(function (e) {
              Rr(e, function (e, n) {
                ur(e)
                  ? (t[n] = e.slice())
                  : cr(e)
                  ? (t[n] = Lr({}, cr(t[n]) ? t[n] : {}, e))
                  : (t[n] = e);
              });
            }),
            t
          );
        }
        function Pr(t, e) {
          vr(e || Ar(t), function (e) {
            delete t[e];
          });
        }
        function Or(t, e) {
          vr(t, function (t) {
            vr(e, function (e) {
              t && t.removeAttribute(e);
            });
          });
        }
        function Ir(t, e, n) {
          cr(e)
            ? Rr(e, function (e, n) {
                Ir(t, n, e);
              })
            : vr(t, function (t) {
                fr(n) || "" === n ? Or(t, e) : t.setAttribute(e, String(n));
              });
        }
        function Nr(t, e, n) {
          var i = document.createElement(t);
          return e && (dr(e) ? br(i, e) : Ir(i, e)), n && wr(n, i), i;
        }
        function Dr(t, e, n) {
          if (pr(n)) return getComputedStyle(t)[e];
          fr(n) || (t.style[e] = "" + n);
        }
        function Ur(t, e) {
          Dr(t, "display", e);
        }
        function Fr(t) {
          (t.setActive && t.setActive()) ||
            t.focus({
              preventScroll: !0,
            });
        }
        function kr(t, e) {
          return t.getAttribute(e);
        }
        function Br(t, e) {
          return t && t.classList.contains(e);
        }
        function zr(t) {
          return t.getBoundingClientRect();
        }
        function Hr(t) {
          vr(t, function (t) {
            t && t.parentNode && t.parentNode.removeChild(t);
          });
        }
        function Vr(t) {
          return Tr(new DOMParser().parseFromString(t, "text/html").body);
        }
        function Gr(t, e) {
          t.preventDefault(),
            e && (t.stopPropagation(), t.stopImmediatePropagation());
        }
        function Wr(t, e) {
          return t && t.querySelector(e);
        }
        function jr(t, e) {
          return e ? ir(t.querySelectorAll(e)) : [];
        }
        function qr(t, e) {
          xr(t, e, !1);
        }
        function Xr(t) {
          return t.timeStamp;
        }
        function Yr(t) {
          return dr(t) ? t : t ? t + "px" : "";
        }
        var Kr = "splide",
          $r = "data-" + Kr;
        function Zr(t, e) {
          if (!t) throw new Error("[" + Kr + "] " + (e || ""));
        }
        var Jr = Math.min,
          Qr = Math.max,
          ts = Math.floor,
          es = Math.ceil,
          ns = Math.abs;
        function is(t, e, n) {
          return ns(t - e) < n;
        }
        function rs(t, e, n, i) {
          var r = Jr(e, n),
            s = Qr(e, n);
          return i ? r < t && t < s : r <= t && t <= s;
        }
        function ss(t, e, n) {
          var i = Jr(e, n),
            r = Qr(e, n);
          return Jr(Qr(i, t), r);
        }
        function os(t) {
          return +(t > 0) - +(t < 0);
        }
        function as(t, e) {
          return (
            vr(e, function (e) {
              t = t.replace("%s", "" + e);
            }),
            t
          );
        }
        function ls(t) {
          return t < 10 ? "0" + t : "" + t;
        }
        var cs = {};
        function us(t) {
          return "" + t + ls((cs[t] = (cs[t] || 0) + 1));
        }
        function hs() {
          var t = [];
          function e(t, e, n) {
            vr(t, function (t) {
              t &&
                vr(e, function (e) {
                  e.split(" ").forEach(function (e) {
                    var i = e.split(".");
                    n(t, i[0], i[1]);
                  });
                });
            });
          }
          return {
            bind: function (n, i, r, s) {
              e(n, i, function (e, n, i) {
                var o = "addEventListener" in e,
                  a = o
                    ? e.removeEventListener.bind(e, n, r, s)
                    : e.removeListener.bind(e, r);
                o ? e.addEventListener(n, r, s) : e.addListener(r),
                  t.push([e, n, i, r, a]);
              });
            },
            unbind: function (n, i, r) {
              e(n, i, function (e, n, i) {
                t = t.filter(function (t) {
                  return (
                    !!(
                      t[0] !== e ||
                      t[1] !== n ||
                      t[2] !== i ||
                      (r && t[3] !== r)
                    ) || (t[4](), !1)
                  );
                });
              });
            },
            dispatch: function (t, e, n) {
              var i,
                r = !0;
              return (
                "function" == typeof CustomEvent
                  ? (i = new CustomEvent(e, {
                      bubbles: r,
                      detail: n,
                    }))
                  : (i = document.createEvent("CustomEvent")).initCustomEvent(
                      e,
                      r,
                      !1,
                      n
                    ),
                t.dispatchEvent(i),
                i
              );
            },
            destroy: function () {
              t.forEach(function (t) {
                t[4]();
              }),
                nr(t);
            },
          };
        }
        var ds = "mounted",
          ps = "ready",
          fs = "move",
          ms = "moved",
          gs = "click",
          vs = "active",
          ys = "inactive",
          _s = "visible",
          xs = "hidden",
          bs = "refresh",
          ws = "updated",
          Es = "resize",
          Ss = "resized",
          Ms = "scroll",
          Ts = "scrolled",
          As = "destroy",
          Rs = "arrows:mounted",
          Cs = "navigation:mounted",
          Ls = "autoplay:play",
          Ps = "autoplay:pause",
          Os = "lazyload:loaded",
          Is = "sk",
          Ns = "sh",
          Ds = "ei";
        function Us(t) {
          var e = t ? t.event.bus : document.createDocumentFragment(),
            n = hs();
          return (
            t && t.event.on(As, n.destroy),
            Cr(n, {
              bus: e,
              on: function (t, i) {
                n.bind(e, gr(t).join(" "), function (t) {
                  i.apply(i, ur(t.detail) ? t.detail : []);
                });
              },
              off: rr(n.unbind, e),
              emit: function (t) {
                n.dispatch(e, t, ir(arguments, 1));
              },
            })
          );
        }
        function Fs(t, e, n, i) {
          var r,
            s,
            o = Date.now,
            a = 0,
            l = !0,
            c = 0;
          function u() {
            if (!l) {
              if (
                ((a = t ? Jr((o() - r) / t, 1) : 1),
                n && n(a),
                a >= 1 && (e(), (r = o()), i && ++c >= i))
              )
                return h();
              s = ar(u);
            }
          }
          function h() {
            l = !0;
          }
          function d() {
            s && cancelAnimationFrame(s), (a = 0), (s = 0), (l = !0);
          }
          return {
            start: function (e) {
              e || d(), (r = o() - (e ? a * t : 0)), (l = !1), (s = ar(u));
            },
            rewind: function () {
              (r = o()), (a = 0), n && n(a);
            },
            pause: h,
            cancel: d,
            set: function (e) {
              t = e;
            },
            isPaused: function () {
              return l;
            },
          };
        }
        var ks = "Arrow",
          Bs = ks + "Left",
          zs = ks + "Right",
          Hs = ks + "Up",
          Vs = ks + "Down",
          Gs = "ttb",
          Ws = {
            width: ["height"],
            left: ["top", "right"],
            right: ["bottom", "left"],
            x: ["y"],
            X: ["Y"],
            Y: ["X"],
            ArrowLeft: [Hs, zs],
            ArrowRight: [Vs, Bs],
          };
        function js(t, e, n) {
          return {
            resolve: function (t, e, i) {
              var r =
                "rtl" !== (i = i || n.direction) || e ? (i === Gs ? 0 : -1) : 1;
              return (
                (Ws[t] && Ws[t][r]) ||
                t.replace(/width|left|right/i, function (t, e) {
                  var n = Ws[t.toLowerCase()][r] || t;
                  return e > 0 ? n.charAt(0).toUpperCase() + n.slice(1) : n;
                })
              );
            },
            orient: function (t) {
              return t * ("rtl" === n.direction ? 1 : -1);
            },
          };
        }
        var qs = "role",
          Xs = "tabindex",
          Ys = "aria-",
          Ks = Ys + "controls",
          $s = Ys + "current",
          Zs = Ys + "selected",
          Js = Ys + "label",
          Qs = Ys + "labelledby",
          to = Ys + "hidden",
          eo = Ys + "orientation",
          no = Ys + "roledescription",
          io = Ys + "live",
          ro = Ys + "busy",
          so = Ys + "atomic",
          oo = [qs, Xs, "disabled", Ks, $s, Js, Qs, to, eo, no],
          ao = Kr + "__",
          lo = "is-",
          co = Kr,
          uo = ao + "track",
          ho = ao + "list",
          po = ao + "slide",
          fo = po + "--clone",
          mo = po + "__container",
          go = ao + "arrows",
          vo = ao + "arrow",
          yo = vo + "--prev",
          _o = vo + "--next",
          xo = ao + "pagination",
          bo = xo + "__page",
          wo = ao + "progress" + "__bar",
          Eo = ao + "toggle",
          So = ao + "sr",
          Mo = lo + "initialized",
          To = lo + "active",
          Ao = lo + "prev",
          Ro = lo + "next",
          Co = lo + "visible",
          Lo = lo + "loading",
          Po = lo + "focus-in",
          Oo = lo + "overflow",
          Io = [To, Co, Ao, Ro, Lo, Po, Oo],
          No = {
            slide: po,
            clone: fo,
            arrows: go,
            arrow: vo,
            prev: yo,
            next: _o,
            pagination: xo,
            page: bo,
            spinner: ao + "spinner",
          };
        var Do = "touchstart mousedown",
          Uo = "touchmove mousemove",
          Fo = "touchend touchcancel mouseup click";
        var ko = "slide",
          Bo = "loop",
          zo = "fade";
        function Ho(t, e, n, i) {
          var r,
            s = Us(t),
            o = s.on,
            a = s.emit,
            l = s.bind,
            c = t.Components,
            u = t.root,
            h = t.options,
            d = h.isNavigation,
            p = h.updateOnMove,
            f = h.i18n,
            m = h.pagination,
            g = h.slideFocus,
            v = c.Direction.resolve,
            y = kr(i, "style"),
            _ = kr(i, Js),
            x = n > -1,
            b = Tr(i, "." + mo);
          function w() {
            var r = t.splides
              .map(function (t) {
                var n = t.splide.Components.Slides.getAt(e);
                return n ? n.slide.id : "";
              })
              .join(" ");
            Ir(i, Js, as(f.slideX, (x ? n : e) + 1)),
              Ir(i, Ks, r),
              Ir(i, qs, g ? "button" : ""),
              g && Or(i, no);
          }
          function E() {
            r || S();
          }
          function S() {
            if (!r) {
              var n = t.index;
              (s = M()) !== Br(i, To) &&
                (xr(i, To, s), Ir(i, $s, (d && s) || ""), a(s ? vs : ys, T)),
                (function () {
                  var e = (function () {
                      if (t.is(zo)) return M();
                      var e = zr(c.Elements.track),
                        n = zr(i),
                        r = v("left", !0),
                        s = v("right", !0);
                      return ts(e[r]) <= es(n[r]) && ts(n[s]) <= es(e[s]);
                    })(),
                    n = !e && (!M() || x);
                  t.state.is([Qi, tr]) || Ir(i, to, n || "");
                  Ir(jr(i, h.focusableNodes || ""), Xs, n ? -1 : ""),
                    g && Ir(i, Xs, n ? -1 : 0);
                  e !== Br(i, Co) && (xr(i, Co, e), a(e ? _s : xs, T));
                  if (!e && document.activeElement === i) {
                    var r = c.Slides.getAt(t.index);
                    r && Fr(r.slide);
                  }
                })(),
                xr(i, Ao, e === n - 1),
                xr(i, Ro, e === n + 1);
            }
            var s;
          }
          function M() {
            var i = t.index;
            return i === e || (h.cloneStatus && i === n);
          }
          var T = {
            index: e,
            slideIndex: n,
            slide: i,
            container: b,
            isClone: x,
            mount: function () {
              x ||
                ((i.id = u.id + "-slide" + ls(e + 1)),
                Ir(i, qs, m ? "tabpanel" : "group"),
                Ir(i, no, f.slide),
                Ir(i, Js, _ || as(f.slideLabel, [e + 1, t.length]))),
                l(i, "click", rr(a, gs, T)),
                l(i, "keydown", rr(a, Is, T)),
                o([ms, Ns, Ts], S),
                o(Cs, w),
                p && o(fs, E);
            },
            destroy: function () {
              (r = !0),
                s.destroy(),
                qr(i, Io),
                Or(i, oo),
                Ir(i, "style", y),
                Ir(i, Js, _ || "");
            },
            update: S,
            style: function (t, e, n) {
              Dr((n && b) || i, t, e);
            },
            isWithin: function (n, i) {
              var r = ns(n - e);
              return (
                x || (!h.rewind && !t.is(Bo)) || (r = Jr(r, t.length - r)),
                r <= i
              );
            },
          };
          return T;
        }
        var Vo = "http://www.w3.org/2000/svg",
          Go =
            "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
        var Wo = $r + "-interval";
        var jo = {
          passive: !1,
          capture: !0,
        };
        var qo = {
          Spacebar: " ",
          Right: zs,
          Left: Bs,
          Up: Hs,
          Down: Vs,
        };
        function Xo(t) {
          return (t = dr(t) ? t : t.key), qo[t] || t;
        }
        var Yo = "keydown";
        var Ko = $r + "-lazy",
          $o = Ko + "-srcset",
          Zo = "[" + Ko + "], [" + $o + "]";
        var Jo = [" ", "Enter"];
        var Qo = Object.freeze({
            __proto__: null,
            Media: function (t, e, n) {
              var i = t.state,
                r = n.breakpoints || {},
                s = n.reducedMotion || {},
                o = hs(),
                a = [];
              function l(t) {
                t && o.destroy();
              }
              function c(t, e) {
                var n = matchMedia(e);
                o.bind(n, "change", u), a.push([t, n]);
              }
              function u() {
                var e = i.is(7),
                  r = n.direction,
                  s = a.reduce(function (t, e) {
                    return Lr(t, e[1].matches ? e[0] : {});
                  }, {});
                Pr(n),
                  h(s),
                  n.destroy
                    ? t.destroy("completely" === n.destroy)
                    : e
                    ? (l(!0), t.mount())
                    : r !== n.direction && t.refresh();
              }
              function h(e, r, s) {
                Lr(n, e),
                  r && Lr(Object.getPrototypeOf(n), e),
                  (!s && i.is(1)) || t.emit(ws, n);
              }
              return {
                setup: function () {
                  var t = "min" === n.mediaQuery;
                  Ar(r)
                    .sort(function (e, n) {
                      return t ? +e - +n : +n - +e;
                    })
                    .forEach(function (e) {
                      c(
                        r[e],
                        "(" + (t ? "min" : "max") + "-width:" + e + "px)"
                      );
                    }),
                    c(s, Ji),
                    u();
                },
                destroy: l,
                reduce: function (t) {
                  matchMedia(Ji).matches && (t ? Lr(n, s) : Pr(n, Ar(s)));
                },
                set: h,
              };
            },
            Direction: js,
            Elements: function (t, e, n) {
              var i,
                r,
                s,
                o = Us(t),
                a = o.on,
                l = o.bind,
                c = t.root,
                u = n.i18n,
                h = {},
                d = [],
                p = [],
                f = [];
              function m() {
                (i = y("." + uo)),
                  (r = Tr(i, "." + ho)),
                  Zr(i && r, "A track/list element is missing."),
                  _r(d, Mr(r, "." + po + ":not(." + fo + ")")),
                  Rr(
                    {
                      arrows: go,
                      pagination: xo,
                      prev: yo,
                      next: _o,
                      bar: wo,
                      toggle: Eo,
                    },
                    function (t, e) {
                      h[e] = y("." + t);
                    }
                  ),
                  Cr(h, {
                    root: c,
                    track: i,
                    list: r,
                    slides: d,
                  }),
                  (function () {
                    var t = c.id || us(Kr),
                      e = n.role;
                    (c.id = t),
                      (i.id = i.id || t + "-track"),
                      (r.id = r.id || t + "-list"),
                      !kr(c, qs) &&
                        "SECTION" !== c.tagName &&
                        e &&
                        Ir(c, qs, e);
                    Ir(c, no, u.carousel), Ir(r, qs, "presentation");
                  })(),
                  v();
              }
              function g(t) {
                var e = oo.concat("style");
                nr(d),
                  qr(c, p),
                  qr(i, f),
                  Or([i, r], e),
                  Or(c, t ? e : ["style", no]);
              }
              function v() {
                qr(c, p),
                  qr(i, f),
                  (p = _(co)),
                  (f = _(uo)),
                  br(c, p),
                  br(i, f),
                  Ir(c, Js, n.label),
                  Ir(c, Qs, n.labelledby);
              }
              function y(t) {
                var e = Wr(c, t);
                return e &&
                  (function (t, e) {
                    if (hr(t.closest)) return t.closest(e);
                    for (var n = t; n && 1 === n.nodeType && !Sr(n, e); )
                      n = n.parentElement;
                    return n;
                  })(e, "." + co) === c
                  ? e
                  : void 0;
              }
              function _(t) {
                return [
                  t + "--" + n.type,
                  t + "--" + n.direction,
                  n.drag && t + "--draggable",
                  n.isNavigation && t + "--nav",
                  t === co && To,
                ];
              }
              return Cr(h, {
                setup: m,
                mount: function () {
                  a(bs, g),
                    a(bs, m),
                    a(ws, v),
                    l(
                      document,
                      Do + " keydown",
                      function (t) {
                        s = "keydown" === t.type;
                      },
                      {
                        capture: !0,
                      }
                    ),
                    l(c, "focusin", function () {
                      xr(c, Po, !!s);
                    });
                },
                destroy: g,
              });
            },
            Slides: function (t, e, n) {
              var i = Us(t),
                r = i.on,
                s = i.emit,
                o = i.bind,
                a = e.Elements,
                l = a.slides,
                c = a.list,
                u = [];
              function h() {
                l.forEach(function (t, e) {
                  p(t, e, -1);
                });
              }
              function d() {
                m(function (t) {
                  t.destroy();
                }),
                  nr(u);
              }
              function p(e, n, i) {
                var r = Ho(t, n, i, e);
                r.mount(),
                  u.push(r),
                  u.sort(function (t, e) {
                    return t.index - e.index;
                  });
              }
              function f(t) {
                return t
                  ? g(function (t) {
                      return !t.isClone;
                    })
                  : u;
              }
              function m(t, e) {
                f(e).forEach(t);
              }
              function g(t) {
                return u.filter(
                  hr(t)
                    ? t
                    : function (e) {
                        return dr(t) ? Sr(e.slide, t) : yr(gr(t), e.index);
                      }
                );
              }
              return {
                mount: function () {
                  h(), r(bs, d), r(bs, h);
                },
                destroy: d,
                update: function () {
                  m(function (t) {
                    t.update();
                  });
                },
                register: p,
                get: f,
                getIn: function (t) {
                  var i = e.Controller,
                    r = i.toIndex(t),
                    s = i.hasFocus() ? 1 : n.perPage;
                  return g(function (t) {
                    return rs(t.index, r, r + s - 1);
                  });
                },
                getAt: function (t) {
                  return g(t)[0];
                },
                add: function (t, e) {
                  vr(t, function (t) {
                    if ((dr(t) && (t = Vr(t)), mr(t))) {
                      var i = l[e];
                      i ? Er(t, i) : wr(c, t),
                        br(t, n.classes.slide),
                        (r = t),
                        (a = rr(s, Es)),
                        (u = jr(r, "img")),
                        (h = u.length)
                          ? u.forEach(function (t) {
                              o(t, "load error", function () {
                                --h || a();
                              });
                            })
                          : a();
                    }
                    var r, a, u, h;
                  }),
                    s(bs);
                },
                remove: function (t) {
                  Hr(
                    g(t).map(function (t) {
                      return t.slide;
                    })
                  ),
                    s(bs);
                },
                forEach: m,
                filter: g,
                style: function (t, e, n) {
                  m(function (i) {
                    i.style(t, e, n);
                  });
                },
                getLength: function (t) {
                  return t ? l.length : u.length;
                },
                isEnough: function () {
                  return u.length > n.perPage;
                },
              };
            },
            Layout: function (t, e, n) {
              var i,
                r,
                s,
                o = Us(t),
                a = o.on,
                l = o.bind,
                c = o.emit,
                u = e.Slides,
                h = e.Direction.resolve,
                d = e.Elements,
                p = d.root,
                f = d.track,
                m = d.list,
                g = u.getAt,
                v = u.style;
              function y() {
                (i = n.direction === Gs),
                  Dr(p, "maxWidth", Yr(n.width)),
                  Dr(f, h("paddingLeft"), x(!1)),
                  Dr(f, h("paddingRight"), x(!0)),
                  _(!0);
              }
              function _(t) {
                var e = zr(p);
                (t || r.width !== e.width || r.height !== e.height) &&
                  (Dr(
                    f,
                    "height",
                    (function () {
                      var t = "";
                      i &&
                        (Zr((t = b()), "height or heightRatio is missing."),
                        (t =
                          "calc(" + t + " - " + x(!1) + " - " + x(!0) + ")"));
                      return t;
                    })()
                  ),
                  v(h("marginRight"), Yr(n.gap)),
                  v(
                    "width",
                    n.autoWidth ? null : Yr(n.fixedWidth) || (i ? "" : w())
                  ),
                  v(
                    "height",
                    Yr(n.fixedHeight) ||
                      (i ? (n.autoHeight ? null : w()) : b()),
                    !0
                  ),
                  (r = e),
                  c(Ss),
                  s !== (s = R()) && (xr(p, Oo, s), c("overflow", s)));
              }
              function x(t) {
                var e = n.padding,
                  i = h(t ? "right" : "left");
                return (e && Yr(e[i] || (cr(e) ? 0 : e))) || "0px";
              }
              function b() {
                return Yr(n.height || zr(m).width * n.heightRatio);
              }
              function w() {
                var t = Yr(n.gap);
                return (
                  "calc((100%" +
                  (t && " + " + t) +
                  ")/" +
                  (n.perPage || 1) +
                  (t && " - " + t) +
                  ")"
                );
              }
              function E() {
                return zr(m)[h("width")];
              }
              function S(t, e) {
                var n = g(t || 0);
                return n ? zr(n.slide)[h("width")] + (e ? 0 : A()) : 0;
              }
              function M(t, e) {
                var n = g(t);
                if (n) {
                  var i = zr(n.slide)[h("right")],
                    r = zr(m)[h("left")];
                  return ns(i - r) + (e ? 0 : A());
                }
                return 0;
              }
              function T(e) {
                return M(t.length - 1) - M(0) + S(0, e);
              }
              function A() {
                var t = g(0);
                return (t && parseFloat(Dr(t.slide, h("marginRight")))) || 0;
              }
              function R() {
                return t.is(zo) || T(!0) > E();
              }
              return {
                mount: function () {
                  var t, e, n;
                  y(),
                    l(
                      window,
                      "resize load",
                      ((t = rr(c, Es)),
                      (n = Fs(e || 0, t, null, 1)),
                      function () {
                        n.isPaused() && n.start();
                      })
                    ),
                    a([ws, bs], y),
                    a(Es, _);
                },
                resize: _,
                listSize: E,
                slideSize: S,
                sliderSize: T,
                totalSize: M,
                getPadding: function (t) {
                  return (
                    parseFloat(Dr(f, h("padding" + (t ? "Right" : "Left")))) ||
                    0
                  );
                },
                isOverflow: R,
              };
            },
            Clones: function (t, e, n) {
              var i,
                r = Us(t),
                s = r.on,
                o = e.Elements,
                a = e.Slides,
                l = e.Direction.resolve,
                c = [];
              function u() {
                s(bs, h),
                  s([ws, Es], p),
                  (i = f()) &&
                    (!(function (e) {
                      var i = a.get().slice(),
                        r = i.length;
                      if (r) {
                        for (; i.length < e; ) _r(i, i);
                        _r(i.slice(-e), i.slice(0, e)).forEach(function (s, l) {
                          var u = l < e,
                            h = (function (e, i) {
                              var r = e.cloneNode(!0);
                              return (
                                br(r, n.classes.clone),
                                (r.id = t.root.id + "-clone" + ls(i + 1)),
                                r
                              );
                            })(s.slide, l);
                          u ? Er(h, i[0].slide) : wr(o.list, h),
                            _r(c, h),
                            a.register(h, l - e + (u ? 0 : r), s.index);
                        });
                      }
                    })(i),
                    e.Layout.resize(!0));
              }
              function h() {
                d(), u();
              }
              function d() {
                Hr(c), nr(c), r.destroy();
              }
              function p() {
                var t = f();
                i !== t && (i < t || !t) && r.emit(bs);
              }
              function f() {
                var i = n.clones;
                if (t.is(Bo)) {
                  if (pr(i)) {
                    var r = n[l("fixedWidth")] && e.Layout.slideSize(0);
                    i =
                      (r && es(zr(o.track)[l("width")] / r)) ||
                      (n[l("autoWidth")] && t.length) ||
                      2 * n.perPage;
                  }
                } else i = 0;
                return i;
              }
              return {
                mount: u,
                destroy: d,
              };
            },
            Move: function (t, e, n) {
              var i,
                r = Us(t),
                s = r.on,
                o = r.emit,
                a = t.state.set,
                l = e.Layout,
                c = l.slideSize,
                u = l.getPadding,
                h = l.totalSize,
                d = l.listSize,
                p = l.sliderSize,
                f = e.Direction,
                m = f.resolve,
                g = f.orient,
                v = e.Elements,
                y = v.list,
                _ = v.track;
              function x() {
                e.Controller.isBusy() ||
                  (e.Scroll.cancel(), b(t.index), e.Slides.update());
              }
              function b(t) {
                w(T(t, !0));
              }
              function w(n, i) {
                if (!t.is(zo)) {
                  var r = i
                    ? n
                    : (function (n) {
                        if (t.is(Bo)) {
                          var i = M(n),
                            r = i > e.Controller.getEnd();
                          (i < 0 || r) && (n = E(n, r));
                        }
                        return n;
                      })(n);
                  Dr(y, "transform", "translate" + m("X") + "(" + r + "px)"),
                    n !== r && o(Ns);
                }
              }
              function E(t, e) {
                var n = t - R(e),
                  i = p();
                return (t -= g(i * (es(ns(n) / i) || 1)) * (e ? 1 : -1));
              }
              function S() {
                w(A(), !0), i.cancel();
              }
              function M(t) {
                for (
                  var n = e.Slides.get(), i = 0, r = 1 / 0, s = 0;
                  s < n.length;
                  s++
                ) {
                  var o = n[s].index,
                    a = ns(T(o, !0) - t);
                  if (!(a <= r)) break;
                  (r = a), (i = o);
                }
                return i;
              }
              function T(e, i) {
                var r = g(
                  h(e - 1) -
                    (function (t) {
                      var e = n.focus;
                      return "center" === e
                        ? (d() - c(t, !0)) / 2
                        : +e * c(t) || 0;
                    })(e)
                );
                return i
                  ? (function (e) {
                      n.trimSpace && t.is(ko) && (e = ss(e, 0, g(p(!0) - d())));
                      return e;
                    })(r)
                  : r;
              }
              function A() {
                var t = m("left");
                return zr(y)[t] - zr(_)[t] + g(u(!1));
              }
              function R(t) {
                return T(t ? e.Controller.getEnd() : 0, !!n.trimSpace);
              }
              return {
                mount: function () {
                  (i = e.Transition), s([ds, Ss, ws, bs], x);
                },
                move: function (t, e, n, r) {
                  var s, l;
                  t !== e &&
                    ((s = t > n),
                    (l = g(E(A(), s))),
                    s
                      ? l >= 0
                      : l <= y[m("scrollWidth")] - zr(_)[m("width")]) &&
                    (S(), w(E(A(), t > n), !0)),
                    a(Qi),
                    o(fs, e, n, t),
                    i.start(e, function () {
                      a(3), o(ms, e, n, t), r && r();
                    });
                },
                jump: b,
                translate: w,
                shift: E,
                cancel: S,
                toIndex: M,
                toPosition: T,
                getPosition: A,
                getLimit: R,
                exceededLimit: function (t, e) {
                  e = pr(e) ? A() : e;
                  var n = !0 !== t && g(e) < g(R(!1)),
                    i = !1 !== t && g(e) > g(R(!0));
                  return n || i;
                },
                reposition: x,
              };
            },
            Controller: function (t, e, n) {
              var i,
                r,
                s,
                o,
                a = Us(t),
                l = a.on,
                c = a.emit,
                u = e.Move,
                h = u.getPosition,
                d = u.getLimit,
                p = u.toPosition,
                f = e.Slides,
                m = f.isEnough,
                g = f.getLength,
                v = n.omitEnd,
                y = t.is(Bo),
                _ = t.is(ko),
                x = rr(T, !1),
                b = rr(T, !0),
                w = n.start || 0,
                E = w;
              function S() {
                (r = g(!0)), (s = n.perMove), (o = n.perPage), (i = C());
                var t = ss(w, 0, v ? i : r - 1);
                t !== w && ((w = t), u.reposition());
              }
              function M() {
                i !== C() && c(Ds);
              }
              function T(t, e) {
                var n = s || (I() ? 1 : o),
                  r = A(w + n * (t ? -1 : 1), w, !(s || I()));
                return -1 === r && _ && !is(h(), d(!t), 1)
                  ? t
                    ? 0
                    : i
                  : e
                  ? r
                  : R(r);
              }
              function A(e, a, l) {
                if (m() || I()) {
                  var c = (function (e) {
                    if (_ && "move" === n.trimSpace && e !== w)
                      for (
                        var i = h();
                        i === p(e, !0) && rs(e, 0, t.length - 1, !n.rewind);

                      )
                        e < w ? --e : ++e;
                    return e;
                  })(e);
                  c !== e && ((a = e), (e = c), (l = !1)),
                    e < 0 || e > i
                      ? (e =
                          s || (!rs(0, e, a, !0) && !rs(i, a, e, !0))
                            ? y
                              ? l
                                ? e < 0
                                  ? -(r % o || o)
                                  : r
                                : e
                              : n.rewind
                              ? e < 0
                                ? i
                                : 0
                              : -1
                            : L(P(e)))
                      : l && e !== a && (e = L(P(a) + (e < a ? -1 : 1)));
                } else e = -1;
                return e;
              }
              function R(t) {
                return y ? (t + r) % r || 0 : t;
              }
              function C() {
                for (var t = r - (I() || (y && s) ? 1 : o); v && t-- > 0; )
                  if (p(r - 1, !0) !== p(t, !0)) {
                    t++;
                    break;
                  }
                return ss(t, 0, r - 1);
              }
              function L(t) {
                return ss(I() ? t : o * t, 0, i);
              }
              function P(t) {
                return I() ? Jr(t, i) : ts((t >= i ? r - 1 : t) / o);
              }
              function O(t) {
                t !== w && ((E = w), (w = t));
              }
              function I() {
                return !pr(n.focus) || n.isNavigation;
              }
              function N() {
                return t.state.is([Qi, tr]) && !!n.waitForTransition;
              }
              return {
                mount: function () {
                  S(), l([ws, bs, Ds], S), l(Ss, M);
                },
                go: function (t, e, n) {
                  if (!N()) {
                    var r = (function (t) {
                        var e = w;
                        if (dr(t)) {
                          var n = t.match(/([+\-<>])(\d+)?/) || [],
                            r = n[1],
                            s = n[2];
                          "+" === r || "-" === r
                            ? (e = A(w + +("" + r + (+s || 1)), w))
                            : ">" === r
                            ? (e = s ? L(+s) : x(!0))
                            : "<" === r && (e = b(!0));
                        } else e = y ? t : ss(t, 0, i);
                        return e;
                      })(t),
                      s = R(r);
                    s > -1 && (e || s !== w) && (O(s), u.move(r, s, E, n));
                  }
                },
                scroll: function (t, n, r, s) {
                  e.Scroll.scroll(t, n, r, function () {
                    var t = R(u.toIndex(h()));
                    O(v ? Jr(t, i) : t), s && s();
                  });
                },
                getNext: x,
                getPrev: b,
                getAdjacent: T,
                getEnd: C,
                setIndex: O,
                getIndex: function (t) {
                  return t ? E : w;
                },
                toIndex: L,
                toPage: P,
                toDest: function (t) {
                  var e = u.toIndex(t);
                  return _ ? ss(e, 0, i) : e;
                },
                hasFocus: I,
                isBusy: N,
              };
            },
            Arrows: function (t, e, n) {
              var i,
                r,
                s = Us(t),
                o = s.on,
                a = s.bind,
                l = s.emit,
                c = n.classes,
                u = n.i18n,
                h = e.Elements,
                d = e.Controller,
                p = h.arrows,
                f = h.track,
                m = p,
                g = h.prev,
                v = h.next,
                y = {};
              function _() {
                !(function () {
                  var t = n.arrows;
                  !t ||
                    (g && v) ||
                    ((m = p || Nr("div", c.arrows)),
                    (g = E(!0)),
                    (v = E(!1)),
                    (i = !0),
                    wr(m, [g, v]),
                    !p && Er(m, f));
                  g &&
                    v &&
                    (Cr(y, {
                      prev: g,
                      next: v,
                    }),
                    Ur(m, t ? "" : "none"),
                    br(m, (r = go + "--" + n.direction)),
                    t &&
                      (o([ds, ms, bs, Ts, Ds], S),
                      a(v, "click", rr(w, ">")),
                      a(g, "click", rr(w, "<")),
                      S(),
                      Ir([g, v], Ks, f.id),
                      l(Rs, g, v)));
                })(),
                  o(ws, x);
              }
              function x() {
                b(), _();
              }
              function b() {
                s.destroy(),
                  qr(m, r),
                  i ? (Hr(p ? [g, v] : m), (g = v = null)) : Or([g, v], oo);
              }
              function w(t) {
                d.go(t, !0);
              }
              function E(t) {
                return Vr(
                  '<button class="' +
                    c.arrow +
                    " " +
                    (t ? c.prev : c.next) +
                    '" type="button"><svg xmlns="' +
                    Vo +
                    '" viewBox="0 0 ' +
                    "40 " +
                    '40" width="' +
                    '40" height="' +
                    '40" focusable="false"><path d="' +
                    (n.arrowPath || Go) +
                    '" />'
                );
              }
              function S() {
                if (g && v) {
                  var e = t.index,
                    n = d.getPrev(),
                    i = d.getNext(),
                    r = n > -1 && e < n ? u.last : u.prev,
                    s = i > -1 && e > i ? u.first : u.next;
                  (g.disabled = n < 0),
                    (v.disabled = i < 0),
                    Ir(g, Js, r),
                    Ir(v, Js, s),
                    l("arrows:updated", g, v, n, i);
                }
              }
              return {
                arrows: y,
                mount: _,
                destroy: b,
                update: S,
              };
            },
            Autoplay: function (t, e, n) {
              var i,
                r,
                s = Us(t),
                o = s.on,
                a = s.bind,
                l = s.emit,
                c = Fs(n.interval, t.go.bind(t, ">"), function (t) {
                  var e = h.bar;
                  e && Dr(e, "width", 100 * t + "%"), l("autoplay:playing", t);
                }),
                u = c.isPaused,
                h = e.Elements,
                d = e.Elements,
                p = d.root,
                f = d.toggle,
                m = n.autoplay,
                g = "pause" === m;
              function v() {
                u() &&
                  e.Slides.isEnough() &&
                  (c.start(!n.resetProgress), (r = i = g = !1), x(), l(Ls));
              }
              function y(t) {
                void 0 === t && (t = !0),
                  (g = !!t),
                  x(),
                  u() || (c.pause(), l(Ps));
              }
              function _() {
                g || (i || r ? y(!1) : v());
              }
              function x() {
                f && (xr(f, To, !g), Ir(f, Js, n.i18n[g ? "play" : "pause"]));
              }
              function b(t) {
                var i = e.Slides.getAt(t);
                c.set((i && +kr(i.slide, Wo)) || n.interval);
              }
              return {
                mount: function () {
                  m &&
                    (!(function () {
                      n.pauseOnHover &&
                        a(p, "mouseenter mouseleave", function (t) {
                          (i = "mouseenter" === t.type), _();
                        });
                      n.pauseOnFocus &&
                        a(p, "focusin focusout", function (t) {
                          (r = "focusin" === t.type), _();
                        });
                      f &&
                        a(f, "click", function () {
                          g ? v() : y(!0);
                        });
                      o([fs, Ms, bs], c.rewind), o(fs, b);
                    })(),
                    f && Ir(f, Ks, h.track.id),
                    g || v(),
                    x());
                },
                destroy: c.cancel,
                play: v,
                pause: y,
                isPaused: u,
              };
            },
            Cover: function (t, e, n) {
              var i = Us(t).on;
              function r(t) {
                e.Slides.forEach(function (e) {
                  var n = Tr(e.container || e.slide, "img");
                  n && n.src && s(t, n, e);
                });
              }
              function s(t, e, n) {
                n.style(
                  "background",
                  t ? 'center/cover no-repeat url("' + e.src + '")' : "",
                  !0
                ),
                  Ur(e, t ? "none" : "");
              }
              return {
                mount: function () {
                  n.cover && (i(Os, rr(s, !0)), i([ds, ws, bs], rr(r, !0)));
                },
                destroy: rr(r, !1),
              };
            },
            Scroll: function (t, e, n) {
              var i,
                r,
                s = Us(t),
                o = s.on,
                a = s.emit,
                l = t.state.set,
                c = e.Move,
                u = c.getPosition,
                h = c.getLimit,
                d = c.exceededLimit,
                p = c.translate,
                f = t.is(ko),
                m = 1;
              function g(t, n, s, o, h) {
                var p = u();
                if ((_(), s && (!f || !d()))) {
                  var g = e.Layout.sliderSize(),
                    x = os(t) * g * ts(ns(t) / g) || 0;
                  t = c.toPosition(e.Controller.toDest(t % g)) + x;
                }
                var b = is(p, t, 1);
                (m = 1),
                  (n = b ? 0 : n || Qr(ns(t - p) / 1.5, 800)),
                  (r = o),
                  (i = Fs(n, v, rr(y, p, t, h), 1)),
                  l(tr),
                  a(Ms),
                  i.start();
              }
              function v() {
                l(3), r && r(), a(Ts);
              }
              function y(t, e, i, s) {
                var o = u(),
                  a =
                    t +
                    (e - t) *
                      (function (t) {
                        var e = n.easingFunc;
                        return e ? e(t) : 1 - Math.pow(1 - t, 4);
                      })(s),
                  l = (a - o) * m;
                p(o + l),
                  f &&
                    !i &&
                    d() &&
                    ((m *= 0.6), ns(l) < 10 && g(h(d(!0)), 600, !1, r, !0));
              }
              function _() {
                i && i.cancel();
              }
              function x() {
                i && !i.isPaused() && (_(), v());
              }
              return {
                mount: function () {
                  o(fs, _), o([ws, bs], x);
                },
                destroy: _,
                scroll: g,
                cancel: x,
              };
            },
            Drag: function (t, e, n) {
              var i,
                r,
                s,
                o,
                a,
                l,
                c,
                u,
                h = Us(t),
                d = h.on,
                p = h.emit,
                f = h.bind,
                m = h.unbind,
                g = t.state,
                v = e.Move,
                y = e.Scroll,
                _ = e.Controller,
                x = e.Elements.track,
                b = e.Media.reduce,
                w = e.Direction,
                E = w.resolve,
                S = w.orient,
                M = v.getPosition,
                T = v.exceededLimit,
                A = !1;
              function R() {
                var t = n.drag;
                B(!t), (o = "free" === t);
              }
              function C(t) {
                if (((l = !1), !c)) {
                  var e = k(t);
                  (i = t.target),
                    (r = n.noDrag),
                    Sr(i, "." + bo + ", ." + vo) ||
                      (r && Sr(i, r)) ||
                      (!e && t.button) ||
                      (_.isBusy()
                        ? Gr(t, !0)
                        : ((u = e ? x : window),
                          (a = g.is([Qi, tr])),
                          (s = null),
                          f(u, Uo, L, jo),
                          f(u, Fo, P, jo),
                          v.cancel(),
                          y.cancel(),
                          I(t)));
                }
                var i, r;
              }
              function L(e) {
                if ((g.is(6) || (g.set(6), p("drag")), e.cancelable))
                  if (a) {
                    v.translate(i + N(e) / (A && t.is(ko) ? 5 : 1));
                    var r = D(e) > 200,
                      s = A !== (A = T());
                    (r || s) && I(e), (l = !0), p("dragging"), Gr(e);
                  } else
                    (function (t) {
                      return ns(N(t)) > ns(N(t, !0));
                    })(e) &&
                      ((a = (function (t) {
                        var e = n.dragMinThreshold,
                          i = cr(e),
                          r = (i && e.mouse) || 0,
                          s = (i ? e.touch : +e) || 10;
                        return ns(N(t)) > (k(t) ? s : r);
                      })(e)),
                      Gr(e));
              }
              function P(i) {
                g.is(6) && (g.set(3), p("dragged")),
                  a &&
                    (!(function (i) {
                      var r = (function (e) {
                          if (t.is(Bo) || !A) {
                            var n = D(e);
                            if (n && n < 200) return N(e) / n;
                          }
                          return 0;
                        })(i),
                        s = (function (t) {
                          return (
                            M() +
                            os(t) *
                              Jr(
                                ns(t) * (n.flickPower || 600),
                                o
                                  ? 1 / 0
                                  : e.Layout.listSize() * (n.flickMaxPages || 1)
                              )
                          );
                        })(r),
                        a = n.rewind && n.rewindByDrag;
                      b(!1),
                        o
                          ? _.scroll(s, 0, n.snap)
                          : t.is(zo)
                          ? _.go(S(os(r)) < 0 ? (a ? "<" : "-") : a ? ">" : "+")
                          : t.is(ko) && A && a
                          ? _.go(T(!0) ? ">" : "<")
                          : _.go(_.toDest(s), !0);
                      b(!0);
                    })(i),
                    Gr(i)),
                  m(u, Uo, L),
                  m(u, Fo, P),
                  (a = !1);
              }
              function O(t) {
                !c && l && Gr(t, !0);
              }
              function I(t) {
                (s = r), (r = t), (i = M());
              }
              function N(t, e) {
                return F(t, e) - F(U(t), e);
              }
              function D(t) {
                return Xr(t) - Xr(U(t));
              }
              function U(t) {
                return (r === t && s) || r;
              }
              function F(t, e) {
                return (k(t) ? t.changedTouches[0] : t)[
                  "page" + E(e ? "Y" : "X")
                ];
              }
              function k(t) {
                return (
                  "undefined" != typeof TouchEvent && t instanceof TouchEvent
                );
              }
              function B(t) {
                c = t;
              }
              return {
                mount: function () {
                  f(x, Uo, or, jo),
                    f(x, Fo, or, jo),
                    f(x, Do, C, jo),
                    f(x, "click", O, {
                      capture: !0,
                    }),
                    f(x, "dragstart", Gr),
                    d([ds, ws], R);
                },
                disable: B,
                isDragging: function () {
                  return a;
                },
              };
            },
            Keyboard: function (t, e, n) {
              var i,
                r,
                s = Us(t),
                o = s.on,
                a = s.bind,
                l = s.unbind,
                c = t.root,
                u = e.Direction.resolve;
              function h() {
                var t = n.keyboard;
                t && ((i = "global" === t ? window : c), a(i, Yo, f));
              }
              function d() {
                l(i, Yo);
              }
              function p() {
                var t = r;
                (r = !0),
                  sr(function () {
                    r = t;
                  });
              }
              function f(e) {
                if (!r) {
                  var n = Xo(e);
                  n === u(Bs) ? t.go("<") : n === u(zs) && t.go(">");
                }
              }
              return {
                mount: function () {
                  h(), o(ws, d), o(ws, h), o(fs, p);
                },
                destroy: d,
                disable: function (t) {
                  r = t;
                },
              };
            },
            LazyLoad: function (t, e, n) {
              var i = Us(t),
                r = i.on,
                s = i.off,
                o = i.bind,
                a = i.emit,
                l = "sequential" === n.lazyLoad,
                c = [ms, Ts],
                u = [];
              function h() {
                nr(u),
                  e.Slides.forEach(function (t) {
                    jr(t.slide, Zo).forEach(function (e) {
                      var i = kr(e, Ko),
                        r = kr(e, $o);
                      if (i !== e.src || r !== e.srcset) {
                        var s = n.classes.spinner,
                          o = e.parentElement,
                          a = Tr(o, "." + s) || Nr("span", s, o);
                        u.push([e, t, a]), e.src || Ur(e, "none");
                      }
                    });
                  }),
                  l ? m() : (s(c), r(c, d), d());
              }
              function d() {
                (u = u.filter(function (e) {
                  var i = n.perPage * ((n.preloadPages || 1) + 1) - 1;
                  return !e[1].isWithin(t.index, i) || p(e);
                })).length || s(c);
              }
              function p(t) {
                var e = t[0];
                br(t[1].slide, Lo),
                  o(e, "load error", rr(f, t)),
                  Ir(e, "src", kr(e, Ko)),
                  Ir(e, "srcset", kr(e, $o)),
                  Or(e, Ko),
                  Or(e, $o);
              }
              function f(t, e) {
                var n = t[0],
                  i = t[1];
                qr(i.slide, Lo),
                  "error" !== e.type &&
                    (Hr(t[2]), Ur(n, ""), a(Os, n, i), a(Es)),
                  l && m();
              }
              function m() {
                u.length && p(u.shift());
              }
              return {
                mount: function () {
                  n.lazyLoad && (h(), r(bs, h));
                },
                destroy: rr(nr, u),
                check: d,
              };
            },
            Pagination: function (t, e, n) {
              var i,
                r,
                s = Us(t),
                o = s.on,
                a = s.emit,
                l = s.bind,
                c = e.Slides,
                u = e.Elements,
                h = e.Controller,
                d = h.hasFocus,
                p = h.getIndex,
                f = h.go,
                m = e.Direction.resolve,
                g = u.pagination,
                v = [];
              function y() {
                i && (Hr(g ? ir(i.children) : i), qr(i, r), nr(v), (i = null)),
                  s.destroy();
              }
              function _(t) {
                f(">" + t, !0);
              }
              function x(t, e) {
                var n = v.length,
                  i = Xo(e),
                  r = b(),
                  s = -1;
                i === m(zs, !1, r)
                  ? (s = ++t % n)
                  : i === m(Bs, !1, r)
                  ? (s = (--t + n) % n)
                  : "Home" === i
                  ? (s = 0)
                  : "End" === i && (s = n - 1);
                var o = v[s];
                o && (Fr(o.button), f(">" + s), Gr(e, !0));
              }
              function b() {
                return n.paginationDirection || n.direction;
              }
              function w(t) {
                return v[h.toPage(t)];
              }
              function E() {
                var t = w(p(!0)),
                  e = w(p());
                if (t) {
                  var n = t.button;
                  qr(n, To), Or(n, Zs), Ir(n, Xs, -1);
                }
                if (e) {
                  var r = e.button;
                  br(r, To), Ir(r, Zs, !0), Ir(r, Xs, "");
                }
                a(
                  "pagination:updated",
                  {
                    list: i,
                    items: v,
                  },
                  t,
                  e
                );
              }
              return {
                items: v,
                mount: function e() {
                  y(), o([ws, bs, Ds], e);
                  var s = n.pagination;
                  g && Ur(g, s ? "" : "none"),
                    s &&
                      (o([fs, Ms, Ts], E),
                      (function () {
                        var e = t.length,
                          s = n.classes,
                          o = n.i18n,
                          a = n.perPage,
                          p = d() ? h.getEnd() + 1 : es(e / a);
                        br(
                          (i =
                            g || Nr("ul", s.pagination, u.track.parentElement)),
                          (r = xo + "--" + b())
                        ),
                          Ir(i, qs, "tablist"),
                          Ir(i, Js, o.select),
                          Ir(i, eo, b() === Gs ? "vertical" : "");
                        for (var f = 0; f < p; f++) {
                          var m = Nr("li", null, i),
                            y = Nr(
                              "button",
                              {
                                class: s.page,
                                type: "button",
                              },
                              m
                            ),
                            w = c.getIn(f).map(function (t) {
                              return t.slide.id;
                            }),
                            E = !d() && a > 1 ? o.pageX : o.slideX;
                          l(y, "click", rr(_, f)),
                            n.paginationKeyboard && l(y, "keydown", rr(x, f)),
                            Ir(m, qs, "presentation"),
                            Ir(y, qs, "tab"),
                            Ir(y, Ks, w.join(" ")),
                            Ir(y, Js, as(E, f + 1)),
                            Ir(y, Xs, -1),
                            v.push({
                              li: m,
                              button: y,
                              page: f,
                            });
                        }
                      })(),
                      E(),
                      a(
                        "pagination:mounted",
                        {
                          list: i,
                          items: v,
                        },
                        w(t.index)
                      ));
                },
                destroy: y,
                getAt: w,
                update: E,
              };
            },
            Sync: function (t, e, n) {
              var i = n.isNavigation,
                r = n.slideFocus,
                s = [];
              function o() {
                var e, n;
                t.splides.forEach(function (e) {
                  e.isParent || (l(t, e.splide), l(e.splide, t));
                }),
                  i &&
                    ((e = Us(t)),
                    (n = e.on)(gs, u),
                    n(Is, h),
                    n([ds, ws], c),
                    s.push(e),
                    e.emit(Cs, t.splides));
              }
              function a() {
                s.forEach(function (t) {
                  t.destroy();
                }),
                  nr(s);
              }
              function l(t, e) {
                var n = Us(t);
                n.on(fs, function (t, n, i) {
                  e.go(e.is(Bo) ? i : t);
                }),
                  s.push(n);
              }
              function c() {
                Ir(e.Elements.list, eo, n.direction === Gs ? "vertical" : "");
              }
              function u(e) {
                t.go(e.index);
              }
              function h(t, e) {
                yr(Jo, Xo(e)) && (u(t), Gr(e));
              }
              return {
                setup: rr(
                  e.Media.set,
                  {
                    slideFocus: pr(r) ? i : r,
                  },
                  !0
                ),
                mount: o,
                destroy: a,
                remount: function () {
                  a(), o();
                },
              };
            },
            Wheel: function (t, e, n) {
              var i = Us(t).bind,
                r = 0;
              function s(i) {
                if (i.cancelable) {
                  var s = i.deltaY,
                    o = s < 0,
                    a = Xr(i),
                    l = n.wheelMinThreshold || 0,
                    c = n.wheelSleep || 0;
                  ns(s) > l && a - r > c && (t.go(o ? "<" : ">"), (r = a)),
                    (function (i) {
                      return (
                        !n.releaseWheel ||
                        t.state.is(Qi) ||
                        -1 !== e.Controller.getAdjacent(i)
                      );
                    })(o) && Gr(i);
                }
              }
              return {
                mount: function () {
                  n.wheel && i(e.Elements.track, "wheel", s, jo);
                },
              };
            },
            Live: function (t, e, n) {
              var i = Us(t).on,
                r = e.Elements.track,
                s = n.live && !n.isNavigation,
                o = Nr("span", So),
                a = Fs(90, rr(l, !1));
              function l(t) {
                Ir(r, ro, t), t ? (wr(r, o), a.start()) : (Hr(o), a.cancel());
              }
              function c(t) {
                s && Ir(r, io, t ? "off" : "polite");
              }
              return {
                mount: function () {
                  s &&
                    (c(!e.Autoplay.isPaused()),
                    Ir(r, so, !0),
                    (o.textContent = "…"),
                    i(Ls, rr(c, !0)),
                    i(Ps, rr(c, !1)),
                    i([ms, Ts], rr(l, !0)));
                },
                disable: c,
                destroy: function () {
                  Or(r, [io, so, ro]), Hr(o);
                },
              };
            },
          }),
          ta = {
            type: "slide",
            role: "region",
            speed: 400,
            perPage: 1,
            cloneStatus: !0,
            arrows: !0,
            pagination: !0,
            paginationKeyboard: !0,
            interval: 5e3,
            pauseOnHover: !0,
            pauseOnFocus: !0,
            resetProgress: !0,
            easing: "cubic-bezier(0.25, 1, 0.5, 1)",
            drag: !0,
            direction: "ltr",
            trimSpace: !0,
            focusableNodes: "a, button, textarea, input, select, iframe",
            live: !0,
            classes: No,
            i18n: {
              prev: "Previous slide",
              next: "Next slide",
              first: "Go to first slide",
              last: "Go to last slide",
              slideX: "Go to slide %s",
              pageX: "Go to page %s",
              play: "Start autoplay",
              pause: "Pause autoplay",
              carousel: "carousel",
              slide: "slide",
              select: "Select a slide to show",
              slideLabel: "%s of %s",
            },
            reducedMotion: {
              speed: 0,
              rewindSpeed: 0,
              autoplay: "pause",
            },
          };
        function ea(t, e, n) {
          var i = e.Slides;
          function r() {
            i.forEach(function (t) {
              t.style("transform", "translateX(-" + 100 * t.index + "%)");
            });
          }
          return {
            mount: function () {
              Us(t).on([ds, bs], r);
            },
            start: function (t, e) {
              i.style("transition", "opacity " + n.speed + "ms " + n.easing),
                sr(e);
            },
            cancel: or,
          };
        }
        function na(t, e, n) {
          var i,
            r = e.Move,
            s = e.Controller,
            o = e.Scroll,
            a = e.Elements.list,
            l = rr(Dr, a, "transition");
          function c() {
            l(""), o.cancel();
          }
          return {
            mount: function () {
              Us(t).bind(a, "transitionend", function (t) {
                t.target === a && i && (c(), i());
              });
            },
            start: function (e, a) {
              var c = r.toPosition(e, !0),
                u = r.getPosition(),
                h = (function (e) {
                  var i = n.rewindSpeed;
                  if (t.is(ko) && i) {
                    var r = s.getIndex(!0),
                      o = s.getEnd();
                    if ((0 === r && e >= o) || (r >= o && 0 === e)) return i;
                  }
                  return n.speed;
                })(e);
              ns(c - u) >= 1 && h >= 1
                ? n.useScroll
                  ? o.scroll(c, h, !1, a)
                  : (l("transform " + h + "ms " + n.easing),
                    r.translate(c, !0),
                    (i = a))
                : (r.jump(e), a());
            },
            cancel: c,
          };
        }
        var ia = (function () {
            function t(e, n) {
              var i;
              (this.event = Us()),
                (this.Components = {}),
                (this.state =
                  ((i = 1),
                  {
                    set: function (t) {
                      i = t;
                    },
                    is: function (t) {
                      return yr(gr(t), i);
                    },
                  })),
                (this.splides = []),
                (this._o = {}),
                (this._E = {});
              var r = dr(e) ? Wr(document, e) : e;
              Zr(r, r + " is invalid."),
                (this.root = r),
                (n = Lr(
                  {
                    label: kr(r, Js) || "",
                    labelledby: kr(r, Qs) || "",
                  },
                  ta,
                  t.defaults,
                  n || {}
                ));
              try {
                Lr(n, JSON.parse(kr(r, $r)));
              } catch (t) {
                Zr(!1, "Invalid JSON");
              }
              this._o = Object.create(Lr({}, n));
            }
            var e,
              n,
              i,
              r = t.prototype;
            return (
              (r.mount = function (t, e) {
                var n = this,
                  i = this.state,
                  r = this.Components;
                return (
                  Zr(i.is([1, 7]), "Already mounted!"),
                  i.set(1),
                  (this._C = r),
                  (this._T = e || this._T || (this.is(zo) ? ea : na)),
                  (this._E = t || this._E),
                  Rr(
                    Cr({}, Qo, this._E, {
                      Transition: this._T,
                    }),
                    function (t, e) {
                      var i = t(n, r, n._o);
                      (r[e] = i), i.setup && i.setup();
                    }
                  ),
                  Rr(r, function (t) {
                    t.mount && t.mount();
                  }),
                  this.emit(ds),
                  br(this.root, Mo),
                  i.set(3),
                  this.emit(ps),
                  this
                );
              }),
              (r.sync = function (t) {
                return (
                  this.splides.push({
                    splide: t,
                  }),
                  t.splides.push({
                    splide: this,
                    isParent: !0,
                  }),
                  this.state.is(3) &&
                    (this._C.Sync.remount(), t.Components.Sync.remount()),
                  this
                );
              }),
              (r.go = function (t) {
                return this._C.Controller.go(t), this;
              }),
              (r.on = function (t, e) {
                return this.event.on(t, e), this;
              }),
              (r.off = function (t) {
                return this.event.off(t), this;
              }),
              (r.emit = function (t) {
                var e;
                return (
                  (e = this.event).emit.apply(e, [t].concat(ir(arguments, 1))),
                  this
                );
              }),
              (r.add = function (t, e) {
                return this._C.Slides.add(t, e), this;
              }),
              (r.remove = function (t) {
                return this._C.Slides.remove(t), this;
              }),
              (r.is = function (t) {
                return this._o.type === t;
              }),
              (r.refresh = function () {
                return this.emit(bs), this;
              }),
              (r.destroy = function (t) {
                void 0 === t && (t = !0);
                var e = this.event,
                  n = this.state;
                return (
                  n.is(1)
                    ? Us(this).on(ps, this.destroy.bind(this, t))
                    : (Rr(
                        this._C,
                        function (e) {
                          e.destroy && e.destroy(t);
                        },
                        !0
                      ),
                      e.emit(As),
                      e.destroy(),
                      t && nr(this.splides),
                      n.set(7)),
                  this
                );
              }),
              (e = t),
              (n = [
                {
                  key: "options",
                  get: function () {
                    return this._o;
                  },
                  set: function (t) {
                    this._C.Media.set(t, !0, !0);
                  },
                },
                {
                  key: "length",
                  get: function () {
                    return this._C.Slides.getLength(!0);
                  },
                },
                {
                  key: "index",
                  get: function () {
                    return this._C.Controller.getIndex();
                  },
                },
              ]) && Zi(e.prototype, n),
              i && Zi(e, i),
              Object.defineProperty(e, "prototype", {
                writable: !1,
              }),
              t
            );
          })(),
          ra = ia;
        (ra.defaults = {}), (ra.STATES = er);
        function sa(t, e, n) {
          return Array.prototype.slice.call(t, e, n);
        }
        function oa(t) {
          return t.bind.apply(t, [null].concat(sa(arguments, 1)));
        }
        function aa(t) {
          return requestAnimationFrame(t);
        }
        function la(t, e) {
          return typeof e === t;
        }
        var ca = Array.isArray;
        function ua(t) {
          return ca(t) ? t : [t];
        }
        function ha(t, e) {
          ua(t).forEach(e);
        }
        oa(la, "function"), oa(la, "string"), oa(la, "undefined");
        var da = Object.keys;
        function pa(t) {
          return (
            sa(arguments, 1).forEach(function (e) {
              !(function (t, e, n) {
                if (t) {
                  var i = da(t);
                  i = n ? i.reverse() : i;
                  for (var r = 0; r < i.length; r++) {
                    var s = i[r];
                    if ("__proto__" !== s && !1 === e(t[s], s)) break;
                  }
                }
              })(e, function (n, i) {
                t[i] = e[i];
              });
            }),
            t
          );
        }
        var fa = Math.min;
        var ma = "move",
          va = "moved",
          ya = "updated",
          _a = "drag",
          xa = "dragged",
          ba = "scroll",
          wa = "scrolled",
          Ea = "destroy";
        function Sa(t) {
          var e = t ? t.event.bus : document.createDocumentFragment(),
            n = (function () {
              var t = [];
              function e(t, e, n) {
                ha(t, function (t) {
                  t &&
                    ha(e, function (e) {
                      e.split(" ").forEach(function (e) {
                        var i = e.split(".");
                        n(t, i[0], i[1]);
                      });
                    });
                });
              }
              return {
                bind: function (n, i, r, s) {
                  e(n, i, function (e, n, i) {
                    var o = "addEventListener" in e,
                      a = o
                        ? e.removeEventListener.bind(e, n, r, s)
                        : e.removeListener.bind(e, r);
                    o ? e.addEventListener(n, r, s) : e.addListener(r),
                      t.push([e, n, i, r, a]);
                  });
                },
                unbind: function (n, i, r) {
                  e(n, i, function (e, n, i) {
                    t = t.filter(function (t) {
                      return (
                        !!(
                          t[0] !== e ||
                          t[1] !== n ||
                          t[2] !== i ||
                          (r && t[3] !== r)
                        ) || (t[4](), !1)
                      );
                    });
                  });
                },
                dispatch: function (t, e, n) {
                  var i,
                    r = !0;
                  return (
                    "function" == typeof CustomEvent
                      ? (i = new CustomEvent(e, {
                          bubbles: r,
                          detail: n,
                        }))
                      : (i =
                          document.createEvent("CustomEvent")).initCustomEvent(
                          e,
                          r,
                          !1,
                          n
                        ),
                    t.dispatchEvent(i),
                    i
                  );
                },
                destroy: function () {
                  t.forEach(function (t) {
                    t[4]();
                  }),
                    (t.length = 0);
                },
              };
            })();
          return (
            t && t.event.on(Ea, n.destroy),
            pa(n, {
              bus: e,
              on: function (t, i) {
                n.bind(e, ua(t).join(" "), function (t) {
                  i.apply(i, ca(t.detail) ? t.detail : []);
                });
              },
              off: oa(n.unbind, e),
              emit: function (t) {
                n.dispatch(e, t, sa(arguments, 1));
              },
            })
          );
        }
        function Ma(t, e, n, i) {
          var r,
            s,
            o = Date.now,
            a = 0,
            l = !0,
            c = 0;
          function u() {
            if (!l) {
              if (
                ((a = t ? fa((o() - r) / t, 1) : 1),
                n && n(a),
                a >= 1 && (e(), (r = o()), i && ++c >= i))
              )
                return h();
              aa(u);
            }
          }
          function h() {
            l = !0;
          }
          function d() {
            s && cancelAnimationFrame(s), (a = 0), (s = 0), (l = !0);
          }
          return {
            start: function (e) {
              !e && d(), (r = o() - (e ? a * t : 0)), (l = !1), aa(u);
            },
            rewind: function () {
              (r = o()), (a = 0), n && n(a);
            },
            pause: h,
            cancel: d,
            set: function (e) {
              t = e;
            },
            isPaused: function () {
              return l;
            },
          };
        }
        var Ta = "slide";
        function Aa(t, e, n) {
          return Array.prototype.slice.call(t, e, n);
        }
        function Ra(t) {
          return t.bind(null, ...Aa(arguments, 1));
        }
        function Ca(t, e) {
          return typeof e === t;
        }
        function La(t) {
          return !Ia(t) && Ca("object", t);
        }
        const Pa = Array.isArray;
        Ra(Ca, "function"), Ra(Ca, "string");
        const Oa = Ra(Ca, "undefined");
        function Ia(t) {
          return null === t;
        }
        function Na(t, e) {
          var n;
          ((n = t), Pa(n) ? n : [n]).forEach(e);
        }
        const Da = Object.keys;
        function Ua(t, e, n) {
          if (t) {
            let i = Da(t);
            i = n ? i.reverse() : i;
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              if ("__proto__" !== r && !1 === e(t[r], r)) break;
            }
          }
          return t;
        }
        function Fa(t) {
          return (
            Aa(arguments, 1).forEach((e) => {
              Ua(e, (n, i) => {
                t[i] = e[i];
              });
            }),
            t
          );
        }
        function ka(t, e, n) {
          La(e)
            ? Ua(e, (e, n) => {
                ka(t, n, e);
              })
            : Na(t, (t) => {
                Ia(n) || "" === n
                  ? (function (t, e) {
                      Na(t, (t) => {
                        Na(e, (e) => {
                          t && t.removeAttribute(e);
                        });
                      });
                    })(t, e)
                  : t.setAttribute(e, String(n));
              });
        }
        const { min: Ba, max: za, floor: Ha, ceil: Va, abs: Ga } = Math;
        const Wa = {
            speed: 1,
            autoStart: !0,
            pauseOnHover: !0,
            pauseOnFocus: !0,
          },
          ja = {
            startScroll: "Start auto scroll",
            pauseScroll: "Pause auto scroll",
          };
        function qa(t, e, n) {
          const { on: i, off: r, bind: s, unbind: o } = Sa(t),
            { translate: a, getPosition: l, toIndex: c, getLimit: u } = e.Move,
            { setIndex: h, getIndex: d } = e.Controller,
            { orient: p } = e.Direction,
            { toggle: f } = e.Elements,
            { Live: m } = e,
            { root: g } = t,
            v = (function (t, e) {
              var n;
              return function () {
                n ||
                  (n = Ma(
                    e || 0,
                    function () {
                      t(), (n = null);
                    },
                    null,
                    1
                  )).start();
              };
            })(e.Arrows.update, 500);
          let y,
            _,
            x,
            b,
            w,
            E,
            S = {};
          function M() {
            t.is("fade") ||
              y ||
              !1 === n.autoScroll ||
              ((y = Ma(0, P)),
              (function () {
                S.pauseOnHover &&
                  s(g, "mouseenter mouseleave", (t) => {
                    (x = "mouseenter" === t.type), L();
                  });
                S.pauseOnFocus &&
                  s(g, "focusin focusout", (t) => {
                    (b = "focusin" === t.type), L();
                  });
                S.useToggleButton &&
                  s(f, "click", () => {
                    _ ? R() : C();
                  });
                i(ya, A),
                  i([ma, _a, ba], () => {
                    (w = !0), C(!1);
                  }),
                  i([va, xa, wa], () => {
                    (w = !1), L();
                  });
              })(),
              S.autoStart &&
                ("complete" === document.readyState
                  ? R()
                  : s(window, "load", R)));
          }
          function T() {
            y &&
              (y.cancel(),
              (y = null),
              (E = void 0),
              r([ma, _a, ba, va, wa]),
              o(g, "mouseenter mouseleave focusin focusout"),
              o(f, "click"));
          }
          function A() {
            const { autoScroll: t } = n;
            !1 !== t ? ((S = Fa({}, S, La(t) ? t : {})), M()) : T(),
              y && !Oa(E) && a(E);
          }
          function R() {
            I() && (y.start(!0), m.disable(!0), (b = x = _ = !1), O());
          }
          function C(t = !0) {
            _ || ((_ = t), O(), I() || (y.pause(), m.disable(!1)));
          }
          function L() {
            _ || (x || b || w ? C(!1) : R());
          }
          function P() {
            const i = l(),
              r = (function (e) {
                const n = S.speed || 1;
                (e += p(n)),
                  t.is(Ta) &&
                    (e = (function (t, e, n) {
                      const i = Ba(e, n),
                        r = za(e, n);
                      return Ba(za(i, t), r);
                    })(e, u(!1), u(!0)));
                return e;
              })(i);
            i !== r
              ? (a(r),
                (function (i) {
                  const { length: r } = t,
                    s = (c(i) + r) % r;
                  s !== d() &&
                    (h(s),
                    e.Slides.update(),
                    e.Pagination.update(),
                    "nearby" === n.lazyLoad && e.LazyLoad.check());
                })((E = l())))
              : (C(!1),
                S.rewind && t.go(S.speed > 0 ? 0 : e.Controller.getEnd())),
              v();
          }
          function O() {
            if (f) {
              const r = _ ? "startScroll" : "pauseScroll";
              (e = "is-active"),
                (i = !_),
                (t = f) &&
                  Na(e, (e) => {
                    e && t.classList[i ? "add" : "remove"](e);
                  }),
                ka(f, "aria-label", n.i18n[r] || ja[r]);
            }
            var t, e, i;
          }
          function I() {
            return !y || y.isPaused();
          }
          return {
            setup: function () {
              const { autoScroll: t } = n;
              S = Fa({}, Wa, La(t) ? t : {});
            },
            mount: M,
            destroy: T,
            play: R,
            pause: C,
            isPaused: I,
          };
        }
        class Xa {
          constructor(t, e, n, i, r) {
            (this.tgt = t),
              (this.pp = e),
              (this.ps = n),
              (this.dir = i),
              (this.drag = r),
              (this.options = {
                type: "loop",
                arrows: !1,
                pauseOnHover: !1,
                pagination: !1,
                direction: this.dir,
                drag: this.drag,
                perPage: 1,
                padding: this.pp,
                breakpoints: {
                  768: {
                    perPage: 1,
                    padding: this.ps,
                  },
                },
                autoScroll: {
                  speed: 0.3,
                  pauseOnHover: !1,
                },
              });
          }
          init() {
            return this.bind();
          }
          bind() {
            this.carouselAction();
          }
          carouselAction() {
            (this.splide = new ra(this.tgt, this.options)),
              this.splide.mount({
                AutoScroll: qa,
              });
          }
        }
        class Ya {
          constructor(t, e, n) {
            (this.tgt = t),
              (this.arrow = this.tgt.querySelector(".splide__arrow--next")),
              (this.options = {
                focus: 0,
                perPage: 1,
                omitEnd: !0,
                arrows: !0,
                mediaQuery: "min",
                gap: n,
                breakpoints: {
                  769: {
                    destroy: e,
                  },
                },
              }),
              (this.config = {
                attributes: !0,
                attributeFilter: ["disabled"],
              });
          }
          init() {
            return this.bind();
          }
          bind() {
            this.carouselAction();
          }
          carouselAction() {
            const t = this;
            (this.splide = new ra(t.tgt, t.options)),
              this.splide.mount(),
              t.disabledObserve();
          }
          disabledObserve() {
            const t = this;
            (this.callback = function (e, n) {
              t.arrow.hasAttribute("disabled")
                ? t.tgt.parentElement.classList.add("--last-item")
                : t.tgt.parentElement.classList.remove("--last-item");
            }),
              (this.OBSERVER = new MutationObserver(this.callback)),
              this.OBSERVER.observe(t.arrow, t.config);
          }
        }
        function Ka(t, e) {
          for (var n = 0; n < e.length; n++) {
            var i = e[n];
            (i.enumerable = i.enumerable || !1),
              (i.configurable = !0),
              "value" in i && (i.writable = !0),
              Object.defineProperty(t, i.key, i);
          }
        }
        /*!
         * Observer 3.12.5
         * https://gsap.com
         *
         * @license Copyright 2008-2024, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var $a,
          Za,
          Ja,
          Qa,
          tl,
          el,
          nl,
          il,
          rl,
          sl,
          ol,
          al,
          ll,
          cl = function () {
            return (
              $a ||
              ("undefined" != typeof window &&
                ($a = window.gsap) &&
                $a.registerPlugin &&
                $a)
            );
          },
          ul = 1,
          hl = [],
          dl = [],
          pl = [],
          fl = Date.now,
          ml = function (t, e) {
            return e;
          },
          gl = function (t, e) {
            return ~pl.indexOf(t) && pl[pl.indexOf(t) + 1][e];
          },
          vl = function (t) {
            return !!~sl.indexOf(t);
          },
          yl = function (t, e, n, i, r) {
            return t.addEventListener(e, n, {
              passive: !1 !== i,
              capture: !!r,
            });
          },
          _l = function (t, e, n, i) {
            return t.removeEventListener(e, n, !!i);
          },
          xl = "scrollLeft",
          bl = "scrollTop",
          wl = function () {
            return (ol && ol.isPressed) || dl.cache++;
          },
          El = function (t, e) {
            var n = function n(i) {
              if (i || 0 === i) {
                ul && (Ja.history.scrollRestoration = "manual");
                var r = ol && ol.isPressed;
                (i = n.v = Math.round(i) || (ol && ol.iOS ? 1 : 0)),
                  t(i),
                  (n.cacheID = dl.cache),
                  r && ml("ss", i);
              } else
                (e || dl.cache !== n.cacheID || ml("ref")) &&
                  ((n.cacheID = dl.cache), (n.v = t()));
              return n.v + n.offset;
            };
            return (n.offset = 0), t && n;
          },
          Sl = {
            s: xl,
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: El(function (t) {
              return arguments.length
                ? Ja.scrollTo(t, Ml.sc())
                : Ja.pageXOffset || Qa[xl] || tl[xl] || el[xl] || 0;
            }),
          },
          Ml = {
            s: bl,
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: Sl,
            sc: El(function (t) {
              return arguments.length
                ? Ja.scrollTo(Sl.sc(), t)
                : Ja.pageYOffset || Qa[bl] || tl[bl] || el[bl] || 0;
            }),
          },
          Tl = function (t, e) {
            return (
              ((e && e._ctx && e._ctx.selector) || $a.utils.toArray)(t)[0] ||
              ("string" == typeof t && !1 !== $a.config().nullTargetWarn
                ? console.warn("Element not found:", t)
                : null)
            );
          },
          Al = function (t, e) {
            var n = e.s,
              i = e.sc;
            vl(t) && (t = Qa.scrollingElement || tl);
            var r = dl.indexOf(t),
              s = i === Ml.sc ? 1 : 2;
            !~r && (r = dl.push(t) - 1), dl[r + s] || yl(t, "scroll", wl);
            var o = dl[r + s],
              a =
                o ||
                (dl[r + s] =
                  El(gl(t, n), !0) ||
                  (vl(t)
                    ? i
                    : El(function (e) {
                        return arguments.length ? (t[n] = e) : t[n];
                      })));
            return (
              (a.target = t),
              o ||
                (a.smooth = "smooth" === $a.getProperty(t, "scrollBehavior")),
              a
            );
          },
          Rl = function (t, e, n) {
            var i = t,
              r = t,
              s = fl(),
              o = s,
              a = e || 50,
              l = Math.max(500, 3 * a),
              c = function (t, e) {
                var l = fl();
                e || l - s > a
                  ? ((r = i), (i = t), (o = s), (s = l))
                  : n
                  ? (i += t)
                  : (i = r + ((t - r) / (l - o)) * (s - o));
              };
            return {
              update: c,
              reset: function () {
                (r = i = n ? 0 : i), (o = s = 0);
              },
              getVelocity: function (t) {
                var e = o,
                  a = r,
                  u = fl();
                return (
                  (t || 0 === t) && t !== i && c(t),
                  s === o || u - o > l
                    ? 0
                    : ((i + (n ? a : -a)) / ((n ? u : s) - e)) * 1e3
                );
              },
            };
          },
          Cl = function (t, e) {
            return (
              e && !t._gsapAllow && t.preventDefault(),
              t.changedTouches ? t.changedTouches[0] : t
            );
          },
          Ll = function (t) {
            var e = Math.max.apply(Math, t),
              n = Math.min.apply(Math, t);
            return Math.abs(e) >= Math.abs(n) ? e : n;
          },
          Pl = function () {
            var t, e, n, i;
            (rl = $a.core.globals().ScrollTrigger) &&
              rl.core &&
              ((t = rl.core),
              (e = t.bridge || {}),
              (n = t._scrollers),
              (i = t._proxies),
              n.push.apply(n, dl),
              i.push.apply(i, pl),
              (dl = n),
              (pl = i),
              (ml = function (t, n) {
                return e[t](n);
              }));
          },
          Ol = function (t) {
            return (
              ($a = t || cl()),
              !Za &&
                $a &&
                "undefined" != typeof document &&
                document.body &&
                ((Ja = window),
                (Qa = document),
                (tl = Qa.documentElement),
                (el = Qa.body),
                (sl = [Ja, Qa, tl, el]),
                $a.utils.clamp,
                (ll = $a.core.context || function () {}),
                (il = "onpointerenter" in el ? "pointer" : "mouse"),
                (nl = Il.isTouch =
                  Ja.matchMedia &&
                  Ja.matchMedia("(hover: none), (pointer: coarse)").matches
                    ? 1
                    : "ontouchstart" in Ja ||
                      navigator.maxTouchPoints > 0 ||
                      navigator.msMaxTouchPoints > 0
                    ? 2
                    : 0),
                (al = Il.eventTypes =
                  (
                    "ontouchstart" in tl
                      ? "touchstart,touchmove,touchcancel,touchend"
                      : "onpointerdown" in tl
                      ? "pointerdown,pointermove,pointercancel,pointerup"
                      : "mousedown,mousemove,mouseup,mouseup"
                  ).split(",")),
                setTimeout(function () {
                  return (ul = 0);
                }, 500),
                Pl(),
                (Za = 1)),
              Za
            );
          };
        (Sl.op = Ml), (dl.cache = 0);
        var Il = (function () {
          function t(t) {
            this.init(t);
          }
          var e, n, i;
          return (
            (t.prototype.init = function (t) {
              Za ||
                Ol($a) ||
                console.warn("Please gsap.registerPlugin(Observer)"),
                rl || Pl();
              var e = t.tolerance,
                n = t.dragMinimum,
                i = t.type,
                r = t.target,
                s = t.lineHeight,
                o = t.debounce,
                a = t.preventDefault,
                l = t.onStop,
                c = t.onStopDelay,
                u = t.ignore,
                h = t.wheelSpeed,
                d = t.event,
                p = t.onDragStart,
                f = t.onDragEnd,
                m = t.onDrag,
                g = t.onPress,
                v = t.onRelease,
                y = t.onRight,
                _ = t.onLeft,
                x = t.onUp,
                b = t.onDown,
                w = t.onChangeX,
                E = t.onChangeY,
                S = t.onChange,
                M = t.onToggleX,
                T = t.onToggleY,
                A = t.onHover,
                R = t.onHoverEnd,
                C = t.onMove,
                L = t.ignoreCheck,
                P = t.isNormalizer,
                O = t.onGestureStart,
                I = t.onGestureEnd,
                N = t.onWheel,
                D = t.onEnable,
                U = t.onDisable,
                F = t.onClick,
                k = t.scrollSpeed,
                B = t.capture,
                z = t.allowClicks,
                H = t.lockAxis,
                V = t.onLockAxis;
              (this.target = r = Tl(r) || tl),
                (this.vars = t),
                u && (u = $a.utils.toArray(u)),
                (e = e || 1e-9),
                (n = n || 0),
                (h = h || 1),
                (k = k || 1),
                (i = i || "wheel,touch,pointer"),
                (o = !1 !== o),
                s || (s = parseFloat(Ja.getComputedStyle(el).lineHeight) || 22);
              var G,
                W,
                j,
                q,
                X,
                Y,
                K,
                $ = this,
                Z = 0,
                J = 0,
                Q = t.passive || !a,
                tt = Al(r, Sl),
                et = Al(r, Ml),
                nt = tt(),
                it = et(),
                rt =
                  ~i.indexOf("touch") &&
                  !~i.indexOf("pointer") &&
                  "pointerdown" === al[0],
                st = vl(r),
                ot = r.ownerDocument || Qa,
                at = [0, 0, 0],
                lt = [0, 0, 0],
                ct = 0,
                ut = function () {
                  return (ct = fl());
                },
                ht = function (t, e) {
                  return (
                    (($.event = t) && u && ~u.indexOf(t.target)) ||
                    (e && rt && "touch" !== t.pointerType) ||
                    (L && L(t, e))
                  );
                },
                dt = function () {
                  var t = ($.deltaX = Ll(at)),
                    n = ($.deltaY = Ll(lt)),
                    i = Math.abs(t) >= e,
                    r = Math.abs(n) >= e;
                  S && (i || r) && S($, t, n, at, lt),
                    i &&
                      (y && $.deltaX > 0 && y($),
                      _ && $.deltaX < 0 && _($),
                      w && w($),
                      M && $.deltaX < 0 != Z < 0 && M($),
                      (Z = $.deltaX),
                      (at[0] = at[1] = at[2] = 0)),
                    r &&
                      (b && $.deltaY > 0 && b($),
                      x && $.deltaY < 0 && x($),
                      E && E($),
                      T && $.deltaY < 0 != J < 0 && T($),
                      (J = $.deltaY),
                      (lt[0] = lt[1] = lt[2] = 0)),
                    (q || j) && (C && C($), j && (m($), (j = !1)), (q = !1)),
                    Y && !(Y = !1) && V && V($),
                    X && (N($), (X = !1)),
                    (G = 0);
                },
                pt = function (t, e, n) {
                  (at[n] += t),
                    (lt[n] += e),
                    $._vx.update(t),
                    $._vy.update(e),
                    o ? G || (G = requestAnimationFrame(dt)) : dt();
                },
                ft = function (t, e) {
                  H &&
                    !K &&
                    (($.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y"),
                    (Y = !0)),
                    "y" !== K && ((at[2] += t), $._vx.update(t, !0)),
                    "x" !== K && ((lt[2] += e), $._vy.update(e, !0)),
                    o ? G || (G = requestAnimationFrame(dt)) : dt();
                },
                mt = function (t) {
                  if (!ht(t, 1)) {
                    var e = (t = Cl(t, a)).clientX,
                      i = t.clientY,
                      r = e - $.x,
                      s = i - $.y,
                      o = $.isDragging;
                    ($.x = e),
                      ($.y = i),
                      (o ||
                        Math.abs($.startX - e) >= n ||
                        Math.abs($.startY - i) >= n) &&
                        (m && (j = !0),
                        o || ($.isDragging = !0),
                        ft(r, s),
                        o || (p && p($)));
                  }
                },
                gt = ($.onPress = function (t) {
                  ht(t, 1) ||
                    (t && t.button) ||
                    (($.axis = K = null),
                    W.pause(),
                    ($.isPressed = !0),
                    (t = Cl(t)),
                    (Z = J = 0),
                    ($.startX = $.x = t.clientX),
                    ($.startY = $.y = t.clientY),
                    $._vx.reset(),
                    $._vy.reset(),
                    yl(P ? r : ot, al[1], mt, Q, !0),
                    ($.deltaX = $.deltaY = 0),
                    g && g($));
                }),
                vt = ($.onRelease = function (t) {
                  if (!ht(t, 1)) {
                    _l(P ? r : ot, al[1], mt, !0);
                    var e = !isNaN($.y - $.startY),
                      n = $.isDragging,
                      i =
                        n &&
                        (Math.abs($.x - $.startX) > 3 ||
                          Math.abs($.y - $.startY) > 3),
                      s = Cl(t);
                    !i &&
                      e &&
                      ($._vx.reset(),
                      $._vy.reset(),
                      a &&
                        z &&
                        $a.delayedCall(0.08, function () {
                          if (fl() - ct > 300 && !t.defaultPrevented)
                            if (t.target.click) t.target.click();
                            else if (ot.createEvent) {
                              var e = ot.createEvent("MouseEvents");
                              e.initMouseEvent(
                                "click",
                                !0,
                                !0,
                                Ja,
                                1,
                                s.screenX,
                                s.screenY,
                                s.clientX,
                                s.clientY,
                                !1,
                                !1,
                                !1,
                                !1,
                                0,
                                null
                              ),
                                t.target.dispatchEvent(e);
                            }
                        })),
                      ($.isDragging = $.isGesturing = $.isPressed = !1),
                      l && n && !P && W.restart(!0),
                      f && n && f($),
                      v && v($, i);
                  }
                }),
                yt = function (t) {
                  return (
                    t.touches &&
                    t.touches.length > 1 &&
                    ($.isGesturing = !0) &&
                    O(t, $.isDragging)
                  );
                },
                _t = function () {
                  return ($.isGesturing = !1) || I($);
                },
                xt = function (t) {
                  if (!ht(t)) {
                    var e = tt(),
                      n = et();
                    pt((e - nt) * k, (n - it) * k, 1),
                      (nt = e),
                      (it = n),
                      l && W.restart(!0);
                  }
                },
                bt = function (t) {
                  if (!ht(t)) {
                    (t = Cl(t, a)), N && (X = !0);
                    var e =
                      (1 === t.deltaMode
                        ? s
                        : 2 === t.deltaMode
                        ? Ja.innerHeight
                        : 1) * h;
                    pt(t.deltaX * e, t.deltaY * e, 0), l && !P && W.restart(!0);
                  }
                },
                wt = function (t) {
                  if (!ht(t)) {
                    var e = t.clientX,
                      n = t.clientY,
                      i = e - $.x,
                      r = n - $.y;
                    ($.x = e),
                      ($.y = n),
                      (q = !0),
                      l && W.restart(!0),
                      (i || r) && ft(i, r);
                  }
                },
                Et = function (t) {
                  ($.event = t), A($);
                },
                St = function (t) {
                  ($.event = t), R($);
                },
                Mt = function (t) {
                  return ht(t) || (Cl(t, a) && F($));
                };
              (W = $._dc =
                $a
                  .delayedCall(c || 0.25, function () {
                    $._vx.reset(), $._vy.reset(), W.pause(), l && l($);
                  })
                  .pause()),
                ($.deltaX = $.deltaY = 0),
                ($._vx = Rl(0, 50, !0)),
                ($._vy = Rl(0, 50, !0)),
                ($.scrollX = tt),
                ($.scrollY = et),
                ($.isDragging = $.isGesturing = $.isPressed = !1),
                ll(this),
                ($.enable = function (t) {
                  return (
                    $.isEnabled ||
                      (yl(st ? ot : r, "scroll", wl),
                      i.indexOf("scroll") >= 0 &&
                        yl(st ? ot : r, "scroll", xt, Q, B),
                      i.indexOf("wheel") >= 0 && yl(r, "wheel", bt, Q, B),
                      ((i.indexOf("touch") >= 0 && nl) ||
                        i.indexOf("pointer") >= 0) &&
                        (yl(r, al[0], gt, Q, B),
                        yl(ot, al[2], vt),
                        yl(ot, al[3], vt),
                        z && yl(r, "click", ut, !0, !0),
                        F && yl(r, "click", Mt),
                        O && yl(ot, "gesturestart", yt),
                        I && yl(ot, "gestureend", _t),
                        A && yl(r, il + "enter", Et),
                        R && yl(r, il + "leave", St),
                        C && yl(r, il + "move", wt)),
                      ($.isEnabled = !0),
                      t && t.type && gt(t),
                      D && D($)),
                    $
                  );
                }),
                ($.disable = function () {
                  $.isEnabled &&
                    (hl.filter(function (t) {
                      return t !== $ && vl(t.target);
                    }).length || _l(st ? ot : r, "scroll", wl),
                    $.isPressed &&
                      ($._vx.reset(),
                      $._vy.reset(),
                      _l(P ? r : ot, al[1], mt, !0)),
                    _l(st ? ot : r, "scroll", xt, B),
                    _l(r, "wheel", bt, B),
                    _l(r, al[0], gt, B),
                    _l(ot, al[2], vt),
                    _l(ot, al[3], vt),
                    _l(r, "click", ut, !0),
                    _l(r, "click", Mt),
                    _l(ot, "gesturestart", yt),
                    _l(ot, "gestureend", _t),
                    _l(r, il + "enter", Et),
                    _l(r, il + "leave", St),
                    _l(r, il + "move", wt),
                    ($.isEnabled = $.isPressed = $.isDragging = !1),
                    U && U($));
                }),
                ($.kill = $.revert =
                  function () {
                    $.disable();
                    var t = hl.indexOf($);
                    t >= 0 && hl.splice(t, 1), ol === $ && (ol = 0);
                  }),
                hl.push($),
                P && vl(r) && (ol = $),
                $.enable(d);
            }),
            (e = t),
            (n = [
              {
                key: "velocityX",
                get: function () {
                  return this._vx.getVelocity();
                },
              },
              {
                key: "velocityY",
                get: function () {
                  return this._vy.getVelocity();
                },
              },
            ]) && Ka(e.prototype, n),
            i && Ka(e, i),
            t
          );
        })();
        (Il.version = "3.12.5"),
          (Il.create = function (t) {
            return new Il(t);
          }),
          (Il.register = Ol),
          (Il.getAll = function () {
            return hl.slice();
          }),
          (Il.getById = function (t) {
            return hl.filter(function (e) {
              return e.vars.id === t;
            })[0];
          }),
          cl() && $a.registerPlugin(Il);
        /*!
         * ScrollTrigger 3.12.5
         * https://gsap.com
         *
         * @license Copyright 2008-2024, GreenSock. All rights reserved.
         * Subject to the terms at https://gsap.com/standard-license or for
         * Club GSAP members, the agreement issued with that membership.
         * @author: Jack Doyle, jack@greensock.com
         */
        var Nl,
          Dl,
          Ul,
          Fl,
          kl,
          Bl,
          zl,
          Hl,
          Vl,
          Gl,
          Wl,
          jl,
          ql,
          Xl,
          Yl,
          Kl,
          $l,
          Zl,
          Jl,
          Ql,
          tc,
          ec,
          nc,
          ic,
          rc,
          sc,
          oc,
          ac,
          lc,
          cc,
          uc,
          hc,
          dc,
          pc,
          fc,
          mc,
          gc,
          vc,
          yc = 1,
          _c = Date.now,
          xc = _c(),
          bc = 0,
          wc = 0,
          Ec = function (t, e, n) {
            var i =
              Fc(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
            return (
              (n["_" + e + "Clamp"] = i), i ? t.substr(6, t.length - 7) : t
            );
          },
          Sc = function (t, e) {
            return !e || (Fc(t) && "clamp(" === t.substr(0, 6))
              ? t
              : "clamp(" + t + ")";
          },
          Mc = function t() {
            return wc && requestAnimationFrame(t);
          },
          Tc = function () {
            return (Xl = 1);
          },
          Ac = function () {
            return (Xl = 0);
          },
          Rc = function (t) {
            return t;
          },
          Cc = function (t) {
            return Math.round(1e5 * t) / 1e5 || 0;
          },
          Lc = function () {
            return "undefined" != typeof window;
          },
          Pc = function () {
            return (
              Nl || (Lc() && (Nl = window.gsap) && Nl.registerPlugin && Nl)
            );
          },
          Oc = function (t) {
            return !!~zl.indexOf(t);
          },
          Ic = function (t) {
            return (
              ("Height" === t ? uc : Ul["inner" + t]) ||
              kl["client" + t] ||
              Bl["client" + t]
            );
          },
          Nc = function (t) {
            return (
              gl(t, "getBoundingClientRect") ||
              (Oc(t)
                ? function () {
                    return (Xu.width = Ul.innerWidth), (Xu.height = uc), Xu;
                  }
                : function () {
                    return ou(t);
                  })
            );
          },
          Dc = function (t, e) {
            var n = e.s,
              i = e.d2,
              r = e.d,
              s = e.a;
            return Math.max(
              0,
              (n = "scroll" + i) && (s = gl(t, n))
                ? s() - Nc(t)()[r]
                : Oc(t)
                ? (kl[n] || Bl[n]) - Ic(i)
                : t[n] - t["offset" + i]
            );
          },
          Uc = function (t, e) {
            for (var n = 0; n < Jl.length; n += 3)
              (!e || ~e.indexOf(Jl[n + 1])) && t(Jl[n], Jl[n + 1], Jl[n + 2]);
          },
          Fc = function (t) {
            return "string" == typeof t;
          },
          kc = function (t) {
            return "function" == typeof t;
          },
          Bc = function (t) {
            return "number" == typeof t;
          },
          zc = function (t) {
            return "object" == typeof t;
          },
          Hc = function (t, e, n) {
            return t && t.progress(e ? 0 : 1) && n && t.pause();
          },
          Vc = function (t, e) {
            if (t.enabled) {
              var n = t._ctx
                ? t._ctx.add(function () {
                    return e(t);
                  })
                : e(t);
              n && n.totalTime && (t.callbackAnimation = n);
            }
          },
          Gc = Math.abs,
          Wc = "left",
          jc = "right",
          qc = "bottom",
          Xc = "width",
          Yc = "height",
          Kc = "Right",
          $c = "Left",
          Zc = "Top",
          Jc = "Bottom",
          Qc = "padding",
          tu = "margin",
          eu = "Width",
          nu = "Height",
          iu = "px",
          ru = function (t) {
            return Ul.getComputedStyle(t);
          },
          su = function (t, e) {
            for (var n in e) n in t || (t[n] = e[n]);
            return t;
          },
          ou = function (t, e) {
            var n =
                e &&
                "matrix(1, 0, 0, 1, 0, 0)" !== ru(t)[Yl] &&
                Nl.to(t, {
                  x: 0,
                  y: 0,
                  xPercent: 0,
                  yPercent: 0,
                  rotation: 0,
                  rotationX: 0,
                  rotationY: 0,
                  scale: 1,
                  skewX: 0,
                  skewY: 0,
                }).progress(1),
              i = t.getBoundingClientRect();
            return n && n.progress(0).kill(), i;
          },
          au = function (t, e) {
            var n = e.d2;
            return t["offset" + n] || t["client" + n] || 0;
          },
          lu = function (t) {
            var e,
              n = [],
              i = t.labels,
              r = t.duration();
            for (e in i) n.push(i[e] / r);
            return n;
          },
          cu = function (t) {
            var e = Nl.utils.snap(t),
              n =
                Array.isArray(t) &&
                t.slice(0).sort(function (t, e) {
                  return t - e;
                });
            return n
              ? function (t, i, r) {
                  var s;
                  if ((void 0 === r && (r = 0.001), !i)) return e(t);
                  if (i > 0) {
                    for (t -= r, s = 0; s < n.length; s++)
                      if (n[s] >= t) return n[s];
                    return n[s - 1];
                  }
                  for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s];
                  return n[0];
                }
              : function (n, i, r) {
                  void 0 === r && (r = 0.001);
                  var s = e(n);
                  return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
                    ? s
                    : e(i < 0 ? n - t : n + t);
                };
          },
          uu = function (t, e, n, i) {
            return n.split(",").forEach(function (n) {
              return t(e, n, i);
            });
          },
          hu = function (t, e, n, i, r) {
            return t.addEventListener(e, n, {
              passive: !i,
              capture: !!r,
            });
          },
          du = function (t, e, n, i) {
            return t.removeEventListener(e, n, !!i);
          },
          pu = function (t, e, n) {
            (n = n && n.wheelHandler) &&
              (t(e, "wheel", n), t(e, "touchmove", n));
          },
          fu = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal",
          },
          mu = {
            toggleActions: "play",
            anticipatePin: 0,
          },
          gu = {
            top: 0,
            left: 0,
            center: 0.5,
            bottom: 1,
            right: 1,
          },
          vu = function (t, e) {
            if (Fc(t)) {
              var n = t.indexOf("="),
                i = ~n
                  ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1))
                  : 0;
              ~n &&
                (t.indexOf("%") > n && (i *= e / 100),
                (t = t.substr(0, n - 1))),
                (t =
                  i +
                  (t in gu
                    ? gu[t] * e
                    : ~t.indexOf("%")
                    ? (parseFloat(t) * e) / 100
                    : parseFloat(t) || 0));
            }
            return t;
          },
          yu = function (t, e, n, i, r, s, o, a) {
            var l = r.startColor,
              c = r.endColor,
              u = r.fontSize,
              h = r.indent,
              d = r.fontWeight,
              p = Fl.createElement("div"),
              f = Oc(n) || "fixed" === gl(n, "pinType"),
              m = -1 !== t.indexOf("scroller"),
              g = f ? Bl : n,
              v = -1 !== t.indexOf("start"),
              y = v ? l : c,
              _ =
                "border-color:" +
                y +
                ";font-size:" +
                u +
                ";color:" +
                y +
                ";font-weight:" +
                d +
                ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return (
              (_ += "position:" + ((m || a) && f ? "fixed;" : "absolute;")),
              (m || a || !f) &&
                (_ += (i === Ml ? jc : qc) + ":" + (s + parseFloat(h)) + "px;"),
              o &&
                (_ +=
                  "box-sizing:border-box;text-align:left;width:" +
                  o.offsetWidth +
                  "px;"),
              (p._isStart = v),
              p.setAttribute(
                "class",
                "gsap-marker-" + t + (e ? " marker-" + e : "")
              ),
              (p.style.cssText = _),
              (p.innerText = e || 0 === e ? t + "-" + e : t),
              g.children[0]
                ? g.insertBefore(p, g.children[0])
                : g.appendChild(p),
              (p._offset = p["offset" + i.op.d2]),
              _u(p, 0, i, v),
              p
            );
          },
          _u = function (t, e, n, i) {
            var r = {
                display: "block",
              },
              s = n[i ? "os2" : "p2"],
              o = n[i ? "p2" : "os2"];
            (t._isFlipped = i),
              (r[n.a + "Percent"] = i ? -100 : 0),
              (r[n.a] = i ? "1px" : 0),
              (r["border" + s + eu] = 1),
              (r["border" + o + eu] = 0),
              (r[n.p] = e + "px"),
              Nl.set(t, r);
          },
          xu = [],
          bu = {},
          wu = function () {
            return _c() - bc > 34 && (fc || (fc = requestAnimationFrame(zu)));
          },
          Eu = function () {
            (!nc || !nc.isPressed || nc.startX > Bl.clientWidth) &&
              (dl.cache++,
              nc ? fc || (fc = requestAnimationFrame(zu)) : zu(),
              bc || Cu("scrollStart"),
              (bc = _c()));
          },
          Su = function () {
            (sc = Ul.innerWidth), (rc = Ul.innerHeight);
          },
          Mu = function () {
            dl.cache++,
              !ql &&
                !ec &&
                !Fl.fullscreenElement &&
                !Fl.webkitFullscreenElement &&
                (!ic ||
                  sc !== Ul.innerWidth ||
                  Math.abs(Ul.innerHeight - rc) > 0.25 * Ul.innerHeight) &&
                Hl.restart(!0);
          },
          Tu = {},
          Au = [],
          Ru = function t() {
            return du(th, "scrollEnd", t) || Fu(!0);
          },
          Cu = function (t) {
            return (
              (Tu[t] &&
                Tu[t].map(function (t) {
                  return t();
                })) ||
              Au
            );
          },
          Lu = [],
          Pu = function (t) {
            for (var e = 0; e < Lu.length; e += 5)
              (!t || (Lu[e + 4] && Lu[e + 4].query === t)) &&
                ((Lu[e].style.cssText = Lu[e + 1]),
                Lu[e].getBBox &&
                  Lu[e].setAttribute("transform", Lu[e + 2] || ""),
                (Lu[e + 3].uncache = 1));
          },
          Ou = function (t, e) {
            var n;
            for (Kl = 0; Kl < xu.length; Kl++)
              !(n = xu[Kl]) ||
                (e && n._ctx !== e) ||
                (t ? n.kill(1) : n.revert(!0, !0));
            (hc = !0), e && Pu(e), e || Cu("revert");
          },
          Iu = function (t, e) {
            dl.cache++,
              (e || !mc) &&
                dl.forEach(function (t) {
                  return kc(t) && t.cacheID++ && (t.rec = 0);
                }),
              Fc(t) && (Ul.history.scrollRestoration = lc = t);
          },
          Nu = 0,
          Du = function () {
            Bl.appendChild(cc),
              (uc = (!nc && cc.offsetHeight) || Ul.innerHeight),
              Bl.removeChild(cc);
          },
          Uu = function (t) {
            return Vl(
              ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
            ).forEach(function (e) {
              return (e.style.display = t ? "none" : "block");
            });
          },
          Fu = function (t, e) {
            if (!bc || t || hc) {
              Du(),
                (mc = th.isRefreshing = !0),
                dl.forEach(function (t) {
                  return kc(t) && ++t.cacheID && (t.rec = t());
                });
              var n = Cu("refreshInit");
              Ql && th.sort(),
                e || Ou(),
                dl.forEach(function (t) {
                  kc(t) &&
                    (t.smooth && (t.target.style.scrollBehavior = "auto"),
                    t(0));
                }),
                xu.slice(0).forEach(function (t) {
                  return t.refresh();
                }),
                (hc = !1),
                xu.forEach(function (t) {
                  if (t._subPinOffset && t.pin) {
                    var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                      n = t.pin[e];
                    t.revert(!0, 1),
                      t.adjustPinSpacing(t.pin[e] - n),
                      t.refresh();
                  }
                }),
                (dc = 1),
                Uu(!0),
                xu.forEach(function (t) {
                  var e = Dc(t.scroller, t._dir),
                    n = "max" === t.vars.end || (t._endClamp && t.end > e),
                    i = t._startClamp && t.start >= e;
                  (n || i) &&
                    t.setPositions(
                      i ? e - 1 : t.start,
                      n ? Math.max(i ? e : t.start + 1, e) : t.end,
                      !0
                    );
                }),
                Uu(!1),
                (dc = 0),
                n.forEach(function (t) {
                  return t && t.render && t.render(-1);
                }),
                dl.forEach(function (t) {
                  kc(t) &&
                    (t.smooth &&
                      requestAnimationFrame(function () {
                        return (t.target.style.scrollBehavior = "smooth");
                      }),
                    t.rec && t(t.rec));
                }),
                Iu(lc, 1),
                Hl.pause(),
                Nu++,
                (mc = 2),
                zu(2),
                xu.forEach(function (t) {
                  return kc(t.vars.onRefresh) && t.vars.onRefresh(t);
                }),
                (mc = th.isRefreshing = !1),
                Cu("refresh");
            } else hu(th, "scrollEnd", Ru);
          },
          ku = 0,
          Bu = 1,
          zu = function (t) {
            if (2 === t || (!mc && !hc)) {
              (th.isUpdating = !0), vc && vc.update(0);
              var e = xu.length,
                n = _c(),
                i = n - xc >= 50,
                r = e && xu[0].scroll();
              if (
                ((Bu = ku > r ? -1 : 1),
                mc || (ku = r),
                i &&
                  (bc && !Xl && n - bc > 200 && ((bc = 0), Cu("scrollEnd")),
                  (Wl = xc),
                  (xc = n)),
                Bu < 0)
              ) {
                for (Kl = e; Kl-- > 0; ) xu[Kl] && xu[Kl].update(0, i);
                Bu = 1;
              } else for (Kl = 0; Kl < e; Kl++) xu[Kl] && xu[Kl].update(0, i);
              th.isUpdating = !1;
            }
            fc = 0;
          },
          Hu = [
            Wc,
            "top",
            qc,
            jc,
            tu + Jc,
            tu + Kc,
            tu + Zc,
            tu + $c,
            "display",
            "flexShrink",
            "float",
            "zIndex",
            "gridColumnStart",
            "gridColumnEnd",
            "gridRowStart",
            "gridRowEnd",
            "gridArea",
            "justifySelf",
            "alignSelf",
            "placeSelf",
            "order",
          ],
          Vu = Hu.concat([
            Xc,
            Yc,
            "boxSizing",
            "max" + eu,
            "max" + nu,
            "position",
            tu,
            Qc,
            Qc + Zc,
            Qc + Kc,
            Qc + Jc,
            Qc + $c,
          ]),
          Gu = function (t, e, n, i) {
            if (!t._gsap.swappedIn) {
              for (var r, s = Hu.length, o = e.style, a = t.style; s--; )
                o[(r = Hu[s])] = n[r];
              (o.position =
                "absolute" === n.position ? "absolute" : "relative"),
                "inline" === n.display && (o.display = "inline-block"),
                (a[qc] = a[jc] = "auto"),
                (o.flexBasis = n.flexBasis || "auto"),
                (o.overflow = "visible"),
                (o.boxSizing = "border-box"),
                (o[Xc] = au(t, Sl) + iu),
                (o[Yc] = au(t, Ml) + iu),
                (o[Qc] = a[tu] = a.top = a[Wc] = "0"),
                ju(i),
                (a[Xc] = a["max" + eu] = n[Xc]),
                (a[Yc] = a["max" + nu] = n[Yc]),
                (a[Qc] = n[Qc]),
                t.parentNode !== e &&
                  (t.parentNode.insertBefore(e, t), e.appendChild(t)),
                (t._gsap.swappedIn = !0);
            }
          },
          Wu = /([A-Z])/g,
          ju = function (t) {
            if (t) {
              var e,
                n,
                i = t.t.style,
                r = t.length,
                s = 0;
              for (
                (t.t._gsap || Nl.core.getCache(t.t)).uncache = 1;
                s < r;
                s += 2
              )
                (n = t[s + 1]),
                  (e = t[s]),
                  n
                    ? (i[e] = n)
                    : i[e] &&
                      i.removeProperty(e.replace(Wu, "-$1").toLowerCase());
            }
          },
          qu = function (t) {
            for (var e = Vu.length, n = t.style, i = [], r = 0; r < e; r++)
              i.push(Vu[r], n[Vu[r]]);
            return (i.t = t), i;
          },
          Xu = {
            left: 0,
            top: 0,
          },
          Yu = function (t, e, n, i, r, s, o, a, l, c, u, h, d, p) {
            kc(t) && (t = t(a)),
              Fc(t) &&
                "max" === t.substr(0, 3) &&
                (t = h + ("=" === t.charAt(4) ? vu("0" + t.substr(3), n) : 0));
            var f,
              m,
              g,
              v = d ? d.time() : 0;
            if ((d && d.seek(0), isNaN(t) || (t = +t), Bc(t)))
              d &&
                (t = Nl.utils.mapRange(
                  d.scrollTrigger.start,
                  d.scrollTrigger.end,
                  0,
                  h,
                  t
                )),
                o && _u(o, n, i, !0);
            else {
              kc(e) && (e = e(a));
              var y,
                _,
                x,
                b,
                w = (t || "0").split(" ");
              (g = Tl(e, a) || Bl),
                ((y = ou(g) || {}) && (y.left || y.top)) ||
                  "none" !== ru(g).display ||
                  ((b = g.style.display),
                  (g.style.display = "block"),
                  (y = ou(g)),
                  b
                    ? (g.style.display = b)
                    : g.style.removeProperty("display")),
                (_ = vu(w[0], y[i.d])),
                (x = vu(w[1] || "0", n)),
                (t = y[i.p] - l[i.p] - c + _ + r - x),
                o && _u(o, x, i, n - x < 20 || (o._isStart && x > 20)),
                (n -= n - x);
            }
            if ((p && ((a[p] = t || -0.001), t < 0 && (t = 0)), s)) {
              var E = t + n,
                S = s._isStart;
              (f = "scroll" + i.d2),
                _u(
                  s,
                  E,
                  i,
                  (S && E > 20) ||
                    (!S &&
                      (u ? Math.max(Bl[f], kl[f]) : s.parentNode[f]) <= E + 1)
                ),
                u &&
                  ((l = ou(o)),
                  u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + iu));
            }
            return (
              d &&
                g &&
                ((f = ou(g)),
                d.seek(h),
                (m = ou(g)),
                (d._caScrollDist = f[i.p] - m[i.p]),
                (t = (t / d._caScrollDist) * h)),
              d && d.seek(v),
              d ? t : Math.round(t)
            );
          },
          Ku = /(webkit|moz|length|cssText|inset)/i,
          $u = function (t, e, n, i) {
            if (t.parentNode !== e) {
              var r,
                s,
                o = t.style;
              if (e === Bl) {
                for (r in ((t._stOrig = o.cssText), (s = ru(t))))
                  +r ||
                    Ku.test(r) ||
                    !s[r] ||
                    "string" != typeof o[r] ||
                    "0" === r ||
                    (o[r] = s[r]);
                (o.top = n), (o.left = i);
              } else o.cssText = t._stOrig;
              (Nl.core.getCache(t).uncache = 1), e.appendChild(t);
            }
          },
          Zu = function (t, e, n) {
            var i = e,
              r = i;
            return function (e) {
              var s = Math.round(t());
              return (
                s !== i &&
                  s !== r &&
                  Math.abs(s - i) > 3 &&
                  Math.abs(s - r) > 3 &&
                  ((e = s), n && n()),
                (r = i),
                (i = e),
                e
              );
            };
          },
          Ju = function (t, e, n) {
            var i = {};
            (i[e.p] = "+=" + n), Nl.set(t, i);
          },
          Qu = function (t, e) {
            var n = Al(t, e),
              i = "_scroll" + e.p2,
              r = function e(r, s, o, a, l) {
                var c = e.tween,
                  u = s.onComplete,
                  h = {};
                o = o || n();
                var d = Zu(n, o, function () {
                  c.kill(), (e.tween = 0);
                });
                return (
                  (l = (a && l) || 0),
                  (a = a || r - o),
                  c && c.kill(),
                  (s[i] = r),
                  (s.inherit = !1),
                  (s.modifiers = h),
                  (h[i] = function () {
                    return d(o + a * c.ratio + l * c.ratio * c.ratio);
                  }),
                  (s.onUpdate = function () {
                    dl.cache++, e.tween && zu();
                  }),
                  (s.onComplete = function () {
                    (e.tween = 0), u && u.call(c);
                  }),
                  (c = e.tween = Nl.to(t, s))
                );
              };
            return (
              (t[i] = n),
              (n.wheelHandler = function () {
                return r.tween && r.tween.kill() && (r.tween = 0);
              }),
              hu(t, "wheel", n.wheelHandler),
              th.isTouch && hu(t, "touchmove", n.wheelHandler),
              r
            );
          },
          th = (function () {
            function t(e, n) {
              Dl ||
                t.register(Nl) ||
                console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                ac(this),
                this.init(e, n);
            }
            return (
              (t.prototype.init = function (e, n) {
                if (
                  ((this.progress = this.start = 0),
                  this.vars && this.kill(!0, !0),
                  wc)
                ) {
                  var i,
                    r,
                    s,
                    o,
                    a,
                    l,
                    c,
                    u,
                    h,
                    d,
                    p,
                    f,
                    m,
                    g,
                    v,
                    y,
                    _,
                    x,
                    b,
                    w,
                    E,
                    S,
                    M,
                    T,
                    A,
                    R,
                    C,
                    L,
                    P,
                    O,
                    I,
                    N,
                    D,
                    U,
                    F,
                    k,
                    B,
                    z,
                    H,
                    V,
                    G,
                    W,
                    j = (e = su(
                      Fc(e) || Bc(e) || e.nodeType
                        ? {
                            trigger: e,
                          }
                        : e,
                      mu
                    )),
                    q = j.onUpdate,
                    X = j.toggleClass,
                    Y = j.id,
                    K = j.onToggle,
                    $ = j.onRefresh,
                    Z = j.scrub,
                    J = j.trigger,
                    Q = j.pin,
                    tt = j.pinSpacing,
                    et = j.invalidateOnRefresh,
                    nt = j.anticipatePin,
                    it = j.onScrubComplete,
                    rt = j.onSnapComplete,
                    st = j.once,
                    ot = j.snap,
                    at = j.pinReparent,
                    lt = j.pinSpacer,
                    ct = j.containerAnimation,
                    ut = j.fastScrollEnd,
                    ht = j.preventOverlaps,
                    dt =
                      e.horizontal ||
                      (e.containerAnimation && !1 !== e.horizontal)
                        ? Sl
                        : Ml,
                    pt = !Z && 0 !== Z,
                    ft = Tl(e.scroller || Ul),
                    mt = Nl.core.getCache(ft),
                    gt = Oc(ft),
                    vt =
                      "fixed" ===
                      ("pinType" in e
                        ? e.pinType
                        : gl(ft, "pinType") || (gt && "fixed")),
                    yt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                    _t = pt && e.toggleActions.split(" "),
                    xt = "markers" in e ? e.markers : mu.markers,
                    bt = gt
                      ? 0
                      : parseFloat(ru(ft)["border" + dt.p2 + eu]) || 0,
                    wt = this,
                    Et =
                      e.onRefreshInit &&
                      function () {
                        return e.onRefreshInit(wt);
                      },
                    St = (function (t, e, n) {
                      var i = n.d,
                        r = n.d2,
                        s = n.a;
                      return (s = gl(t, "getBoundingClientRect"))
                        ? function () {
                            return s()[i];
                          }
                        : function () {
                            return (e ? Ic(r) : t["client" + r]) || 0;
                          };
                    })(ft, gt, dt),
                    Mt = (function (t, e) {
                      return !e || ~pl.indexOf(t)
                        ? Nc(t)
                        : function () {
                            return Xu;
                          };
                    })(ft, gt),
                    Tt = 0,
                    At = 0,
                    Rt = 0,
                    Ct = Al(ft, dt);
                  if (
                    ((wt._startClamp = wt._endClamp = !1),
                    (wt._dir = dt),
                    (nt *= 45),
                    (wt.scroller = ft),
                    (wt.scroll = ct ? ct.time.bind(ct) : Ct),
                    (o = Ct()),
                    (wt.vars = e),
                    (n = n || e.animation),
                    "refreshPriority" in e &&
                      ((Ql = 1), -9999 === e.refreshPriority && (vc = wt)),
                    (mt.tweenScroll = mt.tweenScroll || {
                      top: Qu(ft, Ml),
                      left: Qu(ft, Sl),
                    }),
                    (wt.tweenTo = i = mt.tweenScroll[dt.p]),
                    (wt.scrubDuration = function (t) {
                      (D = Bc(t) && t)
                        ? N
                          ? N.duration(t)
                          : (N = Nl.to(n, {
                              ease: "expo",
                              totalProgress: "+=0",
                              inherit: !1,
                              duration: D,
                              paused: !0,
                              onComplete: function () {
                                return it && it(wt);
                              },
                            }))
                        : (N && N.progress(1).kill(), (N = 0));
                    }),
                    n &&
                      ((n.vars.lazy = !1),
                      (n._initted && !wt.isReverted) ||
                        (!1 !== n.vars.immediateRender &&
                          !1 !== e.immediateRender &&
                          n.duration() &&
                          n.render(0, !0, !0)),
                      (wt.animation = n.pause()),
                      (n.scrollTrigger = wt),
                      wt.scrubDuration(Z),
                      (O = 0),
                      Y || (Y = n.vars.id)),
                    ot &&
                      ((zc(ot) && !ot.push) ||
                        (ot = {
                          snapTo: ot,
                        }),
                      "scrollBehavior" in Bl.style &&
                        Nl.set(gt ? [Bl, kl] : ft, {
                          scrollBehavior: "auto",
                        }),
                      dl.forEach(function (t) {
                        return (
                          kc(t) &&
                          t.target === (gt ? Fl.scrollingElement || kl : ft) &&
                          (t.smooth = !1)
                        );
                      }),
                      (s = kc(ot.snapTo)
                        ? ot.snapTo
                        : "labels" === ot.snapTo
                        ? (function (t) {
                            return function (e) {
                              return Nl.utils.snap(lu(t), e);
                            };
                          })(n)
                        : "labelsDirectional" === ot.snapTo
                        ? ((V = n),
                          function (t, e) {
                            return cu(lu(V))(t, e.direction);
                          })
                        : !1 !== ot.directional
                        ? function (t, e) {
                            return cu(ot.snapTo)(
                              t,
                              _c() - At < 500 ? 0 : e.direction
                            );
                          }
                        : Nl.utils.snap(ot.snapTo)),
                      (U = ot.duration || {
                        min: 0.1,
                        max: 2,
                      }),
                      (U = zc(U) ? Gl(U.min, U.max) : Gl(U, U)),
                      (F = Nl.delayedCall(
                        ot.delay || D / 2 || 0.1,
                        function () {
                          var t = Ct(),
                            e = _c() - At < 500,
                            r = i.tween;
                          if (
                            !(e || Math.abs(wt.getVelocity()) < 10) ||
                            r ||
                            Xl ||
                            Tt === t
                          )
                            wt.isActive && Tt !== t && F.restart(!0);
                          else {
                            var o,
                              a,
                              u = (t - l) / g,
                              h = n && !pt ? n.totalProgress() : u,
                              d = e ? 0 : ((h - I) / (_c() - Wl)) * 1e3 || 0,
                              p = Nl.utils.clamp(
                                -u,
                                1 - u,
                                (Gc(d / 2) * d) / 0.185
                              ),
                              f = u + (!1 === ot.inertia ? 0 : p),
                              m = ot,
                              v = m.onStart,
                              y = m.onInterrupt,
                              _ = m.onComplete;
                            if (
                              ((o = s(f, wt)),
                              Bc(o) || (o = f),
                              (a = Math.round(l + o * g)),
                              t <= c && t >= l && a !== t)
                            ) {
                              if (r && !r._initted && r.data <= Gc(a - t))
                                return;
                              !1 === ot.inertia && (p = o - u),
                                i(
                                  a,
                                  {
                                    duration: U(
                                      Gc(
                                        (0.185 *
                                          Math.max(Gc(f - h), Gc(o - h))) /
                                          d /
                                          0.05 || 0
                                      )
                                    ),
                                    ease: ot.ease || "power3",
                                    data: Gc(a - t),
                                    onInterrupt: function () {
                                      return F.restart(!0) && y && y(wt);
                                    },
                                    onComplete: function () {
                                      wt.update(),
                                        (Tt = Ct()),
                                        n &&
                                          (N
                                            ? N.resetTo(
                                                "totalProgress",
                                                o,
                                                n._tTime / n._tDur
                                              )
                                            : n.progress(o)),
                                        (O = I =
                                          n && !pt
                                            ? n.totalProgress()
                                            : wt.progress),
                                        rt && rt(wt),
                                        _ && _(wt);
                                    },
                                  },
                                  t,
                                  p * g,
                                  a - t - p * g
                                ),
                                v && v(wt, i.tween);
                            }
                          }
                        }
                      ).pause())),
                    Y && (bu[Y] = wt),
                    (H =
                      (J = wt.trigger = Tl(J || (!0 !== Q && Q))) &&
                      J._gsap &&
                      J._gsap.stRevert) && (H = H(wt)),
                    (Q = !0 === Q ? J : Tl(Q)),
                    Fc(X) &&
                      (X = {
                        targets: J,
                        className: X,
                      }),
                    Q &&
                      (!1 === tt ||
                        tt === tu ||
                        (tt =
                          !(
                            !tt &&
                            Q.parentNode &&
                            Q.parentNode.style &&
                            "flex" === ru(Q.parentNode).display
                          ) && Qc),
                      (wt.pin = Q),
                      (r = Nl.core.getCache(Q)).spacer
                        ? (v = r.pinState)
                        : (lt &&
                            ((lt = Tl(lt)) &&
                              !lt.nodeType &&
                              (lt = lt.current || lt.nativeElement),
                            (r.spacerIsNative = !!lt),
                            lt && (r.spacerState = qu(lt))),
                          (r.spacer = x = lt || Fl.createElement("div")),
                          x.classList.add("pin-spacer"),
                          Y && x.classList.add("pin-spacer-" + Y),
                          (r.pinState = v = qu(Q))),
                      !1 !== e.force3D &&
                        Nl.set(Q, {
                          force3D: !0,
                        }),
                      (wt.spacer = x = r.spacer),
                      (P = ru(Q)),
                      (T = P[tt + dt.os2]),
                      (w = Nl.getProperty(Q)),
                      (E = Nl.quickSetter(Q, dt.a, iu)),
                      Gu(Q, x, P),
                      (_ = qu(Q))),
                    xt)
                  ) {
                    (f = zc(xt) ? su(xt, fu) : fu),
                      (d = yu("scroller-start", Y, ft, dt, f, 0)),
                      (p = yu("scroller-end", Y, ft, dt, f, 0, d)),
                      (b = d["offset" + dt.op.d2]);
                    var Lt = Tl(gl(ft, "content") || ft);
                    (u = this.markerStart =
                      yu("start", Y, Lt, dt, f, b, 0, ct)),
                      (h = this.markerEnd = yu("end", Y, Lt, dt, f, b, 0, ct)),
                      ct && (z = Nl.quickSetter([u, h], dt.a, iu)),
                      vt ||
                        (pl.length && !0 === gl(ft, "fixedMarkers")) ||
                        ((W = ru((G = gt ? Bl : ft)).position),
                        (G.style.position =
                          "absolute" === W || "fixed" === W ? W : "relative"),
                        Nl.set([d, p], {
                          force3D: !0,
                        }),
                        (R = Nl.quickSetter(d, dt.a, iu)),
                        (L = Nl.quickSetter(p, dt.a, iu)));
                  }
                  if (ct) {
                    var Pt = ct.vars.onUpdate,
                      Ot = ct.vars.onUpdateParams;
                    ct.eventCallback("onUpdate", function () {
                      wt.update(0, 0, 1), Pt && Pt.apply(ct, Ot || []);
                    });
                  }
                  if (
                    ((wt.previous = function () {
                      return xu[xu.indexOf(wt) - 1];
                    }),
                    (wt.next = function () {
                      return xu[xu.indexOf(wt) + 1];
                    }),
                    (wt.revert = function (t, e) {
                      if (!e) return wt.kill(!0);
                      var i = !1 !== t || !wt.enabled,
                        r = ql;
                      i !== wt.isReverted &&
                        (i &&
                          ((k = Math.max(Ct(), wt.scroll.rec || 0)),
                          (Rt = wt.progress),
                          (B = n && n.progress())),
                        u &&
                          [u, h, d, p].forEach(function (t) {
                            return (t.style.display = i ? "none" : "block");
                          }),
                        i && ((ql = wt), wt.update(i)),
                        !Q ||
                          (at && wt.isActive) ||
                          (i
                            ? (function (t, e, n) {
                                ju(n);
                                var i = t._gsap;
                                if (i.spacerIsNative) ju(i.spacerState);
                                else if (t._gsap.swappedIn) {
                                  var r = e.parentNode;
                                  r && (r.insertBefore(t, e), r.removeChild(e));
                                }
                                t._gsap.swappedIn = !1;
                              })(Q, x, v)
                            : Gu(Q, x, ru(Q), A)),
                        i || wt.update(i),
                        (ql = r),
                        (wt.isReverted = i));
                    }),
                    (wt.refresh = function (r, s, f, b) {
                      if ((!ql && wt.enabled) || s)
                        if (Q && r && bc) hu(t, "scrollEnd", Ru);
                        else {
                          !mc && Et && Et(wt),
                            (ql = wt),
                            i.tween && !f && (i.tween.kill(), (i.tween = 0)),
                            N && N.pause(),
                            et &&
                              n &&
                              n
                                .revert({
                                  kill: !1,
                                })
                                .invalidate(),
                            wt.isReverted || wt.revert(!0, !0),
                            (wt._subPinOffset = !1);
                          var E,
                            T,
                            R,
                            L,
                            P,
                            O,
                            I,
                            D,
                            U,
                            z,
                            H,
                            V,
                            G,
                            W = St(),
                            j = Mt(),
                            q = ct ? ct.duration() : Dc(ft, dt),
                            X = g <= 0.01,
                            Y = 0,
                            K = b || 0,
                            Z = zc(f) ? f.end : e.end,
                            nt = e.endTrigger || J,
                            it = zc(f)
                              ? f.start
                              : e.start ||
                                (0 !== e.start && J
                                  ? Q
                                    ? "0 0"
                                    : "0 100%"
                                  : 0),
                            rt = (wt.pinnedContainer =
                              e.pinnedContainer && Tl(e.pinnedContainer, wt)),
                            st = (J && Math.max(0, xu.indexOf(wt))) || 0,
                            ot = st;
                          for (
                            xt &&
                            zc(f) &&
                            ((V = Nl.getProperty(d, dt.p)),
                            (G = Nl.getProperty(p, dt.p)));
                            ot--;

                          )
                            (O = xu[ot]).end || O.refresh(0, 1) || (ql = wt),
                              !(I = O.pin) ||
                                (I !== J && I !== Q && I !== rt) ||
                                O.isReverted ||
                                (z || (z = []), z.unshift(O), O.revert(!0, !0)),
                              O !== xu[ot] && (st--, ot--);
                          for (
                            kc(it) && (it = it(wt)),
                              it = Ec(it, "start", wt),
                              l =
                                Yu(
                                  it,
                                  J,
                                  W,
                                  dt,
                                  Ct(),
                                  u,
                                  d,
                                  wt,
                                  j,
                                  bt,
                                  vt,
                                  q,
                                  ct,
                                  wt._startClamp && "_startClamp"
                                ) || (Q ? -0.001 : 0),
                              kc(Z) && (Z = Z(wt)),
                              Fc(Z) &&
                                !Z.indexOf("+=") &&
                                (~Z.indexOf(" ")
                                  ? (Z = (Fc(it) ? it.split(" ")[0] : "") + Z)
                                  : ((Y = vu(Z.substr(2), W)),
                                    (Z = Fc(it)
                                      ? it
                                      : (ct
                                          ? Nl.utils.mapRange(
                                              0,
                                              ct.duration(),
                                              ct.scrollTrigger.start,
                                              ct.scrollTrigger.end,
                                              l
                                            )
                                          : l) + Y),
                                    (nt = J))),
                              Z = Ec(Z, "end", wt),
                              c =
                                Math.max(
                                  l,
                                  Yu(
                                    Z || (nt ? "100% 0" : q),
                                    nt,
                                    W,
                                    dt,
                                    Ct() + Y,
                                    h,
                                    p,
                                    wt,
                                    j,
                                    bt,
                                    vt,
                                    q,
                                    ct,
                                    wt._endClamp && "_endClamp"
                                  )
                                ) || -0.001,
                              Y = 0,
                              ot = st;
                            ot--;

                          )
                            (I = (O = xu[ot]).pin) &&
                              O.start - O._pinPush <= l &&
                              !ct &&
                              O.end > 0 &&
                              ((E =
                                O.end -
                                (wt._startClamp
                                  ? Math.max(0, O.start)
                                  : O.start)),
                              ((I === J && O.start - O._pinPush < l) ||
                                I === rt) &&
                                isNaN(it) &&
                                (Y += E * (1 - O.progress)),
                              I === Q && (K += E));
                          if (
                            ((l += Y),
                            (c += Y),
                            wt._startClamp && (wt._startClamp += Y),
                            wt._endClamp &&
                              !mc &&
                              ((wt._endClamp = c || -0.001),
                              (c = Math.min(c, Dc(ft, dt)))),
                            (g = c - l || ((l -= 0.01) && 0.001)),
                            X &&
                              (Rt = Nl.utils.clamp(
                                0,
                                1,
                                Nl.utils.normalize(l, c, k)
                              )),
                            (wt._pinPush = K),
                            u &&
                              Y &&
                              (((E = {})[dt.a] = "+=" + Y),
                              rt && (E[dt.p] = "-=" + Ct()),
                              Nl.set([u, h], E)),
                            !Q || (dc && wt.end >= Dc(ft, dt)))
                          ) {
                            if (J && Ct() && !ct)
                              for (T = J.parentNode; T && T !== Bl; )
                                T._pinOffset &&
                                  ((l -= T._pinOffset), (c -= T._pinOffset)),
                                  (T = T.parentNode);
                          } else
                            (E = ru(Q)),
                              (L = dt === Ml),
                              (R = Ct()),
                              (S = parseFloat(w(dt.a)) + K),
                              !q &&
                                c > 1 &&
                                ((H = {
                                  style: (H = (
                                    gt ? Fl.scrollingElement || kl : ft
                                  ).style),
                                  value: H["overflow" + dt.a.toUpperCase()],
                                }),
                                gt &&
                                  "scroll" !==
                                    ru(Bl)["overflow" + dt.a.toUpperCase()] &&
                                  (H.style["overflow" + dt.a.toUpperCase()] =
                                    "scroll")),
                              Gu(Q, x, E),
                              (_ = qu(Q)),
                              (T = ou(Q, !0)),
                              (D = vt && Al(ft, L ? Sl : Ml)()),
                              tt
                                ? (((A = [tt + dt.os2, g + K + iu]).t = x),
                                  (ot = tt === Qc ? au(Q, dt) + g + K : 0) &&
                                    (A.push(dt.d, ot + iu),
                                    "auto" !== x.style.flexBasis &&
                                      (x.style.flexBasis = ot + iu)),
                                  ju(A),
                                  rt &&
                                    xu.forEach(function (t) {
                                      t.pin === rt &&
                                        !1 !== t.vars.pinSpacing &&
                                        (t._subPinOffset = !0);
                                    }),
                                  vt && Ct(k))
                                : (ot = au(Q, dt)) &&
                                  "auto" !== x.style.flexBasis &&
                                  (x.style.flexBasis = ot + iu),
                              vt &&
                                (((P = {
                                  top: T.top + (L ? R - l : D) + iu,
                                  left: T.left + (L ? D : R - l) + iu,
                                  boxSizing: "border-box",
                                  position: "fixed",
                                })[Xc] = P["max" + eu] =
                                  Math.ceil(T.width) + iu),
                                (P[Yc] = P["max" + nu] =
                                  Math.ceil(T.height) + iu),
                                (P[tu] =
                                  P[tu + Zc] =
                                  P[tu + Kc] =
                                  P[tu + Jc] =
                                  P[tu + $c] =
                                    "0"),
                                (P[Qc] = E[Qc]),
                                (P[Qc + Zc] = E[Qc + Zc]),
                                (P[Qc + Kc] = E[Qc + Kc]),
                                (P[Qc + Jc] = E[Qc + Jc]),
                                (P[Qc + $c] = E[Qc + $c]),
                                (y = (function (t, e, n) {
                                  for (
                                    var i, r = [], s = t.length, o = n ? 8 : 0;
                                    o < s;
                                    o += 2
                                  )
                                    (i = t[o]),
                                      r.push(i, i in e ? e[i] : t[o + 1]);
                                  return (r.t = t.t), r;
                                })(v, P, at)),
                                mc && Ct(0)),
                              n
                                ? ((U = n._initted),
                                  tc(1),
                                  n.render(n.duration(), !0, !0),
                                  (M = w(dt.a) - S + g + K),
                                  (C = Math.abs(g - M) > 1),
                                  vt && C && y.splice(y.length - 2, 2),
                                  n.render(0, !0, !0),
                                  U || n.invalidate(!0),
                                  n.parent || n.totalTime(n.totalTime()),
                                  tc(0))
                                : (M = g),
                              H &&
                                (H.value
                                  ? (H.style["overflow" + dt.a.toUpperCase()] =
                                      H.value)
                                  : H.style.removeProperty("overflow-" + dt.a));
                          z &&
                            z.forEach(function (t) {
                              return t.revert(!1, !0);
                            }),
                            (wt.start = l),
                            (wt.end = c),
                            (o = a = mc ? k : Ct()),
                            ct || mc || (o < k && Ct(k), (wt.scroll.rec = 0)),
                            wt.revert(!1, !0),
                            (At = _c()),
                            F && ((Tt = -1), F.restart(!0)),
                            (ql = 0),
                            n &&
                              pt &&
                              (n._initted || B) &&
                              n.progress() !== B &&
                              n.progress(B || 0, !0).render(n.time(), !0, !0),
                            (X || Rt !== wt.progress || ct || et) &&
                              (n &&
                                !pt &&
                                n.totalProgress(
                                  ct && l < -0.001 && !Rt
                                    ? Nl.utils.normalize(l, c, 0)
                                    : Rt,
                                  !0
                                ),
                              (wt.progress = X || (o - l) / g === Rt ? 0 : Rt)),
                            Q &&
                              tt &&
                              (x._pinOffset = Math.round(wt.progress * M)),
                            N && N.invalidate(),
                            isNaN(V) ||
                              ((V -= Nl.getProperty(d, dt.p)),
                              (G -= Nl.getProperty(p, dt.p)),
                              Ju(d, dt, V),
                              Ju(u, dt, V - (b || 0)),
                              Ju(p, dt, G),
                              Ju(h, dt, G - (b || 0))),
                            X && !mc && wt.update(),
                            !$ || mc || m || ((m = !0), $(wt), (m = !1));
                        }
                    }),
                    (wt.getVelocity = function () {
                      return ((Ct() - a) / (_c() - Wl)) * 1e3 || 0;
                    }),
                    (wt.endAnimation = function () {
                      Hc(wt.callbackAnimation),
                        n &&
                          (N
                            ? N.progress(1)
                            : n.paused()
                            ? pt || Hc(n, wt.direction < 0, 1)
                            : Hc(n, n.reversed()));
                    }),
                    (wt.labelToScroll = function (t) {
                      return (
                        (n &&
                          n.labels &&
                          (l || wt.refresh() || l) +
                            (n.labels[t] / n.duration()) * g) ||
                        0
                      );
                    }),
                    (wt.getTrailing = function (t) {
                      var e = xu.indexOf(wt),
                        n =
                          wt.direction > 0
                            ? xu.slice(0, e).reverse()
                            : xu.slice(e + 1);
                      return (
                        Fc(t)
                          ? n.filter(function (e) {
                              return e.vars.preventOverlaps === t;
                            })
                          : n
                      ).filter(function (t) {
                        return wt.direction > 0 ? t.end <= l : t.start >= c;
                      });
                    }),
                    (wt.update = function (t, e, r) {
                      if (!ct || r || t) {
                        var s,
                          u,
                          h,
                          p,
                          f,
                          m,
                          v,
                          b = !0 === mc ? k : wt.scroll(),
                          w = t ? 0 : (b - l) / g,
                          A = w < 0 ? 0 : w > 1 ? 1 : w || 0,
                          P = wt.progress;
                        if (
                          (e &&
                            ((a = o),
                            (o = ct ? Ct() : b),
                            ot &&
                              ((I = O),
                              (O = n && !pt ? n.totalProgress() : A))),
                          nt &&
                            Q &&
                            !ql &&
                            !yc &&
                            bc &&
                            (!A && l < b + ((b - a) / (_c() - Wl)) * nt
                              ? (A = 1e-4)
                              : 1 === A &&
                                c > b + ((b - a) / (_c() - Wl)) * nt &&
                                (A = 0.9999)),
                          A !== P && wt.enabled)
                        ) {
                          if (
                            ((p =
                              (f =
                                (s = wt.isActive = !!A && A < 1) !==
                                (!!P && P < 1)) || !!A != !!P),
                            (wt.direction = A > P ? 1 : -1),
                            (wt.progress = A),
                            p &&
                              !ql &&
                              ((u =
                                A && !P ? 0 : 1 === A ? 1 : 1 === P ? 2 : 3),
                              pt &&
                                ((h =
                                  (!f && "none" !== _t[u + 1] && _t[u + 1]) ||
                                  _t[u]),
                                (v =
                                  n &&
                                  ("complete" === h ||
                                    "reset" === h ||
                                    h in n)))),
                            ht &&
                              (f || v) &&
                              (v || Z || !n) &&
                              (kc(ht)
                                ? ht(wt)
                                : wt.getTrailing(ht).forEach(function (t) {
                                    return t.endAnimation();
                                  })),
                            pt ||
                              (!N || ql || yc
                                ? n && n.totalProgress(A, !(!ql || (!At && !t)))
                                : (N._dp._time - N._start !== N._time &&
                                    N.render(N._dp._time - N._start),
                                  N.resetTo
                                    ? N.resetTo(
                                        "totalProgress",
                                        A,
                                        n._tTime / n._tDur
                                      )
                                    : ((N.vars.totalProgress = A),
                                      N.invalidate().restart()))),
                            Q)
                          )
                            if ((t && tt && (x.style[tt + dt.os2] = T), vt)) {
                              if (p) {
                                if (
                                  ((m =
                                    !t &&
                                    A > P &&
                                    c + 1 > b &&
                                    b + 1 >= Dc(ft, dt)),
                                  at)
                                )
                                  if (t || (!s && !m)) $u(Q, x);
                                  else {
                                    var D = ou(Q, !0),
                                      U = b - l;
                                    $u(
                                      Q,
                                      Bl,
                                      D.top + (dt === Ml ? U : 0) + iu,
                                      D.left + (dt === Ml ? 0 : U) + iu
                                    );
                                  }
                                ju(s || m ? y : _),
                                  (C && A < 1 && s) ||
                                    E(S + (1 !== A || m ? 0 : M));
                              }
                            } else E(Cc(S + M * A));
                          ot && !i.tween && !ql && !yc && F.restart(!0),
                            X &&
                              (f || (st && A && (A < 1 || !pc))) &&
                              Vl(X.targets).forEach(function (t) {
                                return t.classList[s || st ? "add" : "remove"](
                                  X.className
                                );
                              }),
                            q && !pt && !t && q(wt),
                            p && !ql
                              ? (pt &&
                                  (v &&
                                    ("complete" === h
                                      ? n.pause().totalProgress(1)
                                      : "reset" === h
                                      ? n.restart(!0).pause()
                                      : "restart" === h
                                      ? n.restart(!0)
                                      : n[h]()),
                                  q && q(wt)),
                                (!f && pc) ||
                                  (K && f && Vc(wt, K),
                                  yt[u] && Vc(wt, yt[u]),
                                  st &&
                                    (1 === A ? wt.kill(!1, 1) : (yt[u] = 0)),
                                  f ||
                                    (yt[(u = 1 === A ? 1 : 3)] &&
                                      Vc(wt, yt[u]))),
                                ut &&
                                  !s &&
                                  Math.abs(wt.getVelocity()) >
                                    (Bc(ut) ? ut : 2500) &&
                                  (Hc(wt.callbackAnimation),
                                  N
                                    ? N.progress(1)
                                    : Hc(n, "reverse" === h ? 1 : !A, 1)))
                              : pt && q && !ql && q(wt);
                        }
                        if (L) {
                          var B = ct
                            ? (b / ct.duration()) * (ct._caScrollDist || 0)
                            : b;
                          R(B + (d._isFlipped ? 1 : 0)), L(B);
                        }
                        z && z((-b / ct.duration()) * (ct._caScrollDist || 0));
                      }
                    }),
                    (wt.enable = function (e, n) {
                      wt.enabled ||
                        ((wt.enabled = !0),
                        hu(ft, "resize", Mu),
                        gt || hu(ft, "scroll", Eu),
                        Et && hu(t, "refreshInit", Et),
                        !1 !== e &&
                          ((wt.progress = Rt = 0), (o = a = Tt = Ct())),
                        !1 !== n && wt.refresh());
                    }),
                    (wt.getTween = function (t) {
                      return t && i ? i.tween : N;
                    }),
                    (wt.setPositions = function (t, e, n, i) {
                      if (ct) {
                        var r = ct.scrollTrigger,
                          s = ct.duration(),
                          o = r.end - r.start;
                        (t = r.start + (o * t) / s),
                          (e = r.start + (o * e) / s);
                      }
                      wt.refresh(
                        !1,
                        !1,
                        {
                          start: Sc(t, n && !!wt._startClamp),
                          end: Sc(e, n && !!wt._endClamp),
                        },
                        i
                      ),
                        wt.update();
                    }),
                    (wt.adjustPinSpacing = function (t) {
                      if (A && t) {
                        var e = A.indexOf(dt.d) + 1;
                        (A[e] = parseFloat(A[e]) + t + iu),
                          (A[1] = parseFloat(A[1]) + t + iu),
                          ju(A);
                      }
                    }),
                    (wt.disable = function (e, n) {
                      if (
                        wt.enabled &&
                        (!1 !== e && wt.revert(!0, !0),
                        (wt.enabled = wt.isActive = !1),
                        n || (N && N.pause()),
                        (k = 0),
                        r && (r.uncache = 1),
                        Et && du(t, "refreshInit", Et),
                        F &&
                          (F.pause(),
                          i.tween && i.tween.kill() && (i.tween = 0)),
                        !gt)
                      ) {
                        for (var s = xu.length; s--; )
                          if (xu[s].scroller === ft && xu[s] !== wt) return;
                        du(ft, "resize", Mu), gt || du(ft, "scroll", Eu);
                      }
                    }),
                    (wt.kill = function (t, i) {
                      wt.disable(t, i), N && !i && N.kill(), Y && delete bu[Y];
                      var s = xu.indexOf(wt);
                      s >= 0 && xu.splice(s, 1),
                        s === Kl && Bu > 0 && Kl--,
                        (s = 0),
                        xu.forEach(function (t) {
                          return t.scroller === wt.scroller && (s = 1);
                        }),
                        s || mc || (wt.scroll.rec = 0),
                        n &&
                          ((n.scrollTrigger = null),
                          t &&
                            n.revert({
                              kill: !1,
                            }),
                          i || n.kill()),
                        u &&
                          [u, h, d, p].forEach(function (t) {
                            return t.parentNode && t.parentNode.removeChild(t);
                          }),
                        vc === wt && (vc = 0),
                        Q &&
                          (r && (r.uncache = 1),
                          (s = 0),
                          xu.forEach(function (t) {
                            return t.pin === Q && s++;
                          }),
                          s || (r.spacer = 0)),
                        e.onKill && e.onKill(wt);
                    }),
                    xu.push(wt),
                    wt.enable(!1, !1),
                    H && H(wt),
                    n && n.add && !g)
                  ) {
                    var It = wt.update;
                    (wt.update = function () {
                      (wt.update = It), l || c || wt.refresh();
                    }),
                      Nl.delayedCall(0.01, wt.update),
                      (g = 0.01),
                      (l = c = 0);
                  } else wt.refresh();
                  Q &&
                    (function () {
                      if (gc !== Nu) {
                        var t = (gc = Nu);
                        requestAnimationFrame(function () {
                          return t === Nu && Fu(!0);
                        });
                      }
                    })();
                } else this.update = this.refresh = this.kill = Rc;
              }),
              (t.register = function (e) {
                return (
                  Dl ||
                    ((Nl = e || Pc()),
                    Lc() && window.document && t.enable(),
                    (Dl = wc)),
                  Dl
                );
              }),
              (t.defaults = function (t) {
                if (t) for (var e in t) mu[e] = t[e];
                return mu;
              }),
              (t.disable = function (t, e) {
                (wc = 0),
                  xu.forEach(function (n) {
                    return n[e ? "kill" : "disable"](t);
                  }),
                  du(Ul, "wheel", Eu),
                  du(Fl, "scroll", Eu),
                  clearInterval(jl),
                  du(Fl, "touchcancel", Rc),
                  du(Bl, "touchstart", Rc),
                  uu(du, Fl, "pointerdown,touchstart,mousedown", Tc),
                  uu(du, Fl, "pointerup,touchend,mouseup", Ac),
                  Hl.kill(),
                  Uc(du);
                for (var n = 0; n < dl.length; n += 3)
                  pu(du, dl[n], dl[n + 1]), pu(du, dl[n], dl[n + 2]);
              }),
              (t.enable = function () {
                if (
                  ((Ul = window),
                  (Fl = document),
                  (kl = Fl.documentElement),
                  (Bl = Fl.body),
                  Nl &&
                    ((Vl = Nl.utils.toArray),
                    (Gl = Nl.utils.clamp),
                    (ac = Nl.core.context || Rc),
                    (tc = Nl.core.suppressOverwrites || Rc),
                    (lc = Ul.history.scrollRestoration || "auto"),
                    (ku = Ul.pageYOffset),
                    Nl.core.globals("ScrollTrigger", t),
                    Bl))
                ) {
                  (wc = 1),
                    ((cc = document.createElement("div")).style.height =
                      "100vh"),
                    (cc.style.position = "absolute"),
                    Du(),
                    Mc(),
                    Il.register(Nl),
                    (t.isTouch = Il.isTouch),
                    (oc =
                      Il.isTouch &&
                      /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
                    (ic = 1 === Il.isTouch),
                    hu(Ul, "wheel", Eu),
                    (zl = [Ul, Fl, kl, Bl]),
                    Nl.matchMedia
                      ? ((t.matchMedia = function (t) {
                          var e,
                            n = Nl.matchMedia();
                          for (e in t) n.add(e, t[e]);
                          return n;
                        }),
                        Nl.addEventListener("matchMediaInit", function () {
                          return Ou();
                        }),
                        Nl.addEventListener("matchMediaRevert", function () {
                          return Pu();
                        }),
                        Nl.addEventListener("matchMedia", function () {
                          Fu(0, 1), Cu("matchMedia");
                        }),
                        Nl.matchMedia("(orientation: portrait)", function () {
                          return Su(), Su;
                        }))
                      : console.warn("Requires GSAP 3.11.0 or later"),
                    Su(),
                    hu(Fl, "scroll", Eu);
                  var e,
                    n,
                    i = Bl.style,
                    r = i.borderTopStyle,
                    s = Nl.core.Animation.prototype;
                  for (
                    s.revert ||
                      Object.defineProperty(s, "revert", {
                        value: function () {
                          return this.time(-0.01, !0);
                        },
                      }),
                      i.borderTopStyle = "solid",
                      e = ou(Bl),
                      Ml.m = Math.round(e.top + Ml.sc()) || 0,
                      Sl.m = Math.round(e.left + Sl.sc()) || 0,
                      r
                        ? (i.borderTopStyle = r)
                        : i.removeProperty("border-top-style"),
                      jl = setInterval(wu, 250),
                      Nl.delayedCall(0.5, function () {
                        return (yc = 0);
                      }),
                      hu(Fl, "touchcancel", Rc),
                      hu(Bl, "touchstart", Rc),
                      uu(hu, Fl, "pointerdown,touchstart,mousedown", Tc),
                      uu(hu, Fl, "pointerup,touchend,mouseup", Ac),
                      Yl = Nl.utils.checkPrefix("transform"),
                      Vu.push(Yl),
                      Dl = _c(),
                      Hl = Nl.delayedCall(0.2, Fu).pause(),
                      Jl = [
                        Fl,
                        "visibilitychange",
                        function () {
                          var t = Ul.innerWidth,
                            e = Ul.innerHeight;
                          Fl.hidden
                            ? (($l = t), (Zl = e))
                            : ($l === t && Zl === e) || Mu();
                        },
                        Fl,
                        "DOMContentLoaded",
                        Fu,
                        Ul,
                        "load",
                        Fu,
                        Ul,
                        "resize",
                        Mu,
                      ],
                      Uc(hu),
                      xu.forEach(function (t) {
                        return t.enable(0, 1);
                      }),
                      n = 0;
                    n < dl.length;
                    n += 3
                  )
                    pu(du, dl[n], dl[n + 1]), pu(du, dl[n], dl[n + 2]);
                }
              }),
              (t.config = function (e) {
                "limitCallbacks" in e && (pc = !!e.limitCallbacks);
                var n = e.syncInterval;
                (n && clearInterval(jl)) || ((jl = n) && setInterval(wu, n)),
                  "ignoreMobileResize" in e &&
                    (ic = 1 === t.isTouch && e.ignoreMobileResize),
                  "autoRefreshEvents" in e &&
                    (Uc(du) || Uc(hu, e.autoRefreshEvents || "none"),
                    (ec = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
              }),
              (t.scrollerProxy = function (t, e) {
                var n = Tl(t),
                  i = dl.indexOf(n),
                  r = Oc(n);
                ~i && dl.splice(i, r ? 6 : 2),
                  e && (r ? pl.unshift(Ul, e, Bl, e, kl, e) : pl.unshift(n, e));
              }),
              (t.clearMatchMedia = function (t) {
                xu.forEach(function (e) {
                  return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
                });
              }),
              (t.isInViewport = function (t, e, n) {
                var i = (Fc(t) ? Tl(t) : t).getBoundingClientRect(),
                  r = i[n ? Xc : Yc] * e || 0;
                return n
                  ? i.right - r > 0 && i.left + r < Ul.innerWidth
                  : i.bottom - r > 0 && i.top + r < Ul.innerHeight;
              }),
              (t.positionInViewport = function (t, e, n) {
                Fc(t) && (t = Tl(t));
                var i = t.getBoundingClientRect(),
                  r = i[n ? Xc : Yc],
                  s =
                    null == e
                      ? r / 2
                      : e in gu
                      ? gu[e] * r
                      : ~e.indexOf("%")
                      ? (parseFloat(e) * r) / 100
                      : parseFloat(e) || 0;
                return n
                  ? (i.left + s) / Ul.innerWidth
                  : (i.top + s) / Ul.innerHeight;
              }),
              (t.killAll = function (t) {
                if (
                  (xu.slice(0).forEach(function (t) {
                    return "ScrollSmoother" !== t.vars.id && t.kill();
                  }),
                  !0 !== t)
                ) {
                  var e = Tu.killAll || [];
                  (Tu = {}),
                    e.forEach(function (t) {
                      return t();
                    });
                }
              }),
              t
            );
          })();
        (th.version = "3.12.5"),
          (th.saveStyles = function (t) {
            return t
              ? Vl(t).forEach(function (t) {
                  if (t && t.style) {
                    var e = Lu.indexOf(t);
                    e >= 0 && Lu.splice(e, 5),
                      Lu.push(
                        t,
                        t.style.cssText,
                        t.getBBox && t.getAttribute("transform"),
                        Nl.core.getCache(t),
                        ac()
                      );
                  }
                })
              : Lu;
          }),
          (th.revert = function (t, e) {
            return Ou(!t, e);
          }),
          (th.create = function (t, e) {
            return new th(t, e);
          }),
          (th.refresh = function (t) {
            return t ? Mu() : (Dl || th.register()) && Fu(!0);
          }),
          (th.update = function (t) {
            return ++dl.cache && zu(!0 === t ? 2 : 0);
          }),
          (th.clearScrollMemory = Iu),
          (th.maxScroll = function (t, e) {
            return Dc(t, e ? Sl : Ml);
          }),
          (th.getScrollFunc = function (t, e) {
            return Al(Tl(t), e ? Sl : Ml);
          }),
          (th.getById = function (t) {
            return bu[t];
          }),
          (th.getAll = function () {
            return xu.filter(function (t) {
              return "ScrollSmoother" !== t.vars.id;
            });
          }),
          (th.isScrolling = function () {
            return !!bc;
          }),
          (th.snapDirectional = cu),
          (th.addEventListener = function (t, e) {
            var n = Tu[t] || (Tu[t] = []);
            ~n.indexOf(e) || n.push(e);
          }),
          (th.removeEventListener = function (t, e) {
            var n = Tu[t],
              i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1);
          }),
          (th.batch = function (t, e) {
            var n,
              i = [],
              r = {},
              s = e.interval || 0.016,
              o = e.batchMax || 1e9,
              a = function (t, e) {
                var n = [],
                  i = [],
                  r = Nl.delayedCall(s, function () {
                    e(n, i), (n = []), (i = []);
                  }).pause();
                return function (t) {
                  n.length || r.restart(!0),
                    n.push(t.trigger),
                    i.push(t),
                    o <= n.length && r.progress(1);
                };
              };
            for (n in e)
              r[n] =
                "on" === n.substr(0, 2) && kc(e[n]) && "onRefreshInit" !== n
                  ? a(0, e[n])
                  : e[n];
            return (
              kc(o) &&
                ((o = o()),
                hu(th, "refresh", function () {
                  return (o = e.batchMax());
                })),
              Vl(t).forEach(function (t) {
                var e = {};
                for (n in r) e[n] = r[n];
                (e.trigger = t), i.push(th.create(e));
              }),
              i
            );
          });
        var eh,
          nh = function (t, e, n, i) {
            return (
              e > i ? t(i) : e < 0 && t(0),
              n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
            );
          },
          ih = function t(e, n) {
            !0 === n
              ? e.style.removeProperty("touch-action")
              : (e.style.touchAction =
                  !0 === n
                    ? "auto"
                    : n
                    ? "pan-" + n + (Il.isTouch ? " pinch-zoom" : "")
                    : "none"),
              e === kl && t(Bl, n);
          },
          rh = {
            auto: 1,
            scroll: 1,
          },
          sh = function (t) {
            var e,
              n = t.event,
              i = t.target,
              r = t.axis,
              s = (n.changedTouches ? n.changedTouches[0] : n).target,
              o = s._gsap || Nl.core.getCache(s),
              a = _c();
            if (!o._isScrollT || a - o._isScrollT > 2e3) {
              for (
                ;
                s &&
                s !== Bl &&
                ((s.scrollHeight <= s.clientHeight &&
                  s.scrollWidth <= s.clientWidth) ||
                  (!rh[(e = ru(s)).overflowY] && !rh[e.overflowX]));

              )
                s = s.parentNode;
              (o._isScroll =
                s &&
                s !== i &&
                !Oc(s) &&
                (rh[(e = ru(s)).overflowY] || rh[e.overflowX])),
                (o._isScrollT = a);
            }
            (o._isScroll || "x" === r) &&
              (n.stopPropagation(), (n._gsapAllow = !0));
          },
          oh = function (t, e, n, i) {
            return Il.create({
              target: t,
              capture: !0,
              debounce: !1,
              lockAxis: !0,
              type: e,
              onWheel: (i = i && sh),
              onPress: i,
              onDrag: i,
              onScroll: i,
              onEnable: function () {
                return n && hu(Fl, Il.eventTypes[0], lh, !1, !0);
              },
              onDisable: function () {
                return du(Fl, Il.eventTypes[0], lh, !0);
              },
            });
          },
          ah = /(input|label|select|textarea)/i,
          lh = function (t) {
            var e = ah.test(t.target.tagName);
            (e || eh) && ((t._gsapAllow = !0), (eh = e));
          },
          ch = function (t) {
            zc(t) || (t = {}),
              (t.preventDefault = t.isNormalizer = t.allowClicks = !0),
              t.type || (t.type = "wheel,touch"),
              (t.debounce = !!t.debounce),
              (t.id = t.id || "normalizer");
            var e,
              n,
              i,
              r,
              s,
              o,
              a,
              l,
              c = t,
              u = c.normalizeScrollX,
              h = c.momentum,
              d = c.allowNestedScroll,
              p = c.onRelease,
              f = Tl(t.target) || kl,
              m = Nl.core.globals().ScrollSmoother,
              g = m && m.get(),
              v =
                oc &&
                ((t.content && Tl(t.content)) ||
                  (g && !1 !== t.content && !g.smooth() && g.content())),
              y = Al(f, Ml),
              _ = Al(f, Sl),
              x = 1,
              b =
                (Il.isTouch && Ul.visualViewport
                  ? Ul.visualViewport.scale * Ul.visualViewport.width
                  : Ul.outerWidth) / Ul.innerWidth,
              w = 0,
              E = kc(h)
                ? function () {
                    return h(e);
                  }
                : function () {
                    return h || 2.8;
                  },
              S = oh(f, t.type, !0, d),
              M = function () {
                return (r = !1);
              },
              T = Rc,
              A = Rc,
              R = function () {
                (n = Dc(f, Ml)),
                  (A = Gl(oc ? 1 : 0, n)),
                  u && (T = Gl(0, Dc(f, Sl))),
                  (i = Nu);
              },
              C = function () {
                (v._gsap.y = Cc(parseFloat(v._gsap.y) + y.offset) + "px"),
                  (v.style.transform =
                    "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                    parseFloat(v._gsap.y) +
                    ", 0, 1)"),
                  (y.offset = y.cacheID = 0);
              },
              L = function () {
                R(),
                  s.isActive() &&
                    s.vars.scrollY > n &&
                    (y() > n ? s.progress(1) && y(n) : s.resetTo("scrollY", n));
              };
            return (
              v &&
                Nl.set(v, {
                  y: "+=0",
                }),
              (t.ignoreCheck = function (t) {
                return (
                  (oc &&
                    "touchmove" === t.type &&
                    (function () {
                      if (r) {
                        requestAnimationFrame(M);
                        var t = Cc(e.deltaY / 2),
                          n = A(y.v - t);
                        if (v && n !== y.v + y.offset) {
                          y.offset = n - y.v;
                          var i = Cc(
                            (parseFloat(v && v._gsap.y) || 0) - y.offset
                          );
                          (v.style.transform =
                            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                            i +
                            ", 0, 1)"),
                            (v._gsap.y = i + "px"),
                            (y.cacheID = dl.cache),
                            zu();
                        }
                        return !0;
                      }
                      y.offset && C(), (r = !0);
                    })()) ||
                  (x > 1.05 && "touchstart" !== t.type) ||
                  e.isGesturing ||
                  (t.touches && t.touches.length > 1)
                );
              }),
              (t.onPress = function () {
                r = !1;
                var t = x;
                (x = Cc(
                  ((Ul.visualViewport && Ul.visualViewport.scale) || 1) / b
                )),
                  s.pause(),
                  t !== x && ih(f, x > 1.01 || (!u && "x")),
                  (o = _()),
                  (a = y()),
                  R(),
                  (i = Nu);
              }),
              (t.onRelease = t.onGestureStart =
                function (t, e) {
                  if ((y.offset && C(), e)) {
                    dl.cache++;
                    var i,
                      r,
                      o = E();
                    u &&
                      ((r = (i = _()) + (0.05 * o * -t.velocityX) / 0.227),
                      (o *= nh(_, i, r, Dc(f, Sl))),
                      (s.vars.scrollX = T(r))),
                      (r = (i = y()) + (0.05 * o * -t.velocityY) / 0.227),
                      (o *= nh(y, i, r, Dc(f, Ml))),
                      (s.vars.scrollY = A(r)),
                      s.invalidate().duration(o).play(0.01),
                      ((oc && s.vars.scrollY >= n) || i >= n - 1) &&
                        Nl.to(
                          {},
                          {
                            onUpdate: L,
                            duration: o,
                          }
                        );
                  } else l.restart(!0);
                  p && p(t);
                }),
              (t.onWheel = function () {
                s._ts && s.pause(), _c() - w > 1e3 && ((i = 0), (w = _c()));
              }),
              (t.onChange = function (t, e, n, r, s) {
                if (
                  (Nu !== i && R(),
                  e &&
                    u &&
                    _(T(r[2] === e ? o + (t.startX - t.x) : _() + e - r[1])),
                  n)
                ) {
                  y.offset && C();
                  var l = s[2] === n,
                    c = l ? a + t.startY - t.y : y() + n - s[1],
                    h = A(c);
                  l && c !== h && (a += h - c), y(h);
                }
                (n || e) && zu();
              }),
              (t.onEnable = function () {
                ih(f, !u && "x"),
                  th.addEventListener("refresh", L),
                  hu(Ul, "resize", L),
                  y.smooth &&
                    ((y.target.style.scrollBehavior = "auto"),
                    (y.smooth = _.smooth = !1)),
                  S.enable();
              }),
              (t.onDisable = function () {
                ih(f, !0),
                  du(Ul, "resize", L),
                  th.removeEventListener("refresh", L),
                  S.kill();
              }),
              (t.lockAxis = !1 !== t.lockAxis),
              ((e = new Il(t)).iOS = oc),
              oc && !y() && y(1),
              oc && Nl.ticker.add(Rc),
              (l = e._dc),
              (s = Nl.to(e, {
                ease: "power4",
                paused: !0,
                inherit: !1,
                scrollX: u ? "+=0.1" : "+=0",
                scrollY: "+=0.1",
                modifiers: {
                  scrollY: Zu(y, y(), function () {
                    return s.pause();
                  }),
                },
                onUpdate: zu,
                onComplete: l.vars.onComplete,
              })),
              e
            );
          };
        (th.sort = function (t) {
          return xu.sort(
            t ||
              function (t, e) {
                return (
                  -1e6 * (t.vars.refreshPriority || 0) +
                  t.start -
                  (e.start + -1e6 * (e.vars.refreshPriority || 0))
                );
              }
          );
        }),
          (th.observe = function (t) {
            return new Il(t);
          }),
          (th.normalizeScroll = function (t) {
            if (void 0 === t) return nc;
            if (!0 === t && nc) return nc.enable();
            if (!1 === t) return nc && nc.kill(), void (nc = t);
            var e = t instanceof Il ? t : ch(t);
            return (
              nc && nc.target === e.target && nc.kill(),
              Oc(e.target) && (nc = e),
              e
            );
          }),
          (th.core = {
            _getVelocityProp: Rl,
            _inputObserver: oh,
            _scrollers: dl,
            _proxies: pl,
            bridge: {
              ss: function () {
                bc || Cu("scrollStart"), (bc = _c());
              },
              ref: function () {
                return ql;
              },
            },
          }),
          Pc() && Nl.registerPlugin(th),
          Yi.registerPlugin(th);
        class uh {
          constructor(t) {
            this.tgt = t;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.scrollAction();
          }
          scrollAction() {
            this.tgt.forEach((t, e) => {
              th.create({
                trigger: t,
                id: e + 1,
                start: "top bottom",
                toggleClass: {
                  targets: t,
                  className: "-in",
                },
                once: !0,
                markers: !1,
              });
            });
          }
        }
        class hh {
          constructor(t) {
            (this.tgt = t), (this.colorThief = new ColorThief());
          }
          init() {
            return this.bind();
          }
          bind() {
            this.setBgColor();
          }
          setBgColor() {
            (this.imgBgItem = this.tgt.parentNode.nextElementSibling),
              (this.imgBgItem.style.background = this.getImgColor());
          }
          getImgColor() {
            const t = this;
            return (
              (this.dominantColor = t.colorThief.getColor(t.tgt)),
              (this.hexColor = t.rgbToHex(...this.dominantColor)),
              this.hexColor
            );
          }
          rgbToHex(t, e, n) {
            return (
              "#" +
              [t, e, n]
                .map((t) => {
                  const e = t.toString(16);
                  return 1 === e.length ? "0" + e : e;
                })
                .join("")
            );
          }
        }
        Yi.registerPlugin(th);
        class dh {
          constructor(t) {
            (this.tgt = t),
              (this.main = document.querySelector(".main-area")),
              (this.mainHead = document.querySelector(".main-head-area")),
              (this.config = {
                attributes: !0,
                attributeFilter: ["style"],
              }),
              (this.url = location.href),
              this.endTrigger;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.scrollAction();
          }
          scrollAction() {
            const t = this;
            t.tgt.forEach((e, n) => {
              -1 != t.url.indexOf("company")
                ? e.classList.contains("--bg-sec-n1")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n2")),
                    (t.start = "top-=10% top"),
                    (t.end = "top-=50% top"))
                  : ((this.endTrigger = document.querySelector(".--bg-sec-n2")),
                    (t.start = "top-=50% top"),
                    (t.end = "bottom top"))
                : -1 != t.url.indexOf("about-us")
                ? e.classList.contains("--bg-sec-n1")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n2")),
                    (t.start = "top-=140% top"),
                    (t.end = "top-=140% top"))
                  : e.classList.contains("--bg-sec-n2")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n3")),
                    (t.start = "top-=140% top"),
                    (t.end = "top-=140% top"))
                  : e.classList.contains("--bg-sec-n3")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n4")),
                    (t.start = "top-=140% top"),
                    (t.end = "top-=140% top"))
                  : e.classList.contains("--bg-sec-n4")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n5")),
                    (t.start = "top-=140% top"),
                    (t.end = "top-=140% top"))
                  : e.classList.contains("--bg-sec-n5")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n6")),
                    (t.start = "top-=140% top"),
                    (t.end = "top-=140% top"))
                  : e.classList.contains("--bg-sec-n6")
                  ? ((t.start = "top-=140% top"), (t.end = "bottom top"))
                  : ((t.start = "top-=140% top"), (t.end = "top-=140% top"))
                : -1 != t.url.indexOf("service")
                ? e.classList.contains("--bg-sec-n1")
                  ? ((this.endTrigger = document.querySelector(".--bg-sec-n2")),
                    (t.start = "top-=10% top"),
                    (t.end = "top-=20% top"))
                  : ((this.endTrigger = document.querySelector(".--bg-sec-n2")),
                    (t.start = "top-=20% top"),
                    (t.end = "bottom top"))
                : ((t.start = "top-=20% top"), (t.end = "bottom bottom")),
                Yi.to(e, {
                  scrollTrigger: {
                    trigger: e,
                    endTrigger: t.endTrigger,
                    start: t.start,
                    end: t.end,
                    scrub: !1,
                    once: !1,
                    toggleActions: "play none none reverse",
                    markers: !1,
                    onEnter: () => {
                      t.toggleBgColor(e);
                    },
                    onLeave: () => {},
                    onEnterBack: () => {
                      t.toggleBgColor(e);
                    },
                    onLeaveBack: () => {
                      t.toggleBgColor(e);
                    },
                  },
                });
            });
          }
          toggleBgColor(t) {
            const e = this;
            (this.getBgColor = t.getAttribute("data-js-bg-transition-scroll")),
              (e.main.style.background = this.getBgColor),
              t.classList.contains("--bg-color")
                ? e.main.classList.add("--bg-on")
                : e.main.classList.remove("--bg-on");
          }
          styleObserve(t) {
            const e = this;
            (this.callback = function (t, n) {
              (this.getBgColor = e.main.style.background),
                document
                  .querySelectorAll(
                    "[data-js-bg-transition-scroll] .contents-bg .item"
                  )
                  .forEach((t) => {
                    t.style.background =
                      "linear-gradient(90deg, rgba(114, 118, 126, 0) 8.45%, " +
                      this.getBgColor +
                      " 133.33%)";
                  });
            }),
              (this.OBSERVER = new MutationObserver(this.callback)),
              this.OBSERVER.observe(e.main, e.config);
          }
        }
        class ph {
          constructor(t) {
            (this.tgt = t), (this.buffer = 120);
          }
          init() {
            return this.bind();
          }
          bind() {
            this.anchorAction();
          }
          anchorAction() {
            const t = this;
            t.tgt.addEventListener("click", (e) => {
              -1 != t.tgt.href.indexOf(location.pathname) &&
                (e.preventDefault(),
                (this.targetId = t.tgt.hash),
                (this.targetElement = document.querySelector(this.targetId)),
                (this.targetOffsetTop =
                  window.scrollY +
                  this.targetElement.getBoundingClientRect().top -
                  t.buffer),
                window.scrollTo({
                  top: this.targetOffsetTop,
                  behavior: "smooth",
                }));
            });
          }
        }
        Yi.registerPlugin(th);
        class fh {
          constructor(t, e) {
            (this.item_01 = t),
              (this.item_02 = e),
              (this.world = document.getElementById("world")),
              (this.triggerArea_01 =
                document.querySelector(".main-visual-area")),
              (this.triggerArea_02 = document.querySelector(
                ".footer-contact-carousel-area"
              )),
              this.item_01;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.scrollAction();
          }
          scrollAction() {
            const t = this;
            Yi.killTweensOf(t.item_01),
              Yi.to(t.item_01, {
                scrollTrigger: {
                  trigger: t.triggerArea_01,
                  start: "top top",
                  end: "bottom top",
                  scrub: !1,
                  once: !1,
                  toggleActions: "play none none reverse",
                  markers: !1,
                  onEnter: () => {
                    document
                      .querySelector(".main-area")
                      .classList.contains("--home") &&
                      ((t.world.style.opacity = "1"),
                      t.item_01.classList.remove("is-hide"));
                  },
                  onLeave: () => {
                    document
                      .querySelector(".main-area")
                      .classList.contains("--home") &&
                      ((t.world.style.opacity = "0"),
                      t.item_01.classList.add("is-hide"));
                  },
                  onEnterBack: () => {
                    document
                      .querySelector(".main-area")
                      .classList.contains("--home") &&
                      ((t.world.style.opacity = "1"),
                      t.item_01.classList.remove("is-hide"));
                  },
                },
              }),
              Yi.to(t.item_02, {
                scrollTrigger: {
                  trigger: t.triggerArea_02,
                  start: "top bottom",
                  end: "bottom top",
                  scrub: !1,
                  once: !1,
                  toggleActions: "play none none reverse",
                  markers: !1,
                  onEnter: () => {
                    document
                      .querySelector(".main-area")
                      .classList.contains("--contact") ||
                      t.item_02.classList.add("is-hide");
                  },
                  onLeaveBack: () => {
                    document
                      .querySelector(".main-area")
                      .classList.contains("--contact") ||
                      ((t.world.style.opacity = "0"),
                      t.item_02.classList.remove("is-hide"));
                  },
                },
              });
          }
          refresh() {
            th.refresh();
          }
        }
        /**
         * @license
         * Copyright 2010-2023 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        const mh = "156",
          gh = 0,
          vh = 1,
          yh = 2,
          _h = 0,
          xh = 1,
          bh = 2,
          wh = 3,
          Eh = 1,
          Sh = 2,
          Mh = 3,
          Th = 0,
          Ah = 1,
          Rh = 2,
          Ch = 100,
          Lh = 101,
          Ph = 102,
          Oh = 200,
          Ih = 201,
          Nh = 202,
          Dh = 203,
          Uh = 204,
          Fh = 205,
          kh = 206,
          Bh = 207,
          zh = 208,
          Hh = 209,
          Vh = 210,
          Gh = 0,
          Wh = 1,
          jh = 2,
          qh = 0,
          Xh = 1,
          Yh = 2,
          Kh = 3,
          $h = 4,
          Zh = 5,
          Jh = 301,
          Qh = 302,
          td = 303,
          ed = 304,
          nd = 306,
          id = 1e3,
          rd = 1001,
          sd = 1002,
          od = 1003,
          ad = 1004,
          ld = 1005,
          cd = 1006,
          ud = 1007,
          hd = 1008,
          dd = 1009,
          pd = 1012,
          fd = 1013,
          md = 1014,
          gd = 1015,
          vd = 1016,
          yd = 1020,
          _d = 1023,
          xd = 1026,
          bd = 1027,
          wd = 33776,
          Ed = 33777,
          Sd = 33778,
          Md = 33779,
          Td = 36492,
          Ad = 2300,
          Rd = 2301,
          Cd = 2302,
          Ld = 2400,
          Pd = 2401,
          Od = 2402,
          Id = 3001,
          Nd = "",
          Dd = "srgb",
          Ud = "srgb-linear",
          Fd = "display-p3",
          kd = 7680,
          Bd = 512,
          zd = 513,
          Hd = 514,
          Vd = 515,
          Gd = 516,
          Wd = 517,
          jd = 518,
          qd = 519,
          Xd = 35044,
          Yd = "300 es",
          Kd = 1035,
          $d = 2e3,
          Zd = 2001;
        class Jd {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        const Qd = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ];
        let tp = 1234567;
        const ep = Math.PI / 180,
          np = 180 / Math.PI;
        function ip() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0;
          return (
            Qd[255 & t] +
            Qd[(t >> 8) & 255] +
            Qd[(t >> 16) & 255] +
            Qd[(t >> 24) & 255] +
            "-" +
            Qd[255 & e] +
            Qd[(e >> 8) & 255] +
            "-" +
            Qd[((e >> 16) & 15) | 64] +
            Qd[(e >> 24) & 255] +
            "-" +
            Qd[(63 & n) | 128] +
            Qd[(n >> 8) & 255] +
            "-" +
            Qd[(n >> 16) & 255] +
            Qd[(n >> 24) & 255] +
            Qd[255 & i] +
            Qd[(i >> 8) & 255] +
            Qd[(i >> 16) & 255] +
            Qd[(i >> 24) & 255]
          ).toLowerCase();
        }
        function rp(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function sp(t, e) {
          return ((t % e) + e) % e;
        }
        function op(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function ap(t) {
          return !(t & (t - 1)) && 0 !== t;
        }
        function lp(t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }
        function cp(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        function up(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return t / 4294967295;
            case Uint16Array:
              return t / 65535;
            case Uint8Array:
              return t / 255;
            case Int32Array:
              return Math.max(t / 2147483647, -1);
            case Int16Array:
              return Math.max(t / 32767, -1);
            case Int8Array:
              return Math.max(t / 127, -1);
            default:
              throw new Error("Invalid component type.");
          }
        }
        function hp(t, e) {
          switch (e.constructor) {
            case Float32Array:
              return t;
            case Uint32Array:
              return Math.round(4294967295 * t);
            case Uint16Array:
              return Math.round(65535 * t);
            case Uint8Array:
              return Math.round(255 * t);
            case Int32Array:
              return Math.round(2147483647 * t);
            case Int16Array:
              return Math.round(32767 * t);
            case Int8Array:
              return Math.round(127 * t);
            default:
              throw new Error("Invalid component type.");
          }
        }
        const dp = {
          DEG2RAD: ep,
          RAD2DEG: np,
          generateUUID: ip,
          clamp: rp,
          euclideanModulo: sp,
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: op,
          damp: function (t, e, n, i) {
            return op(t, e, 1 - Math.exp(-n * i));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(sp(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            void 0 !== t && (tp = t);
            let e = (tp += 1831565813);
            return (
              (e = Math.imul(e ^ (e >>> 15), 1 | e)),
              (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
              ((e ^ (e >>> 14)) >>> 0) / 4294967296
            );
          },
          degToRad: function (t) {
            return t * ep;
          },
          radToDeg: function (t) {
            return t * np;
          },
          isPowerOfTwo: ap,
          ceilPowerOfTwo: lp,
          floorPowerOfTwo: cp,
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
              o = Math.sin,
              a = s(n / 2),
              l = o(n / 2),
              c = s((e + i) / 2),
              u = o((e + i) / 2),
              h = s((e - i) / 2),
              d = o((e - i) / 2),
              p = s((i - e) / 2),
              f = o((i - e) / 2);
            switch (r) {
              case "XYX":
                t.set(a * u, l * h, l * d, a * c);
                break;
              case "YZY":
                t.set(l * d, a * u, l * h, a * c);
                break;
              case "ZXZ":
                t.set(l * h, l * d, a * u, a * c);
                break;
              case "XZX":
                t.set(a * u, l * f, l * p, a * c);
                break;
              case "YXY":
                t.set(l * p, a * u, l * f, a * c);
                break;
              case "ZYZ":
                t.set(l * f, l * p, a * u, a * c);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    r
                );
            }
          },
          normalize: hp,
          denormalize: up,
        };
        class pp {
          constructor(t = 0, e = 0) {
            (pp.prototype.isVector2 = !0), (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]),
              (this.y = i[1] * e + i[4] * n + i[7]),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(rp(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e) {
            return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              s = this.y - t.y;
            return (
              (this.x = r * n - s * i + t.x),
              (this.y = r * i + s * n + t.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        }
        class fp {
          constructor(t, e, n, i, r, s, o, a, l) {
            (fp.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              void 0 !== t && this.set(t, e, n, i, r, s, o, a, l);
          }
          set(t, e, n, i, r, s, o, a, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = o),
              (c[3] = e),
              (c[4] = r),
              (c[5] = a),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              o = n[3],
              a = n[6],
              l = n[1],
              c = n[4],
              u = n[7],
              h = n[2],
              d = n[5],
              p = n[8],
              f = i[0],
              m = i[3],
              g = i[6],
              v = i[1],
              y = i[4],
              _ = i[7],
              x = i[2],
              b = i[5],
              w = i[8];
            return (
              (r[0] = s * f + o * v + a * x),
              (r[3] = s * m + o * y + a * b),
              (r[6] = s * g + o * _ + a * w),
              (r[1] = l * f + c * v + u * x),
              (r[4] = l * m + c * y + u * b),
              (r[7] = l * g + c * _ + u * w),
              (r[2] = h * f + d * v + p * x),
              (r[5] = h * m + d * y + p * b),
              (r[8] = h * g + d * _ + p * w),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8];
            return (
              e * s * c -
              e * o * l -
              n * r * c +
              n * o * a +
              i * r * l -
              i * s * a
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              u = c * s - o * l,
              h = o * a - c * r,
              d = l * r - s * a,
              p = e * u + n * h + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return (
              (t[0] = u * f),
              (t[1] = (i * l - c * n) * f),
              (t[2] = (o * n - i * s) * f),
              (t[3] = h * f),
              (t[4] = (c * e - i * a) * f),
              (t[5] = (i * r - o * e) * f),
              (t[6] = d * f),
              (t[7] = (n * a - l * e) * f),
              (t[8] = (s * e - n * r) * f),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, i, r, s, o) {
            const a = Math.cos(r),
              l = Math.sin(r);
            return (
              this.set(
                n * a,
                n * l,
                -n * (a * s + l * o) + s + t,
                -i * l,
                i * a,
                -i * (-l * s + a * o) + o + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            return this.premultiply(mp.makeScale(t, e)), this;
          }
          rotate(t) {
            return this.premultiply(mp.makeRotation(-t)), this;
          }
          translate(t, e) {
            return this.premultiply(mp.makeTranslation(t, e)), this;
          }
          makeTranslation(t, e) {
            return (
              t.isVector2
                ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
                : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
              this
            );
          }
          makeRotation(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
          }
          makeScale(t, e) {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        const mp = new fp();
        function gp(t) {
          for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
          return !1;
        }
        Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array;
        function vp(t) {
          return document.createElementNS("http://www.w3.org/1999/xhtml", t);
        }
        function yp() {
          const t = vp("canvas");
          return (t.style.display = "block"), t;
        }
        const _p = {};
        function xp(t) {
          t in _p || ((_p[t] = !0), console.warn(t));
        }
        function bp(t) {
          return t < 0.04045
            ? 0.0773993808 * t
            : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function wp(t) {
          return t < 0.0031308
            ? 12.92 * t
            : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        const Ep = new fp().fromArray([
            0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974,
            -1e-7, 1e-7, 0.9105199,
          ]),
          Sp = new fp().fromArray([
            1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571,
            -0.0786361, 1e-7, 0, 1.0982735,
          ]);
        const Mp = {
            [Ud]: (t) => t,
            [Dd]: (t) => t.convertSRGBToLinear(),
            [Fd]: function (t) {
              return t.convertSRGBToLinear().applyMatrix3(Sp);
            },
          },
          Tp = {
            [Ud]: (t) => t,
            [Dd]: (t) => t.convertLinearToSRGB(),
            [Fd]: function (t) {
              return t.applyMatrix3(Ep).convertLinearToSRGB();
            },
          },
          Ap = {
            enabled: !0,
            get legacyMode() {
              return (
                console.warn(
                  "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
                ),
                !this.enabled
              );
            },
            set legacyMode(t) {
              console.warn(
                "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
              ),
                (this.enabled = !t);
            },
            get workingColorSpace() {
              return Ud;
            },
            set workingColorSpace(t) {
              console.warn(
                "THREE.ColorManagement: .workingColorSpace is readonly."
              );
            },
            convert: function (t, e, n) {
              if (!1 === this.enabled || e === n || !e || !n) return t;
              const i = Mp[e],
                r = Tp[n];
              if (void 0 === i || void 0 === r)
                throw new Error(
                  `Unsupported color space conversion, "${e}" to "${n}".`
                );
              return r(i(t));
            },
            fromWorkingColorSpace: function (t, e) {
              return this.convert(t, this.workingColorSpace, e);
            },
            toWorkingColorSpace: function (t, e) {
              return this.convert(t, e, this.workingColorSpace);
            },
          };
        let Rp;
        class Cp {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === Rp && (Rp = vp("canvas")),
                (Rp.width = t.width),
                (Rp.height = t.height);
              const n = Rp.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = Rp);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
          static sRGBToLinear(t) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const e = vp("canvas");
              (e.width = t.width), (e.height = t.height);
              const n = e.getContext("2d");
              n.drawImage(t, 0, 0, t.width, t.height);
              const i = n.getImageData(0, 0, t.width, t.height),
                r = i.data;
              for (let t = 0; t < r.length; t++) r[t] = 255 * bp(r[t] / 255);
              return n.putImageData(i, 0, 0), e;
            }
            if (t.data) {
              const e = t.data.slice(0);
              for (let t = 0; t < e.length; t++)
                e instanceof Uint8Array || e instanceof Uint8ClampedArray
                  ? (e[t] = Math.floor(255 * bp(e[t] / 255)))
                  : (e[t] = bp(e[t]));
              return {
                data: e,
                width: t.width,
                height: t.height,
              };
            }
            return (
              console.warn(
                "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
              ),
              t
            );
          }
        }
        let Lp = 0;
        class Pp {
          constructor(t = null) {
            (this.isSource = !0),
              Object.defineProperty(this, "id", {
                value: Lp++,
              }),
              (this.uuid = ip()),
              (this.data = t),
              (this.version = 0);
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.images[this.uuid])
              return t.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: "",
              },
              i = this.data;
            if (null !== i) {
              let t;
              if (Array.isArray(i)) {
                t = [];
                for (let e = 0, n = i.length; e < n; e++)
                  i[e].isDataTexture
                    ? t.push(Op(i[e].image))
                    : t.push(Op(i[e]));
              } else t = Op(i);
              n.url = t;
            }
            return e || (t.images[this.uuid] = n), n;
          }
        }
        function Op(t) {
          return ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? Cp.getDataURL(t)
            : t.data
            ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        let Ip = 0;
        class Np extends Jd {
          constructor(
            t = Np.DEFAULT_IMAGE,
            e = Np.DEFAULT_MAPPING,
            n = 1001,
            i = 1001,
            r = 1006,
            s = 1008,
            o = 1023,
            a = 1009,
            l = Np.DEFAULT_ANISOTROPY,
            c = ""
          ) {
            super(),
              (this.isTexture = !0),
              Object.defineProperty(this, "id", {
                value: Ip++,
              }),
              (this.uuid = ip()),
              (this.name = ""),
              (this.source = new Pp(t)),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.channel = 0),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = o),
              (this.internalFormat = null),
              (this.type = a),
              (this.offset = new pp(0, 0)),
              (this.repeat = new pp(1, 1)),
              (this.center = new pp(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new fp()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              "string" == typeof c
                ? (this.colorSpace = c)
                : (xp(
                    "THREE.Texture: Property .encoding has been replaced by .colorSpace."
                  ),
                  (this.colorSpace = c === Id ? Dd : Nd)),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1),
              (this.needsPMREMUpdate = !1);
          }
          get image() {
            return this.source.data;
          }
          set image(t = null) {
            this.source.data = t;
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.source = t.source),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.channel = t.channel),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.colorSpace = t.colorSpace),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              (this.needsUpdate = !0),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(t).uuid,
              mapping: this.mapping,
              channel: this.channel,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              internalFormat: this.internalFormat,
              type: this.type,
              colorSpace: this.colorSpace,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            return (
              Object.keys(this.userData).length > 0 &&
                (n.userData = this.userData),
              e || (t.textures[this.uuid] = n),
              n
            );
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose",
            });
          }
          transformUv(t) {
            if (300 !== this.mapping) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case id:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case rd:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case sd:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case id:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case rd:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case sd:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && (this.version++, (this.source.needsUpdate = !0));
          }
          get encoding() {
            return (
              xp(
                "THREE.Texture: Property .encoding has been replaced by .colorSpace."
              ),
              this.colorSpace === Dd ? Id : 3e3
            );
          }
          set encoding(t) {
            xp(
              "THREE.Texture: Property .encoding has been replaced by .colorSpace."
            ),
              (this.colorSpace = t === Id ? Dd : Nd);
          }
        }
        (Np.DEFAULT_IMAGE = null),
          (Np.DEFAULT_MAPPING = 300),
          (Np.DEFAULT_ANISOTROPY = 1);
        class Dp {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (Dp.prototype.isVector4 = !0),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              (this.w = i);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t) {
            return (
              (this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this
            );
          }
          addScalar(t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t) {
            return (
              (this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this
            );
          }
          subScalar(t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (
              (this.x *= t.x),
              (this.y *= t.y),
              (this.z *= t.z),
              (this.w *= t.w),
              this
            );
          }
          multiplyScalar(t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
              (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
              (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
              (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = 0.01,
              o = 0.1,
              a = t.elements,
              l = a[0],
              c = a[4],
              u = a[8],
              h = a[1],
              d = a[5],
              p = a[9],
              f = a[2],
              m = a[6],
              g = a[10];
            if (
              Math.abs(c - h) < s &&
              Math.abs(u - f) < s &&
              Math.abs(p - m) < s
            ) {
              if (
                Math.abs(c + h) < o &&
                Math.abs(u + f) < o &&
                Math.abs(p + m) < o &&
                Math.abs(l + d + g - 3) < o
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (l + 1) / 2,
                a = (d + 1) / 2,
                v = (g + 1) / 2,
                y = (c + h) / 4,
                _ = (u + f) / 4,
                x = (p + m) / 4;
              return (
                t > a && t > v
                  ? t < s
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = y / n), (r = _ / n))
                  : a > v
                  ? a < s
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(a)), (n = y / i), (r = x / i))
                  : v < s
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(v)), (n = _ / r), (i = x / r)),
                this.set(n, i, r, e),
                this
              );
            }
            let v = Math.sqrt(
              (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
            );
            return (
              Math.abs(v) < 0.001 && (v = 1),
              (this.x = (m - p) / v),
              (this.y = (u - f) / v),
              (this.z = (h - c) / v),
              (this.w = Math.acos((l + d + g - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              (this.w = Math.trunc(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        }
        class Up extends Jd {
          constructor(t = 1, e = 1, n = {}) {
            super(),
              (this.isRenderTarget = !0),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new Dp(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new Dp(0, 0, t, e));
            const i = {
              width: t,
              height: e,
              depth: 1,
            };
            void 0 !== n.encoding &&
              (xp(
                "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (n.colorSpace = n.encoding === Id ? Dd : Nd)),
              (this.texture = new Np(
                i,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.flipY = !1),
              (this.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.internalFormat =
                void 0 !== n.internalFormat ? n.internalFormat : null),
              (this.texture.minFilter =
                void 0 !== n.minFilter ? n.minFilter : cd),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer =
                void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture =
                void 0 !== n.depthTexture ? n.depthTexture : null),
              (this.samples = void 0 !== n.samples ? n.samples : 0);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.scissor.copy(t.scissor),
              (this.scissorTest = t.scissorTest),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.texture.isRenderTargetTexture = !0);
            const e = Object.assign({}, t.texture.image);
            return (
              (this.texture.source = new Pp(e)),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              null !== t.depthTexture &&
                (this.depthTexture = t.depthTexture.clone()),
              (this.samples = t.samples),
              this
            );
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose",
            });
          }
        }
        class Fp extends Up {
          constructor(t = 1, e = 1, n = {}) {
            super(t, e, n), (this.isWebGLRenderTarget = !0);
          }
        }
        class kp extends Np {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isDataArrayTexture = !0),
              (this.image = {
                data: t,
                width: e,
                height: n,
                depth: i,
              }),
              (this.magFilter = od),
              (this.minFilter = od),
              (this.wrapR = rd),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class Bp extends Np {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.isData3DTexture = !0),
              (this.image = {
                data: t,
                width: e,
                height: n,
                depth: i,
              }),
              (this.magFilter = od),
              (this.minFilter = od),
              (this.wrapR = rd),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        class zp {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this.isQuaternion = !0),
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i);
          }
          static slerpFlat(t, e, n, i, r, s, o) {
            let a = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              u = n[i + 3];
            const h = r[s + 0],
              d = r[s + 1],
              p = r[s + 2],
              f = r[s + 3];
            if (0 === o)
              return (
                (t[e + 0] = a),
                (t[e + 1] = l),
                (t[e + 2] = c),
                void (t[e + 3] = u)
              );
            if (1 === o)
              return (
                (t[e + 0] = h),
                (t[e + 1] = d),
                (t[e + 2] = p),
                void (t[e + 3] = f)
              );
            if (u !== f || a !== h || l !== d || c !== p) {
              let t = 1 - o;
              const e = a * h + l * d + c * p + u * f,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  s = Math.atan2(r, e * n);
                (t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r);
              }
              const r = o * n;
              if (
                ((a = a * t + h * r),
                (l = l * t + d * r),
                (c = c * t + p * r),
                (u = u * t + f * r),
                t === 1 - o)
              ) {
                const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                (a *= t), (l *= t), (c *= t), (u *= t);
              }
            }
            (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const o = n[i],
              a = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              u = r[s],
              h = r[s + 1],
              d = r[s + 2],
              p = r[s + 3];
            return (
              (t[e] = o * p + c * u + a * d - l * h),
              (t[e + 1] = a * p + c * h + l * u - o * d),
              (t[e + 2] = l * p + c * d + o * h - a * u),
              (t[e + 3] = c * p - o * u - a * h - l * d),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._order,
              o = Math.cos,
              a = Math.sin,
              l = o(n / 2),
              c = o(i / 2),
              u = o(r / 2),
              h = a(n / 2),
              d = a(i / 2),
              p = a(r / 2);
            switch (s) {
              case "XYZ":
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case "YXZ":
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              case "ZXY":
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case "ZYX":
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              case "YZX":
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case "XZY":
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    s
                );
            }
            return !1 !== e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              s = e[1],
              o = e[5],
              a = e[9],
              l = e[2],
              c = e[6],
              u = e[10],
              h = n + o + u;
            if (h > 0) {
              const t = 0.5 / Math.sqrt(h + 1);
              (this._w = 0.25 / t),
                (this._x = (c - a) * t),
                (this._y = (r - l) * t),
                (this._z = (s - i) * t);
            } else if (n > o && n > u) {
              const t = 2 * Math.sqrt(1 + n - o - u);
              (this._w = (c - a) / t),
                (this._x = 0.25 * t),
                (this._y = (i + s) / t),
                (this._z = (r + l) / t);
            } else if (o > u) {
              const t = 2 * Math.sqrt(1 + o - n - u);
              (this._w = (r - l) / t),
                (this._x = (i + s) / t),
                (this._y = 0.25 * t),
                (this._z = (a + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + u - n - o);
              (this._w = (s - i) / t),
                (this._x = (r + l) / t),
                (this._y = (a + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y),
                      (this._y = t.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -t.z),
                      (this._z = t.y),
                      (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(rp(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t) {
            return this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._w,
              o = e._x,
              a = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + s * o + i * l - r * a),
              (this._y = i * c + s * a + r * o - n * l),
              (this._z = r * c + s * l + n * a - i * o),
              (this._w = s * c - n * o - i * a - r * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              i = this._y,
              r = this._z,
              s = this._w;
            let o = s * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (o < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (o = -o))
                : this.copy(t),
              o >= 1)
            )
              return (
                (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
              );
            const a = 1 - o * o;
            if (a <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            const l = Math.sqrt(a),
              c = Math.atan2(l, o),
              u = Math.sin((1 - e) * c) / l,
              h = Math.sin(e * c) / l;
            return (
              (this._w = s * u + this._w * h),
              (this._x = n * u + this._x * h),
              (this._y = i * u + this._y * h),
              (this._z = r * u + this._z * h),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n);
          }
          random() {
            const t = Math.random(),
              e = Math.sqrt(1 - t),
              n = Math.sqrt(t),
              i = 2 * Math.PI * Math.random(),
              r = 2 * Math.PI * Math.random();
            return this.set(
              e * Math.cos(i),
              n * Math.sin(r),
              n * Math.cos(r),
              e * Math.sin(i)
            );
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this
            );
          }
          toJSON() {
            return this.toArray();
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
          }
        }
        class Hp {
          constructor(t = 0, e = 0, n = 0) {
            (Hp.prototype.isVector3 = !0),
              (this.x = t),
              (this.y = e),
              (this.z = n);
          }
          set(t, e, n) {
            return (
              void 0 === n && (n = this.z),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              this
            );
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t) {
            return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          }
          sub(t) {
            return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          }
          applyEuler(t) {
            return this.applyQuaternion(Gp.setFromEuler(t));
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(Gp.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              o = t.z,
              a = t.w,
              l = a * e + s * i - o * n,
              c = a * n + o * e - r * i,
              u = a * i + r * n - s * e,
              h = -r * e - s * n - o * i;
            return (
              (this.x = l * a + h * -r + c * -o - u * -s),
              (this.y = c * a + h * -s + u * -r - l * -o),
              (this.z = u * a + h * -o + l * -s - c * -r),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
              t.projectionMatrix
            );
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
              t.matrixWorld
            );
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = Math.trunc(this.x)),
              (this.y = Math.trunc(this.y)),
              (this.z = Math.trunc(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t) {
            return this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = e.x,
              o = e.y,
              a = e.z;
            return (
              (this.x = i * a - r * o),
              (this.y = r * s - n * a),
              (this.z = n * o - i * s),
              this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return Vp.copy(this).projectOnVector(t), this.sub(Vp);
          }
          reflect(t) {
            return this.sub(Vp.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(rp(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          }
          manhattanDistanceTo(t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return (
              (this.x = i * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = i * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (
              (this.x = t * Math.sin(e)),
              (this.y = n),
              (this.z = t * Math.cos(e)),
              this
            );
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          setFromEuler(t) {
            return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
          }
          setFromColor(t) {
            return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
          randomDirection() {
            const t = 2 * (Math.random() - 0.5),
              e = Math.random() * Math.PI * 2,
              n = Math.sqrt(1 - t ** 2);
            return (
              (this.x = n * Math.cos(e)),
              (this.y = n * Math.sin(e)),
              (this.z = t),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        }
        const Vp = new Hp(),
          Gp = new zp();
        class Wp {
          constructor(
            t = new Hp(1 / 0, 1 / 0, 1 / 0),
            e = new Hp(-1 / 0, -1 / 0, -1 / 0)
          ) {
            (this.isBox3 = !0), (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e += 3)
              this.expandByPoint(qp.fromArray(t, e));
            return this;
          }
          setFromBufferAttribute(t) {
            this.makeEmpty();
            for (let e = 0, n = t.count; e < n; e++)
              this.expandByPoint(qp.fromBufferAttribute(t, e));
            return this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = qp.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t, e = !1) {
            return this.makeEmpty(), this.expandByObject(t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.subVectors(this.max, this.min);
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t, e = !1) {
            if ((t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox))
              null === t.boundingBox && t.computeBoundingBox(),
                Xp.copy(t.boundingBox),
                Xp.applyMatrix4(t.matrixWorld),
                this.union(Xp);
            else {
              const n = t.geometry;
              if (void 0 !== n)
                if (
                  e &&
                  void 0 !== n.attributes &&
                  void 0 !== n.attributes.position
                ) {
                  const e = n.attributes.position;
                  for (let n = 0, i = e.count; n < i; n++)
                    qp.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                      this.expandByPoint(qp);
                } else
                  null === n.boundingBox && n.computeBoundingBox(),
                    Xp.copy(n.boundingBox),
                    Xp.applyMatrix4(t.matrixWorld),
                    this.union(Xp);
            }
            const n = t.children;
            for (let t = 0, i = n.length; t < i; t++)
              this.expandByObject(n[t], e);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return e.set(
              (t.x - this.min.x) / (this.max.x - this.min.x),
              (t.y - this.min.y) / (this.max.y - this.min.y),
              (t.z - this.min.z) / (this.max.z - this.min.z)
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, qp),
              qp.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(tf),
              ef.subVectors(this.max, tf),
              Yp.subVectors(t.a, tf),
              Kp.subVectors(t.b, tf),
              $p.subVectors(t.c, tf),
              Zp.subVectors(Kp, Yp),
              Jp.subVectors($p, Kp),
              Qp.subVectors(Yp, $p);
            let e = [
              0,
              -Zp.z,
              Zp.y,
              0,
              -Jp.z,
              Jp.y,
              0,
              -Qp.z,
              Qp.y,
              Zp.z,
              0,
              -Zp.x,
              Jp.z,
              0,
              -Jp.x,
              Qp.z,
              0,
              -Qp.x,
              -Zp.y,
              Zp.x,
              0,
              -Jp.y,
              Jp.x,
              0,
              -Qp.y,
              Qp.x,
              0,
            ];
            return (
              !!sf(e, Yp, Kp, $p, ef) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!sf(e, Yp, Kp, $p, ef) &&
                (nf.crossVectors(Zp, Jp),
                (e = [nf.x, nf.y, nf.z]),
                sf(e, Yp, Kp, $p, ef)))
            );
          }
          clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
          }
          distanceToPoint(t) {
            return this.clampPoint(t, qp).distanceTo(t);
          }
          getBoundingSphere(t) {
            return (
              this.isEmpty()
                ? t.makeEmpty()
                : (this.getCenter(t.center),
                  (t.radius = 0.5 * this.getSize(qp).length())),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (jp[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                jp[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                jp[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                jp[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                jp[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                jp[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                jp[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                jp[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(jp)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        const jp = [
            new Hp(),
            new Hp(),
            new Hp(),
            new Hp(),
            new Hp(),
            new Hp(),
            new Hp(),
            new Hp(),
          ],
          qp = new Hp(),
          Xp = new Wp(),
          Yp = new Hp(),
          Kp = new Hp(),
          $p = new Hp(),
          Zp = new Hp(),
          Jp = new Hp(),
          Qp = new Hp(),
          tf = new Hp(),
          ef = new Hp(),
          nf = new Hp(),
          rf = new Hp();
        function sf(t, e, n, i, r) {
          for (let s = 0, o = t.length - 3; s <= o; s += 3) {
            rf.fromArray(t, s);
            const o =
                r.x * Math.abs(rf.x) +
                r.y * Math.abs(rf.y) +
                r.z * Math.abs(rf.z),
              a = e.dot(rf),
              l = n.dot(rf),
              c = i.dot(rf);
            if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
          }
          return !0;
        }
        const of = new Wp(),
          af = new Hp(),
          lf = new Hp();
        class cf {
          constructor(t = new Hp(), e = -1) {
            (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : of.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++)
              i = Math.max(i, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(i)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return this.isEmpty()
              ? (t.makeEmpty(), t)
              : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t);
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            if (this.isEmpty())
              return this.center.copy(t), (this.radius = 0), this;
            af.subVectors(t, this.center);
            const e = af.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.addScaledVector(af, n / t), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return t.isEmpty()
              ? this
              : this.isEmpty()
              ? (this.copy(t), this)
              : (!0 === this.center.equals(t.center)
                  ? (this.radius = Math.max(this.radius, t.radius))
                  : (lf.subVectors(t.center, this.center).setLength(t.radius),
                    this.expandByPoint(af.copy(t.center).add(lf)),
                    this.expandByPoint(af.copy(t.center).sub(lf))),
                this);
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const uf = new Hp(),
          hf = new Hp(),
          df = new Hp(),
          pf = new Hp(),
          ff = new Hp(),
          mf = new Hp(),
          gf = new Hp();
        class vf {
          constructor(t = new Hp(), e = new Hp(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          }
          at(t, e) {
            return e.copy(this.origin).addScaledVector(this.direction, t);
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, uf)), this;
          }
          closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.origin).addScaledVector(this.direction, n);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = uf.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (uf.copy(this.origin).addScaledVector(this.direction, e),
                uf.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, i) {
            hf.copy(t).add(e).multiplyScalar(0.5),
              df.copy(e).sub(t).normalize(),
              pf.copy(this.origin).sub(hf);
            const r = 0.5 * t.distanceTo(e),
              s = -this.direction.dot(df),
              o = pf.dot(this.direction),
              a = -pf.dot(df),
              l = pf.lengthSq(),
              c = Math.abs(1 - s * s);
            let u, h, d, p;
            if (c > 0)
              if (((u = s * a - o), (h = s * o - a), (p = r * c), u >= 0))
                if (h >= -p)
                  if (h <= p) {
                    const t = 1 / c;
                    (u *= t),
                      (h *= t),
                      (d =
                        u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l);
                  } else
                    (h = r),
                      (u = Math.max(0, -(s * h + o))),
                      (d = -u * u + h * (h + 2 * a) + l);
                else
                  (h = -r),
                    (u = Math.max(0, -(s * h + o))),
                    (d = -u * u + h * (h + 2 * a) + l);
              else
                h <= -p
                  ? ((u = Math.max(0, -(-s * r + o))),
                    (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                    (d = -u * u + h * (h + 2 * a) + l))
                  : h <= p
                  ? ((u = 0),
                    (h = Math.min(Math.max(-r, -a), r)),
                    (d = h * (h + 2 * a) + l))
                  : ((u = Math.max(0, -(s * r + o))),
                    (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                    (d = -u * u + h * (h + 2 * a) + l));
            else
              (h = s > 0 ? -r : r),
                (u = Math.max(0, -(s * h + o))),
                (d = -u * u + h * (h + 2 * a) + l);
            return (
              n && n.copy(this.origin).addScaledVector(this.direction, u),
              i && i.copy(hf).addScaledVector(df, h),
              d
            );
          }
          intersectSphere(t, e) {
            uf.subVectors(t.center, this.origin);
            const n = uf.dot(this.direction),
              i = uf.dot(uf) - n * n,
              r = t.radius * t.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i),
              o = n - s,
              a = n + s;
            return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            return t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, i, r, s, o, a;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              u = 1 / this.direction.z,
              h = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
                : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
              c >= 0
                ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
                : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
              n > s || r > i
                ? null
                : ((r > n || isNaN(n)) && (n = r),
                  (s < i || isNaN(i)) && (i = s),
                  u >= 0
                    ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                    : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
                  n > a || o > i
                    ? null
                    : ((o > n || n != n) && (n = o),
                      (a < i || i != i) && (i = a),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, uf);
          }
          intersectTriangle(t, e, n, i, r) {
            ff.subVectors(e, t), mf.subVectors(n, t), gf.crossVectors(ff, mf);
            let s,
              o = this.direction.dot(gf);
            if (o > 0) {
              if (i) return null;
              s = 1;
            } else {
              if (!(o < 0)) return null;
              (s = -1), (o = -o);
            }
            pf.subVectors(this.origin, t);
            const a = s * this.direction.dot(mf.crossVectors(pf, mf));
            if (a < 0) return null;
            const l = s * this.direction.dot(ff.cross(pf));
            if (l < 0) return null;
            if (a + l > o) return null;
            const c = -s * pf.dot(gf);
            return c < 0 ? null : this.at(c / o, r);
          }
          applyMatrix4(t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          }
          equals(t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class yf {
          constructor(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
            (yf.prototype.isMatrix4 = !0),
              (this.elements = [
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]),
              void 0 !== t &&
                this.set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m);
          }
          set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = s),
              (g[9] = o),
              (g[13] = a),
              (g[2] = l),
              (g[6] = c),
              (g[10] = u),
              (g[14] = h),
              (g[3] = d),
              (g[7] = p),
              (g[11] = f),
              (g[15] = m),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new yf().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(
                e[0],
                e[3],
                e[6],
                0,
                e[1],
                e[4],
                e[7],
                0,
                e[2],
                e[5],
                e[8],
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / _f.setFromMatrixColumn(t, 0).length(),
              r = 1 / _f.setFromMatrixColumn(t, 1).length(),
              s = 1 / _f.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              s = Math.cos(n),
              o = Math.sin(n),
              a = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              u = Math.sin(r);
            if ("XYZ" === t.order) {
              const t = s * c,
                n = s * u,
                i = o * c,
                r = o * u;
              (e[0] = a * c),
                (e[4] = -a * u),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -o * a),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = s * a);
            } else if ("YXZ" === t.order) {
              const t = a * c,
                n = a * u,
                i = l * c,
                r = l * u;
              (e[0] = t + r * o),
                (e[4] = i * o - n),
                (e[8] = s * l),
                (e[1] = s * u),
                (e[5] = s * c),
                (e[9] = -o),
                (e[2] = n * o - i),
                (e[6] = r + t * o),
                (e[10] = s * a);
            } else if ("ZXY" === t.order) {
              const t = a * c,
                n = a * u,
                i = l * c,
                r = l * u;
              (e[0] = t - r * o),
                (e[4] = -s * u),
                (e[8] = i + n * o),
                (e[1] = n + i * o),
                (e[5] = s * c),
                (e[9] = r - t * o),
                (e[2] = -s * l),
                (e[6] = o),
                (e[10] = s * a);
            } else if ("ZYX" === t.order) {
              const t = s * c,
                n = s * u,
                i = o * c,
                r = o * u;
              (e[0] = a * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = a * u),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = o * a),
                (e[10] = s * a);
            } else if ("YZX" === t.order) {
              const t = s * a,
                n = s * l,
                i = o * a,
                r = o * l;
              (e[0] = a * c),
                (e[4] = r - t * u),
                (e[8] = i * u + n),
                (e[1] = u),
                (e[5] = s * c),
                (e[9] = -o * c),
                (e[2] = -l * c),
                (e[6] = n * u + i),
                (e[10] = t - r * u);
            } else if ("XZY" === t.order) {
              const t = s * a,
                n = s * l,
                i = o * a,
                r = o * l;
              (e[0] = a * c),
                (e[4] = -u),
                (e[8] = l * c),
                (e[1] = t * u + r),
                (e[5] = s * c),
                (e[9] = n * u - i),
                (e[2] = i * u - n),
                (e[6] = o * c),
                (e[10] = r * u + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(bf, t, wf);
          }
          lookAt(t, e, n) {
            const i = this.elements;
            return (
              Mf.subVectors(t, e),
              0 === Mf.lengthSq() && (Mf.z = 1),
              Mf.normalize(),
              Ef.crossVectors(n, Mf),
              0 === Ef.lengthSq() &&
                (1 === Math.abs(n.z) ? (Mf.x += 1e-4) : (Mf.z += 1e-4),
                Mf.normalize(),
                Ef.crossVectors(n, Mf)),
              Ef.normalize(),
              Sf.crossVectors(Mf, Ef),
              (i[0] = Ef.x),
              (i[4] = Sf.x),
              (i[8] = Mf.x),
              (i[1] = Ef.y),
              (i[5] = Sf.y),
              (i[9] = Mf.y),
              (i[2] = Ef.z),
              (i[6] = Sf.z),
              (i[10] = Mf.z),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              o = n[4],
              a = n[8],
              l = n[12],
              c = n[1],
              u = n[5],
              h = n[9],
              d = n[13],
              p = n[2],
              f = n[6],
              m = n[10],
              g = n[14],
              v = n[3],
              y = n[7],
              _ = n[11],
              x = n[15],
              b = i[0],
              w = i[4],
              E = i[8],
              S = i[12],
              M = i[1],
              T = i[5],
              A = i[9],
              R = i[13],
              C = i[2],
              L = i[6],
              P = i[10],
              O = i[14],
              I = i[3],
              N = i[7],
              D = i[11],
              U = i[15];
            return (
              (r[0] = s * b + o * M + a * C + l * I),
              (r[4] = s * w + o * T + a * L + l * N),
              (r[8] = s * E + o * A + a * P + l * D),
              (r[12] = s * S + o * R + a * O + l * U),
              (r[1] = c * b + u * M + h * C + d * I),
              (r[5] = c * w + u * T + h * L + d * N),
              (r[9] = c * E + u * A + h * P + d * D),
              (r[13] = c * S + u * R + h * O + d * U),
              (r[2] = p * b + f * M + m * C + g * I),
              (r[6] = p * w + f * T + m * L + g * N),
              (r[10] = p * E + f * A + m * P + g * D),
              (r[14] = p * S + f * R + m * O + g * U),
              (r[3] = v * b + y * M + _ * C + x * I),
              (r[7] = v * w + y * T + _ * L + x * N),
              (r[11] = v * E + y * A + _ * P + x * D),
              (r[15] = v * S + y * R + _ * O + x * U),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              s = t[1],
              o = t[5],
              a = t[9],
              l = t[13],
              c = t[2],
              u = t[6],
              h = t[10],
              d = t[14];
            return (
              t[3] *
                (+r * a * u -
                  i * l * u -
                  r * o * h +
                  n * l * h +
                  i * o * d -
                  n * a * d) +
              t[7] *
                (+e * a * d -
                  e * l * h +
                  r * s * h -
                  i * s * d +
                  i * l * c -
                  r * a * c) +
              t[11] *
                (+e * l * u -
                  e * o * d -
                  r * s * u +
                  n * s * d +
                  r * o * c -
                  n * l * c) +
              t[15] *
                (-i * o * c -
                  e * a * u +
                  e * o * h +
                  i * s * u -
                  n * s * h +
                  n * a * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const i = this.elements;
            return (
              t.isVector3
                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              u = t[9],
              h = t[10],
              d = t[11],
              p = t[12],
              f = t[13],
              m = t[14],
              g = t[15],
              v =
                u * m * l -
                f * h * l +
                f * a * d -
                o * m * d -
                u * a * g +
                o * h * g,
              y =
                p * h * l -
                c * m * l -
                p * a * d +
                s * m * d +
                c * a * g -
                s * h * g,
              _ =
                c * f * l -
                p * u * l +
                p * o * d -
                s * f * d -
                c * o * g +
                s * u * g,
              x =
                p * u * a -
                c * f * a -
                p * o * h +
                s * f * h +
                c * o * m -
                s * u * m,
              b = e * v + n * y + i * _ + r * x;
            if (0 === b)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return (
              (t[0] = v * w),
              (t[1] =
                (f * h * r -
                  u * m * r -
                  f * i * d +
                  n * m * d +
                  u * i * g -
                  n * h * g) *
                w),
              (t[2] =
                (o * m * r -
                  f * a * r +
                  f * i * l -
                  n * m * l -
                  o * i * g +
                  n * a * g) *
                w),
              (t[3] =
                (u * a * r -
                  o * h * r -
                  u * i * l +
                  n * h * l +
                  o * i * d -
                  n * a * d) *
                w),
              (t[4] = y * w),
              (t[5] =
                (c * m * r -
                  p * h * r +
                  p * i * d -
                  e * m * d -
                  c * i * g +
                  e * h * g) *
                w),
              (t[6] =
                (p * a * r -
                  s * m * r -
                  p * i * l +
                  e * m * l +
                  s * i * g -
                  e * a * g) *
                w),
              (t[7] =
                (s * h * r -
                  c * a * r +
                  c * i * l -
                  e * h * l -
                  s * i * d +
                  e * a * d) *
                w),
              (t[8] = _ * w),
              (t[9] =
                (p * u * r -
                  c * f * r -
                  p * n * d +
                  e * f * d +
                  c * n * g -
                  e * u * g) *
                w),
              (t[10] =
                (s * f * r -
                  p * o * r +
                  p * n * l -
                  e * f * l -
                  s * n * g +
                  e * o * g) *
                w),
              (t[11] =
                (c * o * r -
                  s * u * r -
                  c * n * l +
                  e * u * l +
                  s * n * d -
                  e * o * d) *
                w),
              (t[12] = x * w),
              (t[13] =
                (c * f * i -
                  p * u * i +
                  p * n * h -
                  e * f * h -
                  c * n * m +
                  e * u * m) *
                w),
              (t[14] =
                (p * o * i -
                  s * f * i -
                  p * n * a +
                  e * f * a +
                  s * n * m -
                  e * o * m) *
                w),
              (t[15] =
                (s * u * i -
                  c * o * i +
                  c * n * a -
                  e * u * a -
                  s * n * h +
                  e * o * h) *
                w),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          }
          makeTranslation(t, e, n) {
            return (
              t.isVector3
                ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
                : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
              this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              s = t.x,
              o = t.y,
              a = t.z,
              l = r * s,
              c = r * o;
            return (
              this.set(
                l * s + n,
                l * o - i * a,
                l * a + i * o,
                0,
                l * o + i * a,
                c * o + n,
                c * a - i * s,
                0,
                l * a - i * o,
                c * a + i * s,
                r * a * a + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(t, e, n, i, r, s) {
            return (
              this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              s = e._y,
              o = e._z,
              a = e._w,
              l = r + r,
              c = s + s,
              u = o + o,
              h = r * l,
              d = r * c,
              p = r * u,
              f = s * c,
              m = s * u,
              g = o * u,
              v = a * l,
              y = a * c,
              _ = a * u,
              x = n.x,
              b = n.y,
              w = n.z;
            return (
              (i[0] = (1 - (f + g)) * x),
              (i[1] = (d + _) * x),
              (i[2] = (p - y) * x),
              (i[3] = 0),
              (i[4] = (d - _) * b),
              (i[5] = (1 - (h + g)) * b),
              (i[6] = (m + v) * b),
              (i[7] = 0),
              (i[8] = (p + y) * w),
              (i[9] = (m - v) * w),
              (i[10] = (1 - (h + f)) * w),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const i = this.elements;
            let r = _f.set(i[0], i[1], i[2]).length();
            const s = _f.set(i[4], i[5], i[6]).length(),
              o = _f.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
              (t.x = i[12]),
              (t.y = i[13]),
              (t.z = i[14]),
              xf.copy(this);
            const a = 1 / r,
              l = 1 / s,
              c = 1 / o;
            return (
              (xf.elements[0] *= a),
              (xf.elements[1] *= a),
              (xf.elements[2] *= a),
              (xf.elements[4] *= l),
              (xf.elements[5] *= l),
              (xf.elements[6] *= l),
              (xf.elements[8] *= c),
              (xf.elements[9] *= c),
              (xf.elements[10] *= c),
              e.setFromRotationMatrix(xf),
              (n.x = r),
              (n.y = s),
              (n.z = o),
              this
            );
          }
          makePerspective(t, e, n, i, r, s, o = 2e3) {
            const a = this.elements,
              l = (2 * r) / (e - t),
              c = (2 * r) / (n - i),
              u = (e + t) / (e - t),
              h = (n + i) / (n - i);
            let d, p;
            if (o === $d)
              (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
            else {
              if (o !== Zd)
                throw new Error(
                  "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                    o
                );
              (d = -s / (s - r)), (p = (-s * r) / (s - r));
            }
            return (
              (a[0] = l),
              (a[4] = 0),
              (a[8] = u),
              (a[12] = 0),
              (a[1] = 0),
              (a[5] = c),
              (a[9] = h),
              (a[13] = 0),
              (a[2] = 0),
              (a[6] = 0),
              (a[10] = d),
              (a[14] = p),
              (a[3] = 0),
              (a[7] = 0),
              (a[11] = -1),
              (a[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, i, r, s, o = 2e3) {
            const a = this.elements,
              l = 1 / (e - t),
              c = 1 / (n - i),
              u = 1 / (s - r),
              h = (e + t) * l,
              d = (n + i) * c;
            let p, f;
            if (o === $d) (p = (s + r) * u), (f = -2 * u);
            else {
              if (o !== Zd)
                throw new Error(
                  "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                    o
                );
              (p = r * u), (f = -1 * u);
            }
            return (
              (a[0] = 2 * l),
              (a[4] = 0),
              (a[8] = 0),
              (a[12] = -h),
              (a[1] = 0),
              (a[5] = 2 * c),
              (a[9] = 0),
              (a[13] = -d),
              (a[2] = 0),
              (a[6] = 0),
              (a[10] = f),
              (a[14] = -p),
              (a[3] = 0),
              (a[7] = 0),
              (a[11] = 0),
              (a[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        const _f = new Hp(),
          xf = new yf(),
          bf = new Hp(0, 0, 0),
          wf = new Hp(1, 1, 1),
          Ef = new Hp(),
          Sf = new Hp(),
          Mf = new Hp(),
          Tf = new yf(),
          Af = new zp();
        class Rf {
          constructor(t = 0, e = 0, n = 0, i = Rf.DEFAULT_ORDER) {
            (this.isEuler = !0),
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, i = this._order) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e = this._order, n = !0) {
            const i = t.elements,
              r = i[0],
              s = i[4],
              o = i[8],
              a = i[1],
              l = i[5],
              c = i[9],
              u = i[2],
              h = i[6],
              d = i[10];
            switch (e) {
              case "XYZ":
                (this._y = Math.asin(rp(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-c, d)),
                      (this._z = Math.atan2(-s, r)))
                    : ((this._x = Math.atan2(h, l)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-rp(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._y = Math.atan2(o, d)),
                      (this._z = Math.atan2(a, l)))
                    : ((this._y = Math.atan2(-u, r)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(rp(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._y = Math.atan2(-u, d)),
                      (this._z = Math.atan2(-s, l)))
                    : ((this._y = 0), (this._z = Math.atan2(a, r)));
                break;
              case "ZYX":
                (this._y = Math.asin(-rp(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._x = Math.atan2(h, d)),
                      (this._z = Math.atan2(a, r)))
                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                break;
              case "YZX":
                (this._z = Math.asin(rp(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-c, l)),
                      (this._y = Math.atan2(-u, r)))
                    : ((this._x = 0), (this._y = Math.atan2(o, d)));
                break;
              case "XZY":
                (this._z = Math.asin(-rp(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(h, l)),
                      (this._y = Math.atan2(o, r)))
                    : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    e
                );
            }
            return (
              (this._order = e), !0 === n && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, e, n) {
            return (
              Tf.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(Tf, e, n)
            );
          }
          setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e);
          }
          reorder(t) {
            return Af.setFromEuler(this), this.setFromQuaternion(Af, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        }
        Rf.DEFAULT_ORDER = "XYZ";
        class Cf {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = (1 << t) >>> 0;
          }
          enable(t) {
            this.mask |= 1 << t;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= 1 << t;
          }
          disable(t) {
            this.mask &= ~(1 << t);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return !!(this.mask & t.mask);
          }
          isEnabled(t) {
            return !!(this.mask & (1 << t));
          }
        }
        let Lf = 0;
        const Pf = new Hp(),
          Of = new zp(),
          If = new yf(),
          Nf = new Hp(),
          Df = new Hp(),
          Uf = new Hp(),
          Ff = new zp(),
          kf = new Hp(1, 0, 0),
          Bf = new Hp(0, 1, 0),
          zf = new Hp(0, 0, 1),
          Hf = {
            type: "added",
          },
          Vf = {
            type: "removed",
          };
        class Gf extends Jd {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", {
                value: Lf++,
              }),
              (this.uuid = ip()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = Gf.DEFAULT_UP.clone());
            const t = new Hp(),
              e = new Rf(),
              n = new zp(),
              i = new Hp(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: {
                  configurable: !0,
                  enumerable: !0,
                  value: t,
                },
                rotation: {
                  configurable: !0,
                  enumerable: !0,
                  value: e,
                },
                quaternion: {
                  configurable: !0,
                  enumerable: !0,
                  value: n,
                },
                scale: {
                  configurable: !0,
                  enumerable: !0,
                  value: i,
                },
                modelViewMatrix: {
                  value: new yf(),
                },
                normalMatrix: {
                  value: new fp(),
                },
              }),
              (this.matrix = new yf()),
              (this.matrixWorld = new yf()),
              (this.matrixAutoUpdate = Gf.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.matrixWorldAutoUpdate =
                Gf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.layers = new Cf()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return (
              Of.setFromAxisAngle(t, e), this.quaternion.multiply(Of), this
            );
          }
          rotateOnWorldAxis(t, e) {
            return (
              Of.setFromAxisAngle(t, e), this.quaternion.premultiply(Of), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(kf, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(Bf, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(zf, t);
          }
          translateOnAxis(t, e) {
            return (
              Pf.copy(t).applyQuaternion(this.quaternion),
              this.position.add(Pf.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(kf, t);
          }
          translateY(t) {
            return this.translateOnAxis(Bf, t);
          }
          translateZ(t) {
            return this.translateOnAxis(zf, t);
          }
          localToWorld(t) {
            return (
              this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            );
          }
          worldToLocal(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.applyMatrix4(If.copy(this.matrixWorld).invert())
            );
          }
          lookAt(t, e, n) {
            t.isVector3 ? Nf.copy(t) : Nf.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
              Df.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? If.lookAt(Df, Nf, this.up)
                : If.lookAt(Nf, Df, this.up),
              this.quaternion.setFromRotationMatrix(If),
              i &&
                (If.extractRotation(i.matrixWorld),
                Of.setFromRotationMatrix(If),
                this.quaternion.premultiply(Of.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(Hf))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++)
                this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e &&
                ((t.parent = null),
                this.children.splice(e, 1),
                t.dispatchEvent(Vf)),
              this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            return this.remove(...this.children);
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              If.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1),
                If.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(If),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
              const i = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== i) return i;
            }
          }
          getObjectsByProperty(t, e) {
            let n = [];
            this[t] === e && n.push(this);
            for (let i = 0, r = this.children.length; i < r; i++) {
              const r = this.children[i].getObjectsByProperty(t, e);
              r.length > 0 && (n = n.concat(r));
            }
            return n;
          }
          getWorldPosition(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Df, t, Uf),
              t
            );
          }
          getWorldScale(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Df, Ff, t),
              t
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              (!0 !== i.matrixWorldAutoUpdate && !0 !== t) ||
                i.updateMatrixWorld(t);
            }
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t &&
                null !== n &&
                !0 === n.matrixWorldAutoUpdate &&
                n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const i = {};
            function r(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 &&
                (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              (i.up = this.up.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((i.type = "InstancedMesh"),
                (i.count = this.count),
                (i.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (i.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (i.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (i.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (i.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              i.geometry = r(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    r(t.shapes, i);
                  }
                else r(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((i.bindMode = this.bindMode),
                (i.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (r(t.skeletons, this.skeleton),
                  (i.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                  e.push(r(t.materials, this.material[n]));
                i.material = e;
              } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (let e = 0; e < this.children.length; e++)
                i.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              i.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                i.animations.push(r(t.animations, n));
              }
            }
            if (e) {
              const e = s(t.geometries),
                i = s(t.materials),
                r = s(t.textures),
                o = s(t.images),
                a = s(t.shapes),
                l = s(t.skeletons),
                c = s(t.animations),
                u = s(t.nodes);
              e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                o.length > 0 && (n.images = o),
                a.length > 0 && (n.shapes = a),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c),
                u.length > 0 && (n.nodes = u);
            }
            return (n.object = i), n;
            function s(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.animations = t.animations.slice()),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone());
              }
            return this;
          }
        }
        (Gf.DEFAULT_UP = new Hp(0, 1, 0)),
          (Gf.DEFAULT_MATRIX_AUTO_UPDATE = !0),
          (Gf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
        const Wf = new Hp(),
          jf = new Hp(),
          qf = new Hp(),
          Xf = new Hp(),
          Yf = new Hp(),
          Kf = new Hp(),
          $f = new Hp(),
          Zf = new Hp(),
          Jf = new Hp(),
          Qf = new Hp();
        let tm = !1;
        class em {
          constructor(t = new Hp(), e = new Hp(), n = new Hp()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, i) {
            i.subVectors(n, e), Wf.subVectors(t, e), i.cross(Wf);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, i, r) {
            Wf.subVectors(i, e), jf.subVectors(n, e), qf.subVectors(t, e);
            const s = Wf.dot(Wf),
              o = Wf.dot(jf),
              a = Wf.dot(qf),
              l = jf.dot(jf),
              c = jf.dot(qf),
              u = s * l - o * o;
            if (0 === u) return r.set(-2, -1, -1);
            const h = 1 / u,
              d = (l * a - o * c) * h,
              p = (s * c - o * a) * h;
            return r.set(1 - d - p, p, d);
          }
          static containsPoint(t, e, n, i) {
            return (
              this.getBarycoord(t, e, n, i, Xf),
              Xf.x >= 0 && Xf.y >= 0 && Xf.x + Xf.y <= 1
            );
          }
          static getUV(t, e, n, i, r, s, o, a) {
            return (
              !1 === tm &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (tm = !0)),
              this.getInterpolation(t, e, n, i, r, s, o, a)
            );
          }
          static getInterpolation(t, e, n, i, r, s, o, a) {
            return (
              this.getBarycoord(t, e, n, i, Xf),
              a.setScalar(0),
              a.addScaledVector(r, Xf.x),
              a.addScaledVector(s, Xf.y),
              a.addScaledVector(o, Xf.z),
              a
            );
          }
          static isFrontFacing(t, e, n, i) {
            return (
              Wf.subVectors(n, e), jf.subVectors(t, e), Wf.cross(jf).dot(i) < 0
            );
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, i) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            );
          }
          setFromAttributeAndIndices(t, e, n, i) {
            return (
              this.a.fromBufferAttribute(t, e),
              this.b.fromBufferAttribute(t, n),
              this.c.fromBufferAttribute(t, i),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              Wf.subVectors(this.c, this.b),
              jf.subVectors(this.a, this.b),
              0.5 * Wf.cross(jf).length()
            );
          }
          getMidpoint(t) {
            return t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(t) {
            return em.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(t, e) {
            return em.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, i, r) {
            return (
              !1 === tm &&
                (console.warn(
                  "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
                ),
                (tm = !0)),
              em.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            );
          }
          getInterpolation(t, e, n, i, r) {
            return em.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
          }
          containsPoint(t) {
            return em.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return em.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            const n = this.a,
              i = this.b,
              r = this.c;
            let s, o;
            Yf.subVectors(i, n), Kf.subVectors(r, n), Zf.subVectors(t, n);
            const a = Yf.dot(Zf),
              l = Kf.dot(Zf);
            if (a <= 0 && l <= 0) return e.copy(n);
            Jf.subVectors(t, i);
            const c = Yf.dot(Jf),
              u = Kf.dot(Jf);
            if (c >= 0 && u <= c) return e.copy(i);
            const h = a * u - c * l;
            if (h <= 0 && a >= 0 && c <= 0)
              return (s = a / (a - c)), e.copy(n).addScaledVector(Yf, s);
            Qf.subVectors(t, r);
            const d = Yf.dot(Qf),
              p = Kf.dot(Qf);
            if (p >= 0 && d <= p) return e.copy(r);
            const f = d * l - a * p;
            if (f <= 0 && l >= 0 && p <= 0)
              return (o = l / (l - p)), e.copy(n).addScaledVector(Kf, o);
            const m = c * p - d * u;
            if (m <= 0 && u - c >= 0 && d - p >= 0)
              return (
                $f.subVectors(r, i),
                (o = (u - c) / (u - c + (d - p))),
                e.copy(i).addScaledVector($f, o)
              );
            const g = 1 / (m + f + h);
            return (
              (s = f * g),
              (o = h * g),
              e.copy(n).addScaledVector(Yf, s).addScaledVector(Kf, o)
            );
          }
          equals(t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          }
        }
        let nm = 0;
        class im extends Jd {
          constructor() {
            super(),
              (this.isMaterial = !0),
              Object.defineProperty(this, "id", {
                value: nm++,
              }),
              (this.uuid = ip()),
              (this.name = ""),
              (this.type = "Material"),
              (this.blending = 1),
              (this.side = Th),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.alphaHash = !1),
              (this.blendSrc = 204),
              (this.blendDst = 205),
              (this.blendEquation = Ch),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = kd),
              (this.stencilZFail = kd),
              (this.stencilZPass = kd),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.forceSinglePass = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++,
              (this._alphaTest = t);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(
                    `THREE.Material: parameter '${e}' has value of undefined.`
                  );
                  continue;
                }
                const i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                    );
              }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e &&
              (t = {
                textures: {},
                images: {},
              });
            const n = {
              metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function i(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              "" !== this.name && (n.name = this.name),
              this.color &&
                this.color.isColor &&
                (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              void 0 !== this.sheen && (n.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (n.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness &&
                (n.sheenRoughness = this.sheenRoughness),
              this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity &&
                (n.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (n.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              void 0 !== this.iridescence && (n.iridescence = this.iridescence),
              void 0 !== this.iridescenceIOR &&
                (n.iridescenceIOR = this.iridescenceIOR),
              void 0 !== this.iridescenceThicknessRange &&
                (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
              this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
              this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (n.iridescenceThicknessMap =
                  this.iridescenceThicknessMap.toJSON(t).uuid),
              void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
              void 0 !== this.anisotropyRotation &&
                (n.anisotropyRotation = this.anisotropyRotation),
              this.anisotropyMap &&
                this.anisotropyMap.isTexture &&
                (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
              this.map &&
                this.map.isTexture &&
                (n.map = this.map.toJSON(t).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (n.specularIntensityMap =
                  this.specularIntensityMap.toJSON(t).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                void 0 !== this.combine && (n.combine = this.combine)),
              void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity &&
                (n.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio &&
                (n.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.transmission &&
                (n.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
              void 0 !== this.thickness && (n.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
              void 0 !== this.attenuationDistance &&
                this.attenuationDistance !== 1 / 0 &&
                (n.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (n.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (n.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (n.blending = this.blending),
              this.side !== Th && (n.side = this.side),
              this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = this.transparent),
              (n.depthFunc = this.depthFunc),
              (n.depthTest = this.depthTest),
              (n.depthWrite = this.depthWrite),
              (n.colorWrite = this.colorWrite),
              (n.stencilWrite = this.stencilWrite),
              (n.stencilWriteMask = this.stencilWriteMask),
              (n.stencilFunc = this.stencilFunc),
              (n.stencilRef = this.stencilRef),
              (n.stencilFuncMask = this.stencilFuncMask),
              (n.stencilFail = this.stencilFail),
              (n.stencilZFail = this.stencilZFail),
              (n.stencilZPass = this.stencilZPass),
              void 0 !== this.rotation &&
                0 !== this.rotation &&
                (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
              void 0 !== this.linewidth &&
                1 !== this.linewidth &&
                (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaHash && (n.alphaHash = this.alphaHash),
              !0 === this.alphaToCoverage &&
                (n.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (n.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.forceSinglePass &&
                (n.forceSinglePass = this.forceSinglePass),
              !0 === this.wireframe && (n.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap &&
                (n.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (n.flatShading = this.flatShading),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              !1 === this.fog && (n.fog = !1),
              Object.keys(this.userData).length > 0 &&
                (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images);
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
            }
            return n;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.name = t.name),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaHash = t.alphaHash),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.forceSinglePass = t.forceSinglePass),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose",
            });
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        const rm = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          sm = {
            h: 0,
            s: 0,
            l: 0,
          },
          om = {
            h: 0,
            s: 0,
            l: 0,
          };
        function am(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        class lm {
          constructor(t, e, n) {
            return (
              (this.isColor = !0),
              (this.r = 1),
              (this.g = 1),
              (this.b = 1),
              this.set(t, e, n)
            );
          }
          set(t, e, n) {
            if (void 0 === e && void 0 === n) {
              const e = t;
              e && e.isColor
                ? this.copy(e)
                : "number" == typeof e
                ? this.setHex(e)
                : "string" == typeof e && this.setStyle(e);
            } else this.setRGB(t, e, n);
            return this;
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t, e = Dd) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              Ap.toWorkingColorSpace(this, e),
              this
            );
          }
          setRGB(t, e, n, i = Ap.workingColorSpace) {
            return (
              (this.r = t),
              (this.g = e),
              (this.b = n),
              Ap.toWorkingColorSpace(this, i),
              this
            );
          }
          setHSL(t, e, n, i = Ap.workingColorSpace) {
            if (((t = sp(t, 1)), (e = rp(e, 0, 1)), (n = rp(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i;
              (this.r = am(r, i, t + 1 / 3)),
                (this.g = am(r, i, t)),
                (this.b = am(r, i, t - 1 / 3));
            }
            return Ap.toWorkingColorSpace(this, i), this;
          }
          setStyle(t, e = Dd) {
            function n(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn(
                  "THREE.Color: Alpha component of " + t + " will be ignored."
                );
            }
            let i;
            if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
              let r;
              const s = i[1],
                o = i[2];
              switch (s) {
                case "rgb":
                case "rgba":
                  if (
                    (r =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        o
                      ))
                  )
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(255, parseInt(r[1], 10)) / 255,
                        Math.min(255, parseInt(r[2], 10)) / 255,
                        Math.min(255, parseInt(r[3], 10)) / 255,
                        e
                      )
                    );
                  if (
                    (r =
                      /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        o
                      ))
                  )
                    return (
                      n(r[4]),
                      this.setRGB(
                        Math.min(100, parseInt(r[1], 10)) / 100,
                        Math.min(100, parseInt(r[2], 10)) / 100,
                        Math.min(100, parseInt(r[3], 10)) / 100,
                        e
                      )
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (r =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        o
                      ))
                  )
                    return (
                      n(r[4]),
                      this.setHSL(
                        parseFloat(r[1]) / 360,
                        parseFloat(r[2]) / 100,
                        parseFloat(r[3]) / 100,
                        e
                      )
                    );
                  break;
                default:
                  console.warn("THREE.Color: Unknown color model " + t);
              }
            } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const n = i[1],
                r = n.length;
              if (3 === r)
                return this.setRGB(
                  parseInt(n.charAt(0), 16) / 15,
                  parseInt(n.charAt(1), 16) / 15,
                  parseInt(n.charAt(2), 16) / 15,
                  e
                );
              if (6 === r) return this.setHex(parseInt(n, 16), e);
              console.warn("THREE.Color: Invalid hex color " + t);
            } else if (t && t.length > 0) return this.setColorName(t, e);
            return this;
          }
          setColorName(t, e = Dd) {
            const n = rm[t.toLowerCase()];
            return (
              void 0 !== n
                ? this.setHex(n, e)
                : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copySRGBToLinear(t) {
            return (
              (this.r = bp(t.r)), (this.g = bp(t.g)), (this.b = bp(t.b)), this
            );
          }
          copyLinearToSRGB(t) {
            return (
              (this.r = wp(t.r)), (this.g = wp(t.g)), (this.b = wp(t.b)), this
            );
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex(t = Dd) {
            return (
              Ap.fromWorkingColorSpace(cm.copy(this), t),
              65536 * Math.round(rp(255 * cm.r, 0, 255)) +
                256 * Math.round(rp(255 * cm.g, 0, 255)) +
                Math.round(rp(255 * cm.b, 0, 255))
            );
          }
          getHexString(t = Dd) {
            return ("000000" + this.getHex(t).toString(16)).slice(-6);
          }
          getHSL(t, e = Ap.workingColorSpace) {
            Ap.fromWorkingColorSpace(cm.copy(this), e);
            const n = cm.r,
              i = cm.g,
              r = cm.b,
              s = Math.max(n, i, r),
              o = Math.min(n, i, r);
            let a, l;
            const c = (o + s) / 2;
            if (o === s) (a = 0), (l = 0);
            else {
              const t = s - o;
              switch (((l = c <= 0.5 ? t / (s + o) : t / (2 - s - o)), s)) {
                case n:
                  a = (i - r) / t + (i < r ? 6 : 0);
                  break;
                case i:
                  a = (r - n) / t + 2;
                  break;
                case r:
                  a = (n - i) / t + 4;
              }
              a /= 6;
            }
            return (t.h = a), (t.s = l), (t.l = c), t;
          }
          getRGB(t, e = Ap.workingColorSpace) {
            return (
              Ap.fromWorkingColorSpace(cm.copy(this), e),
              (t.r = cm.r),
              (t.g = cm.g),
              (t.b = cm.b),
              t
            );
          }
          getStyle(t = Dd) {
            Ap.fromWorkingColorSpace(cm.copy(this), t);
            const e = cm.r,
              n = cm.g,
              i = cm.b;
            return t !== Dd
              ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
              : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
                  255 * i
                )})`;
          }
          offsetHSL(t, e, n) {
            return (
              this.getHSL(sm),
              (sm.h += t),
              (sm.s += e),
              (sm.l += n),
              this.setHSL(sm.h, sm.s, sm.l),
              this
            );
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (
              (this.r = t.r + e.r),
              (this.g = t.g + e.g),
              (this.b = t.b + e.b),
              this
            );
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(sm), t.getHSL(om);
            const n = op(sm.h, om.h, e),
              i = op(sm.s, om.s, e),
              r = op(sm.l, om.l, e);
            return this.setHSL(n, i, r), this;
          }
          setFromVector3(t) {
            return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
          }
          applyMatrix3(t) {
            const e = this.r,
              n = this.g,
              i = this.b,
              r = t.elements;
            return (
              (this.r = r[0] * e + r[3] * n + r[6] * i),
              (this.g = r[1] * e + r[4] * n + r[7] * i),
              (this.b = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (
              (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              this
            );
          }
          toJSON() {
            return this.getHex();
          }
          *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b;
          }
        }
        const cm = new lm();
        lm.NAMES = rm;
        class um extends im {
          constructor(t) {
            super(),
              (this.isMeshBasicMaterial = !0),
              (this.type = "MeshBasicMaterial"),
              (this.color = new lm(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = Gh),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const hm = dm();
        function dm() {
          const t = new ArrayBuffer(4),
            e = new Float32Array(t),
            n = new Uint32Array(t),
            i = new Uint32Array(512),
            r = new Uint32Array(512);
          for (let t = 0; t < 256; ++t) {
            const e = t - 127;
            e < -27
              ? ((i[t] = 0),
                (i[256 | t] = 32768),
                (r[t] = 24),
                (r[256 | t] = 24))
              : e < -14
              ? ((i[t] = 1024 >> (-e - 14)),
                (i[256 | t] = (1024 >> (-e - 14)) | 32768),
                (r[t] = -e - 1),
                (r[256 | t] = -e - 1))
              : e <= 15
              ? ((i[t] = (e + 15) << 10),
                (i[256 | t] = ((e + 15) << 10) | 32768),
                (r[t] = 13),
                (r[256 | t] = 13))
              : e < 128
              ? ((i[t] = 31744),
                (i[256 | t] = 64512),
                (r[t] = 24),
                (r[256 | t] = 24))
              : ((i[t] = 31744),
                (i[256 | t] = 64512),
                (r[t] = 13),
                (r[256 | t] = 13));
          }
          const s = new Uint32Array(2048),
            o = new Uint32Array(64),
            a = new Uint32Array(64);
          for (let t = 1; t < 1024; ++t) {
            let e = t << 13,
              n = 0;
            for (; !(8388608 & e); ) (e <<= 1), (n -= 8388608);
            (e &= -8388609), (n += 947912704), (s[t] = e | n);
          }
          for (let t = 1024; t < 2048; ++t)
            s[t] = 939524096 + ((t - 1024) << 13);
          for (let t = 1; t < 31; ++t) o[t] = t << 23;
          (o[31] = 1199570944), (o[32] = 2147483648);
          for (let t = 33; t < 63; ++t) o[t] = 2147483648 + ((t - 32) << 23);
          o[63] = 3347054592;
          for (let t = 1; t < 64; ++t) 32 !== t && (a[t] = 1024);
          return {
            floatView: e,
            uint32View: n,
            baseTable: i,
            shiftTable: r,
            mantissaTable: s,
            exponentTable: o,
            offsetTable: a,
          };
        }
        function pm(t) {
          Math.abs(t) > 65504 &&
            console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            (t = rp(t, -65504, 65504)),
            (hm.floatView[0] = t);
          const e = hm.uint32View[0],
            n = (e >> 23) & 511;
          return hm.baseTable[n] + ((8388607 & e) >> hm.shiftTable[n]);
        }
        function fm(t) {
          const e = t >> 10;
          return (
            (hm.uint32View[0] =
              hm.mantissaTable[hm.offsetTable[e] + (1023 & t)] +
              hm.exponentTable[e]),
            hm.floatView[0]
          );
        }
        const mm = {
            toHalfFloat: pm,
            fromHalfFloat: fm,
          },
          gm = new Hp(),
          vm = new pp();
        class ym {
          constructor(t, e, n = !1) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = n),
              (this.usage = Xd),
              (this.updateRange = {
                offset: 0,
                count: -1,
              }),
              (this.gpuType = gd),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              (this.gpuType = t.gpuType),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let i = 0, r = this.itemSize; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                vm.fromBufferAttribute(this, e),
                  vm.applyMatrix3(t),
                  this.setXY(e, vm.x, vm.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                gm.fromBufferAttribute(this, e),
                  gm.applyMatrix3(t),
                  this.setXYZ(e, gm.x, gm.y, gm.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              gm.fromBufferAttribute(this, e),
                gm.applyMatrix4(t),
                this.setXYZ(e, gm.x, gm.y, gm.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              gm.fromBufferAttribute(this, e),
                gm.applyNormalMatrix(t),
                this.setXYZ(e, gm.x, gm.y, gm.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              gm.fromBufferAttribute(this, e),
                gm.transformDirection(t),
                this.setXYZ(e, gm.x, gm.y, gm.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getComponent(t, e) {
            let n = this.array[t * this.itemSize + e];
            return this.normalized && (n = up(n, this.array)), n;
          }
          setComponent(t, e, n) {
            return (
              this.normalized && (n = hp(n, this.array)),
              (this.array[t * this.itemSize + e] = n),
              this
            );
          }
          getX(t) {
            let e = this.array[t * this.itemSize];
            return this.normalized && (e = up(e, this.array)), e;
          }
          setX(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.array[t * this.itemSize] = e),
              this
            );
          }
          getY(t) {
            let e = this.array[t * this.itemSize + 1];
            return this.normalized && (e = up(e, this.array)), e;
          }
          setY(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.array[t * this.itemSize + 1] = e),
              this
            );
          }
          getZ(t) {
            let e = this.array[t * this.itemSize + 2];
            return this.normalized && (e = up(e, this.array)), e;
          }
          setZ(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.array[t * this.itemSize + 2] = e),
              this
            );
          }
          getW(t) {
            let e = this.array[t * this.itemSize + 3];
            return this.normalized && (e = up(e, this.array)), e;
          }
          setW(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.array[t * this.itemSize + 3] = e),
              this
            );
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = hp(e, this.array)), (n = hp(n, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = hp(e, this.array)),
                (n = hp(n, this.array)),
                (i = hp(i, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t *= this.itemSize),
              this.normalized &&
                ((e = hp(e, this.array)),
                (n = hp(n, this.array)),
                (i = hp(i, this.array)),
                (r = hp(r, this.array))),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              (this.array[t + 3] = r),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== Xd && (t.usage = this.usage),
              (0 === this.updateRange.offset &&
                -1 === this.updateRange.count) ||
                (t.updateRange = this.updateRange),
              t
            );
          }
        }
        class _m extends ym {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        class xm extends ym {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        class bm extends ym {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        let wm = 0;
        const Em = new yf(),
          Sm = new Gf(),
          Mm = new Hp(),
          Tm = new Wp(),
          Am = new Wp(),
          Rm = new Hp();
        class Cm extends Jd {
          constructor() {
            super(),
              (this.isBufferGeometry = !0),
              Object.defineProperty(this, "id", {
                value: wm++,
              }),
              (this.uuid = ip()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = {
                start: 0,
                count: 1 / 0,
              }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t)
                ? (this.index = new (gp(t) ? xm : _m)(t, 1))
                : (this.index = t),
              this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({
              start: t,
              count: e,
              materialIndex: n,
            });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new fp().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const i = this.attributes.tangent;
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(t) {
            return (
              Em.makeRotationFromQuaternion(t), this.applyMatrix4(Em), this
            );
          }
          rotateX(t) {
            return Em.makeRotationX(t), this.applyMatrix4(Em), this;
          }
          rotateY(t) {
            return Em.makeRotationY(t), this.applyMatrix4(Em), this;
          }
          rotateZ(t) {
            return Em.makeRotationZ(t), this.applyMatrix4(Em), this;
          }
          translate(t, e, n) {
            return Em.makeTranslation(t, e, n), this.applyMatrix4(Em), this;
          }
          scale(t, e, n) {
            return Em.makeScale(t, e, n), this.applyMatrix4(Em), this;
          }
          lookAt(t) {
            return (
              Sm.lookAt(t),
              Sm.updateMatrix(),
              this.applyMatrix4(Sm.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(Mm).negate(),
              this.translate(Mm.x, Mm.y, Mm.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.push(i.x, i.y, i.z || 0);
            }
            return this.setAttribute("position", new bm(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Wp());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new Hp(-1 / 0, -1 / 0, -1 / 0),
                  new Hp(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Tm.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Rm.addVectors(this.boundingBox.min, Tm.min),
                        this.boundingBox.expandByPoint(Rm),
                        Rm.addVectors(this.boundingBox.max, Tm.max),
                        this.boundingBox.expandByPoint(Rm))
                      : (this.boundingBox.expandByPoint(Tm.min),
                        this.boundingBox.expandByPoint(Tm.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new cf());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new Hp(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((Tm.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Am.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Rm.addVectors(Tm.min, Am.min),
                        Tm.expandByPoint(Rm),
                        Rm.addVectors(Tm.max, Am.max),
                        Tm.expandByPoint(Rm))
                      : (Tm.expandByPoint(Am.min), Tm.expandByPoint(Am.max));
                }
              Tm.getCenter(n);
              let i = 0;
              for (let e = 0, r = t.count; e < r; e++)
                Rm.fromBufferAttribute(t, e),
                  (i = Math.max(i, n.distanceToSquared(Rm)));
              if (e)
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r],
                    o = this.morphTargetsRelative;
                  for (let e = 0, r = s.count; e < r; e++)
                    Rm.fromBufferAttribute(s, e),
                      o && (Mm.fromBufferAttribute(t, e), Rm.add(Mm)),
                      (i = Math.max(i, n.distanceToSquared(Rm)));
                }
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (
              null === t ||
              void 0 === e.position ||
              void 0 === e.normal ||
              void 0 === e.uv
            )
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              s = e.uv.array,
              o = i.length / 3;
            !1 === this.hasAttribute("tangent") &&
              this.setAttribute("tangent", new ym(new Float32Array(4 * o), 4));
            const a = this.getAttribute("tangent").array,
              l = [],
              c = [];
            for (let t = 0; t < o; t++) (l[t] = new Hp()), (c[t] = new Hp());
            const u = new Hp(),
              h = new Hp(),
              d = new Hp(),
              p = new pp(),
              f = new pp(),
              m = new pp(),
              g = new Hp(),
              v = new Hp();
            function y(t, e, n) {
              u.fromArray(i, 3 * t),
                h.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                f.fromArray(s, 2 * e),
                m.fromArray(s, 2 * n),
                h.sub(u),
                d.sub(u),
                f.sub(p),
                m.sub(p);
              const r = 1 / (f.x * m.y - m.x * f.y);
              isFinite(r) &&
                (g
                  .copy(h)
                  .multiplyScalar(m.y)
                  .addScaledVector(d, -f.y)
                  .multiplyScalar(r),
                v
                  .copy(d)
                  .multiplyScalar(f.x)
                  .addScaledVector(h, -m.x)
                  .multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(v),
                c[e].add(v),
                c[n].add(v));
            }
            let _ = this.groups;
            0 === _.length &&
              (_ = [
                {
                  start: 0,
                  count: n.length,
                },
              ]);
            for (let t = 0, e = _.length; t < e; ++t) {
              const e = _[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                y(n[t + 0], n[t + 1], n[t + 2]);
            }
            const x = new Hp(),
              b = new Hp(),
              w = new Hp(),
              E = new Hp();
            function S(t) {
              w.fromArray(r, 3 * t), E.copy(w);
              const e = l[t];
              x.copy(e),
                x.sub(w.multiplyScalar(w.dot(e))).normalize(),
                b.crossVectors(E, e);
              const n = b.dot(c[t]) < 0 ? -1 : 1;
              (a[4 * t] = x.x),
                (a[4 * t + 1] = x.y),
                (a[4 * t + 2] = x.z),
                (a[4 * t + 3] = n);
            }
            for (let t = 0, e = _.length; t < e; ++t) {
              const e = _[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new ym(new Float32Array(3 * e.count), 3)),
                  this.setAttribute("normal", n);
              else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const i = new Hp(),
                r = new Hp(),
                s = new Hp(),
                o = new Hp(),
                a = new Hp(),
                l = new Hp(),
                c = new Hp(),
                u = new Hp();
              if (t)
                for (let h = 0, d = t.count; h < d; h += 3) {
                  const d = t.getX(h + 0),
                    p = t.getX(h + 1),
                    f = t.getX(h + 2);
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    s.fromBufferAttribute(e, f),
                    c.subVectors(s, r),
                    u.subVectors(i, r),
                    c.cross(u),
                    o.fromBufferAttribute(n, d),
                    a.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, f),
                    o.add(c),
                    a.add(c),
                    l.add(c),
                    n.setXYZ(d, o.x, o.y, o.z),
                    n.setXYZ(p, a.x, a.y, a.z),
                    n.setXYZ(f, l.x, l.y, l.z);
                }
              else
                for (let t = 0, o = e.count; t < o; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, r),
                    u.subVectors(i, r),
                    c.cross(u),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              Rm.fromBufferAttribute(t, e),
                Rm.normalize(),
                t.setXYZ(e, Rm.x, Rm.y, Rm.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                s = new n.constructor(e.length * i);
              let o = 0,
                a = 0;
              for (let r = 0, l = e.length; r < l; r++) {
                o = t.isInterleavedBufferAttribute
                  ? e[r] * t.data.stride + t.offset
                  : e[r] * i;
                for (let t = 0; t < i; t++) s[a++] = n[o++];
              }
              return new ym(s, i, r);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new Cm(),
              n = this.index.array,
              i = this.attributes;
            for (const r in i) {
              const s = t(i[r], n);
              e.setAttribute(r, s);
            }
            const r = this.morphAttributes;
            for (const i in r) {
              const s = [],
                o = r[i];
              for (let e = 0, i = o.length; e < i; e++) {
                const i = t(o[e], n);
                s.push(i);
              }
              e.morphAttributes[i] = s;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
              const n = s[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              "" !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = {
              attributes: {},
            };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const i = n[e];
              t.data.attributes[e] = i.toJSON(t.data);
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                s = [];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                s.push(i.toJSON(t.data));
              }
              s.length > 0 && ((i[e] = s), (r = !0));
            }
            r &&
              ((t.data.morphAttributes = i),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const o = this.boundingSphere;
            return (
              null !== o &&
                (t.data.boundingSphere = {
                  center: o.center.toArray(),
                  radius: o.radius,
                }),
              t
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
              const n = i[t];
              this.setAttribute(t, n.clone(e));
            }
            const r = t.morphAttributes;
            for (const t in r) {
              const n = [],
                i = r[t];
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const o = t.boundingBox;
            null !== o && (this.boundingBox = o.clone());
            const a = t.boundingSphere;
            return (
              null !== a && (this.boundingSphere = a.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose",
            });
          }
        }
        const Lm = new yf(),
          Pm = new vf(),
          Om = new cf(),
          Im = new Hp(),
          Nm = new Hp(),
          Dm = new Hp(),
          Um = new Hp(),
          Fm = new Hp(),
          km = new Hp(),
          Bm = new pp(),
          zm = new pp(),
          Hm = new pp(),
          Vm = new Hp(),
          Gm = new Hp(),
          Wm = new Hp(),
          jm = new Hp(),
          qm = new Hp();
        class Xm extends Gf {
          constructor(t = new Cm(), e = new um()) {
            super(),
              (this.isMesh = !0),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  t.morphTargetDictionary
                )),
              (this.material = Array.isArray(t.material)
                ? t.material.slice()
                : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
          getVertexPosition(t, e) {
            const n = this.geometry,
              i = n.attributes.position,
              r = n.morphAttributes.position,
              s = n.morphTargetsRelative;
            e.fromBufferAttribute(i, t);
            const o = this.morphTargetInfluences;
            if (r && o) {
              km.set(0, 0, 0);
              for (let n = 0, i = r.length; n < i; n++) {
                const i = o[n],
                  a = r[n];
                0 !== i &&
                  (Fm.fromBufferAttribute(a, t),
                  s
                    ? km.addScaledVector(Fm, i)
                    : km.addScaledVector(Fm.sub(e), i));
              }
              e.add(km);
            }
            return e;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld;
            if (void 0 !== i) {
              if (
                (null === n.boundingSphere && n.computeBoundingSphere(),
                Om.copy(n.boundingSphere),
                Om.applyMatrix4(r),
                Pm.copy(t.ray).recast(t.near),
                !1 === Om.containsPoint(Pm.origin))
              ) {
                if (null === Pm.intersectSphere(Om, Im)) return;
                if (Pm.origin.distanceToSquared(Im) > (t.far - t.near) ** 2)
                  return;
              }
              Lm.copy(r).invert(),
                Pm.copy(t.ray).applyMatrix4(Lm),
                (null !== n.boundingBox &&
                  !1 === Pm.intersectsBox(n.boundingBox)) ||
                  this._computeIntersections(t, e, Pm);
            }
          }
          _computeIntersections(t, e, n) {
            let i;
            const r = this.geometry,
              s = this.material,
              o = r.index,
              a = r.attributes.position,
              l = r.attributes.uv,
              c = r.attributes.uv1,
              u = r.attributes.normal,
              h = r.groups,
              d = r.drawRange;
            if (null !== o)
              if (Array.isArray(s))
                for (let r = 0, a = h.length; r < a; r++) {
                  const a = h[r],
                    p = s[a.materialIndex];
                  for (
                    let r = Math.max(a.start, d.start),
                      s = Math.min(
                        o.count,
                        Math.min(a.start + a.count, d.start + d.count)
                      );
                    r < s;
                    r += 3
                  ) {
                    (i = Ym(
                      this,
                      p,
                      t,
                      n,
                      l,
                      c,
                      u,
                      o.getX(r),
                      o.getX(r + 1),
                      o.getX(r + 2)
                    )),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = a.materialIndex),
                        e.push(i));
                  }
                }
              else {
                for (
                  let r = Math.max(0, d.start),
                    a = Math.min(o.count, d.start + d.count);
                  r < a;
                  r += 3
                ) {
                  (i = Ym(
                    this,
                    s,
                    t,
                    n,
                    l,
                    c,
                    u,
                    o.getX(r),
                    o.getX(r + 1),
                    o.getX(r + 2)
                  )),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
                }
              }
            else if (void 0 !== a)
              if (Array.isArray(s))
                for (let r = 0, o = h.length; r < o; r++) {
                  const o = h[r],
                    p = s[o.materialIndex];
                  for (
                    let r = Math.max(o.start, d.start),
                      s = Math.min(
                        a.count,
                        Math.min(o.start + o.count, d.start + d.count)
                      );
                    r < s;
                    r += 3
                  ) {
                    (i = Ym(this, p, t, n, l, c, u, r, r + 1, r + 2)),
                      i &&
                        ((i.faceIndex = Math.floor(r / 3)),
                        (i.face.materialIndex = o.materialIndex),
                        e.push(i));
                  }
                }
              else {
                for (
                  let r = Math.max(0, d.start),
                    o = Math.min(a.count, d.start + d.count);
                  r < o;
                  r += 3
                ) {
                  (i = Ym(this, s, t, n, l, c, u, r, r + 1, r + 2)),
                    i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
                }
              }
          }
        }
        function Ym(t, e, n, i, r, s, o, a, l, c) {
          t.getVertexPosition(a, Nm),
            t.getVertexPosition(l, Dm),
            t.getVertexPosition(c, Um);
          const u = (function (t, e, n, i, r, s, o, a) {
            let l;
            if (
              ((l =
                e.side === Ah
                  ? i.intersectTriangle(o, s, r, !0, a)
                  : i.intersectTriangle(r, s, o, e.side === Th, a)),
              null === l)
            )
              return null;
            qm.copy(a), qm.applyMatrix4(t.matrixWorld);
            const c = n.ray.origin.distanceTo(qm);
            return c < n.near || c > n.far
              ? null
              : {
                  distance: c,
                  point: qm.clone(),
                  object: t,
                };
          })(t, e, n, i, Nm, Dm, Um, jm);
          if (u) {
            r &&
              (Bm.fromBufferAttribute(r, a),
              zm.fromBufferAttribute(r, l),
              Hm.fromBufferAttribute(r, c),
              (u.uv = em.getInterpolation(
                jm,
                Nm,
                Dm,
                Um,
                Bm,
                zm,
                Hm,
                new pp()
              ))),
              s &&
                (Bm.fromBufferAttribute(s, a),
                zm.fromBufferAttribute(s, l),
                Hm.fromBufferAttribute(s, c),
                (u.uv1 = em.getInterpolation(
                  jm,
                  Nm,
                  Dm,
                  Um,
                  Bm,
                  zm,
                  Hm,
                  new pp()
                )),
                (u.uv2 = u.uv1)),
              o &&
                (Vm.fromBufferAttribute(o, a),
                Gm.fromBufferAttribute(o, l),
                Wm.fromBufferAttribute(o, c),
                (u.normal = em.getInterpolation(
                  jm,
                  Nm,
                  Dm,
                  Um,
                  Vm,
                  Gm,
                  Wm,
                  new Hp()
                )),
                u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
            const t = {
              a,
              b: l,
              c,
              normal: new Hp(),
              materialIndex: 0,
            };
            em.getNormal(Nm, Dm, Um, t.normal), (u.face = t);
          }
          return u;
        }
        class Km extends Cm {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s,
              });
            const o = this;
            (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
            const a = [],
              l = [],
              c = [],
              u = [];
            let h = 0,
              d = 0;
            function p(t, e, n, i, r, s, p, f, m, g, v) {
              const y = s / m,
                _ = p / g,
                x = s / 2,
                b = p / 2,
                w = f / 2,
                E = m + 1,
                S = g + 1;
              let M = 0,
                T = 0;
              const A = new Hp();
              for (let s = 0; s < S; s++) {
                const o = s * _ - b;
                for (let a = 0; a < E; a++) {
                  const h = a * y - x;
                  (A[t] = h * i),
                    (A[e] = o * r),
                    (A[n] = w),
                    l.push(A.x, A.y, A.z),
                    (A[t] = 0),
                    (A[e] = 0),
                    (A[n] = f > 0 ? 1 : -1),
                    c.push(A.x, A.y, A.z),
                    u.push(a / m),
                    u.push(1 - s / g),
                    (M += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < m; e++) {
                  const n = h + e + E * t,
                    i = h + e + E * (t + 1),
                    r = h + (e + 1) + E * (t + 1),
                    s = h + (e + 1) + E * t;
                  a.push(n, i, s), a.push(i, r, s), (T += 6);
                }
              o.addGroup(d, T, v), (d += T), (h += M);
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
              p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
              p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
              p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
              p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
              p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
              this.setIndex(a),
              this.setAttribute("position", new bm(l, 3)),
              this.setAttribute("normal", new bm(c, 3)),
              this.setAttribute("uv", new bm(u, 2));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.parameters = Object.assign({}, t.parameters)),
              this
            );
          }
          static fromJSON(t) {
            return new Km(
              t.width,
              t.height,
              t.depth,
              t.widthSegments,
              t.heightSegments,
              t.depthSegments
            );
          }
        }
        function $m(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
              const r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? r.isRenderTargetTexture
                  ? (console.warn(
                      "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                    ),
                    (e[n][i] = null))
                  : (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        }
        function Zm(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const i = $m(t[n]);
            for (const t in i) e[t] = i[t];
          }
          return e;
        }
        function Jm(t) {
          return null === t.getRenderTarget() ? t.outputColorSpace : Ud;
        }
        const Qm = {
          clone: $m,
          merge: Zm,
        };
        class tg extends im {
          constructor(t) {
            super(),
              (this.isShaderMaterial = !0),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.uniformsGroups = []),
              (this.vertexShader =
                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
              (this.fragmentShader =
                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.forceSinglePass = !0),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t && this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = $m(t.uniforms)),
              (this.uniformsGroups = (function (t) {
                const e = [];
                for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                return e;
              })(t.uniformsGroups)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.fog = t.fog),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value;
              i && i.isTexture
                ? (e.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(t).uuid,
                  })
                : i && i.isColor
                ? (e.uniforms[n] = {
                    type: "c",
                    value: i.getHex(),
                  })
                : i && i.isVector2
                ? (e.uniforms[n] = {
                    type: "v2",
                    value: i.toArray(),
                  })
                : i && i.isVector3
                ? (e.uniforms[n] = {
                    type: "v3",
                    value: i.toArray(),
                  })
                : i && i.isVector4
                ? (e.uniforms[n] = {
                    type: "v4",
                    value: i.toArray(),
                  })
                : i && i.isMatrix3
                ? (e.uniforms[n] = {
                    type: "m3",
                    value: i.toArray(),
                  })
                : i && i.isMatrix4
                ? (e.uniforms[n] = {
                    type: "m4",
                    value: i.toArray(),
                  })
                : (e.uniforms[n] = {
                    value: i,
                  });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader),
              (e.lights = this.lights),
              (e.clipping = this.clipping);
            const n = {};
            for (const t in this.extensions)
              !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        class eg extends Gf {
          constructor() {
            super(),
              (this.isCamera = !0),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new yf()),
              (this.projectionMatrix = new yf()),
              (this.projectionMatrixInverse = new yf()),
              (this.coordinateSystem = $d);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              (this.coordinateSystem = t.coordinateSystem),
              this
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class ng extends eg {
          constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
            super(),
              (this.isPerspectiveCamera = !0),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = i),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * np * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * ep * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return (
              2 * np * Math.atan(Math.tan(0.5 * ep * this.fov) / this.zoom)
            );
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, i, r, s) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * ep * this.fov)) / this.zoom,
              n = 2 * e,
              i = this.aspect * n,
              r = -0.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = s.fullWidth,
                o = s.fullHeight;
              (r += (s.offsetX * i) / t),
                (e -= (s.offsetY * n) / o),
                (i *= s.width / t),
                (n *= s.height / o);
            }
            const o = this.filmOffset;
            0 !== o && (r += (t * o) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                e,
                e - n,
                t,
                this.far,
                this.coordinateSystem
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        const ig = -90;
        class rg extends Gf {
          constructor(t, e, n) {
            super(),
              (this.type = "CubeCamera"),
              (this.renderTarget = n),
              (this.coordinateSystem = null);
            const i = new ng(ig, 1, t, e);
            (i.layers = this.layers), this.add(i);
            const r = new ng(ig, 1, t, e);
            (r.layers = this.layers), this.add(r);
            const s = new ng(ig, 1, t, e);
            (s.layers = this.layers), this.add(s);
            const o = new ng(ig, 1, t, e);
            (o.layers = this.layers), this.add(o);
            const a = new ng(ig, 1, t, e);
            (a.layers = this.layers), this.add(a);
            const l = new ng(ig, 1, t, e);
            (l.layers = this.layers), this.add(l);
          }
          updateCoordinateSystem() {
            const t = this.coordinateSystem,
              e = this.children.concat(),
              [n, i, r, s, o, a] = e;
            for (const t of e) this.remove(t);
            if (t === $d)
              n.up.set(0, 1, 0),
                n.lookAt(1, 0, 0),
                i.up.set(0, 1, 0),
                i.lookAt(-1, 0, 0),
                r.up.set(0, 0, -1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, 1),
                s.lookAt(0, -1, 0),
                o.up.set(0, 1, 0),
                o.lookAt(0, 0, 1),
                a.up.set(0, 1, 0),
                a.lookAt(0, 0, -1);
            else {
              if (t !== Zd)
                throw new Error(
                  "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                    t
                );
              n.up.set(0, -1, 0),
                n.lookAt(-1, 0, 0),
                i.up.set(0, -1, 0),
                i.lookAt(1, 0, 0),
                r.up.set(0, 0, 1),
                r.lookAt(0, 1, 0),
                s.up.set(0, 0, -1),
                s.lookAt(0, -1, 0),
                o.up.set(0, -1, 0),
                o.lookAt(0, 0, 1),
                a.up.set(0, -1, 0),
                a.lookAt(0, 0, -1);
            }
            for (const t of e) this.add(t), t.updateMatrixWorld();
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget;
            this.coordinateSystem !== t.coordinateSystem &&
              ((this.coordinateSystem = t.coordinateSystem),
              this.updateCoordinateSystem());
            const [i, r, s, o, a, l] = this.children,
              c = t.getRenderTarget(),
              u = t.xr.enabled;
            t.xr.enabled = !1;
            const h = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, i),
              t.setRenderTarget(n, 1),
              t.render(e, r),
              t.setRenderTarget(n, 2),
              t.render(e, s),
              t.setRenderTarget(n, 3),
              t.render(e, o),
              t.setRenderTarget(n, 4),
              t.render(e, a),
              (n.texture.generateMipmaps = h),
              t.setRenderTarget(n, 5),
              t.render(e, l),
              t.setRenderTarget(c),
              (t.xr.enabled = u),
              (n.texture.needsPMREMUpdate = !0);
          }
        }
        class sg extends Np {
          constructor(t, e, n, i, r, s, o, a, l, c) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : Jh),
              n,
              i,
              r,
              s,
              o,
              a,
              l,
              c
            ),
              (this.isCubeTexture = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        class og extends Fp {
          constructor(t = 1, e = {}) {
            super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
            const n = {
                width: t,
                height: t,
                depth: 1,
              },
              i = [n, n, n, n, n, n];
            void 0 !== e.encoding &&
              (xp(
                "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
              ),
              (e.colorSpace = e.encoding === Id ? Dd : Nd)),
              (this.texture = new sg(
                i,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.colorSpace
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps =
                void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== e.minFilter ? e.minFilter : cd);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.colorSpace = e.colorSpace),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = {
                uniforms: {
                  tEquirect: {
                    value: null,
                  },
                },
                vertexShader:
                  "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader:
                  "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              },
              i = new Km(5, 5, 5),
              r = new tg({
                name: "CubemapFromEquirect",
                uniforms: $m(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Ah,
                blending: 0,
              });
            r.uniforms.tEquirect.value = e;
            const s = new Xm(i, r),
              o = e.minFilter;
            e.minFilter === hd && (e.minFilter = cd);
            return (
              new rg(1, 10, this).update(t, s),
              (e.minFilter = o),
              s.geometry.dispose(),
              s.material.dispose(),
              this
            );
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++)
              t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r);
          }
        }
        const ag = new Hp(),
          lg = new Hp(),
          cg = new fp();
        class ug {
          constructor(t = new Hp(1, 0, 0), e = 0) {
            (this.isPlane = !0), (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(t, e, n) {
            const i = ag
              .subVectors(n, e)
              .cross(lg.subVectors(t, e))
              .normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this;
          }
          copy(t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return e
              .copy(t)
              .addScaledVector(this.normal, -this.distanceToPoint(t));
          }
          intersectLine(t, e) {
            const n = t.delta(ag),
              i = this.normal.dot(n);
            if (0 === i)
              return 0 === this.distanceToPoint(t.start)
                ? e.copy(t.start)
                : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1
              ? null
              : e.copy(t.start).addScaledVector(n, r);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(t, e) {
            const n = e || cg.getNormalMatrix(t),
              i = this.coplanarPoint(ag).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(r)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const hg = new cf(),
          dg = new Hp();
        class pg {
          constructor(
            t = new ug(),
            e = new ug(),
            n = new ug(),
            i = new ug(),
            r = new ug(),
            s = new ug()
          ) {
            this.planes = [t, e, n, i, r, s];
          }
          set(t, e, n, i, r, s) {
            const o = this.planes;
            return (
              o[0].copy(t),
              o[1].copy(e),
              o[2].copy(n),
              o[3].copy(i),
              o[4].copy(r),
              o[5].copy(s),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t, e = 2e3) {
            const n = this.planes,
              i = t.elements,
              r = i[0],
              s = i[1],
              o = i[2],
              a = i[3],
              l = i[4],
              c = i[5],
              u = i[6],
              h = i[7],
              d = i[8],
              p = i[9],
              f = i[10],
              m = i[11],
              g = i[12],
              v = i[13],
              y = i[14],
              _ = i[15];
            if (
              (n[0].setComponents(a - r, h - l, m - d, _ - g).normalize(),
              n[1].setComponents(a + r, h + l, m + d, _ + g).normalize(),
              n[2].setComponents(a + s, h + c, m + p, _ + v).normalize(),
              n[3].setComponents(a - s, h - c, m - p, _ - v).normalize(),
              n[4].setComponents(a - o, h - u, m - f, _ - y).normalize(),
              e === $d)
            )
              n[5].setComponents(a + o, h + u, m + f, _ + y).normalize();
            else {
              if (e !== Zd)
                throw new Error(
                  "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                    e
                );
              n[5].setComponents(o, u, f, y).normalize();
            }
            return this;
          }
          intersectsObject(t) {
            if (void 0 !== t.boundingSphere)
              null === t.boundingSphere && t.computeBoundingSphere(),
                hg.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
            else {
              const e = t.geometry;
              null === e.boundingSphere && e.computeBoundingSphere(),
                hg.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
            }
            return this.intersectsSphere(hg);
          }
          intersectsSprite(t) {
            return (
              hg.center.set(0, 0, 0),
              (hg.radius = 0.7071067811865476),
              hg.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(hg)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius;
            for (let t = 0; t < 6; t++) {
              if (e[t].distanceToPoint(n) < i) return !1;
            }
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const i = e[n];
              if (
                ((dg.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (dg.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (dg.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(dg) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function fg() {
          let t = null,
            e = !1,
            n = null,
            i = null;
          function r(e, s) {
            n(e, s), (i = t.requestAnimationFrame(r));
          }
          return {
            start: function () {
              !0 !== e &&
                null !== n &&
                ((i = t.requestAnimationFrame(r)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function mg(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = i.get(e);
              n && (t.deleteBuffer(n.buffer), i.delete(e));
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const s = i.get(e);
              void 0 === s
                ? i.set(
                    e,
                    (function (e, i) {
                      const r = e.array,
                        s = e.usage,
                        o = t.createBuffer();
                      let a;
                      if (
                        (t.bindBuffer(i, o),
                        t.bufferData(i, r, s),
                        e.onUploadCallback(),
                        r instanceof Float32Array)
                      )
                        a = t.FLOAT;
                      else if (r instanceof Uint16Array)
                        if (e.isFloat16BufferAttribute) {
                          if (!n)
                            throw new Error(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            );
                          a = t.HALF_FLOAT;
                        } else a = t.UNSIGNED_SHORT;
                      else if (r instanceof Int16Array) a = t.SHORT;
                      else if (r instanceof Uint32Array) a = t.UNSIGNED_INT;
                      else if (r instanceof Int32Array) a = t.INT;
                      else if (r instanceof Int8Array) a = t.BYTE;
                      else if (r instanceof Uint8Array) a = t.UNSIGNED_BYTE;
                      else {
                        if (!(r instanceof Uint8ClampedArray))
                          throw new Error(
                            "THREE.WebGLAttributes: Unsupported buffer data format: " +
                              r
                          );
                        a = t.UNSIGNED_BYTE;
                      }
                      return {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version,
                      };
                    })(e, r)
                  )
                : s.version < e.version &&
                  (!(function (e, i, r) {
                    const s = i.array,
                      o = i.updateRange;
                    t.bindBuffer(r, e),
                      -1 === o.count
                        ? t.bufferSubData(r, 0, s)
                        : (n
                            ? t.bufferSubData(
                                r,
                                o.offset * s.BYTES_PER_ELEMENT,
                                s,
                                o.offset,
                                o.count
                              )
                            : t.bufferSubData(
                                r,
                                o.offset * s.BYTES_PER_ELEMENT,
                                s.subarray(o.offset, o.offset + o.count)
                              ),
                          (o.count = -1)),
                      i.onUploadCallback();
                  })(s.buffer, e, r),
                  (s.version = e.version));
            },
          };
        }
        class gg extends Cm {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i,
              });
            const r = t / 2,
              s = e / 2,
              o = Math.floor(n),
              a = Math.floor(i),
              l = o + 1,
              c = a + 1,
              u = t / o,
              h = e / a,
              d = [],
              p = [],
              f = [],
              m = [];
            for (let t = 0; t < c; t++) {
              const e = t * h - s;
              for (let n = 0; n < l; n++) {
                const i = n * u - r;
                p.push(i, -e, 0),
                  f.push(0, 0, 1),
                  m.push(n / o),
                  m.push(1 - t / a);
              }
            }
            for (let t = 0; t < a; t++)
              for (let e = 0; e < o; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  s = e + 1 + l * t;
                d.push(n, i, s), d.push(i, r, s);
              }
            this.setIndex(d),
              this.setAttribute("position", new bm(p, 3)),
              this.setAttribute("normal", new bm(f, 3)),
              this.setAttribute("uv", new bm(m, 2));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.parameters = Object.assign({}, t.parameters)),
              this
            );
          }
          static fromJSON(t) {
            return new gg(t.width, t.height, t.widthSegments, t.heightSegments);
          }
        }
        const vg = {
            alphahash_fragment:
              "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment:
              "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment:
              "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment:
              "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex:
              "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment:
              "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common:
              "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment:
              "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment:
              "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex:
              "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment:
              "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment:
              "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment:
              "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment:
              "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment:
              "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment:
              "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex:
              "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin:
              "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps:
              "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex:
              "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment:
              "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment:
              "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment:
              "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment:
              "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment:
              "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex:
              "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag:
              "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag:
              "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag:
              "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert:
              "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag:
              "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert:
              "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          },
          yg = {
            common: {
              diffuse: {
                value: new lm(16777215),
              },
              opacity: {
                value: 1,
              },
              map: {
                value: null,
              },
              mapTransform: {
                value: new fp(),
              },
              alphaMap: {
                value: null,
              },
              alphaMapTransform: {
                value: new fp(),
              },
              alphaTest: {
                value: 0,
              },
            },
            specularmap: {
              specularMap: {
                value: null,
              },
              specularMapTransform: {
                value: new fp(),
              },
            },
            envmap: {
              envMap: {
                value: null,
              },
              flipEnvMap: {
                value: -1,
              },
              reflectivity: {
                value: 1,
              },
              ior: {
                value: 1.5,
              },
              refractionRatio: {
                value: 0.98,
              },
            },
            aomap: {
              aoMap: {
                value: null,
              },
              aoMapIntensity: {
                value: 1,
              },
              aoMapTransform: {
                value: new fp(),
              },
            },
            lightmap: {
              lightMap: {
                value: null,
              },
              lightMapIntensity: {
                value: 1,
              },
              lightMapTransform: {
                value: new fp(),
              },
            },
            bumpmap: {
              bumpMap: {
                value: null,
              },
              bumpMapTransform: {
                value: new fp(),
              },
              bumpScale: {
                value: 1,
              },
            },
            normalmap: {
              normalMap: {
                value: null,
              },
              normalMapTransform: {
                value: new fp(),
              },
              normalScale: {
                value: new pp(1, 1),
              },
            },
            displacementmap: {
              displacementMap: {
                value: null,
              },
              displacementMapTransform: {
                value: new fp(),
              },
              displacementScale: {
                value: 1,
              },
              displacementBias: {
                value: 0,
              },
            },
            emissivemap: {
              emissiveMap: {
                value: null,
              },
              emissiveMapTransform: {
                value: new fp(),
              },
            },
            metalnessmap: {
              metalnessMap: {
                value: null,
              },
              metalnessMapTransform: {
                value: new fp(),
              },
            },
            roughnessmap: {
              roughnessMap: {
                value: null,
              },
              roughnessMapTransform: {
                value: new fp(),
              },
            },
            gradientmap: {
              gradientMap: {
                value: null,
              },
            },
            fog: {
              fogDensity: {
                value: 25e-5,
              },
              fogNear: {
                value: 1,
              },
              fogFar: {
                value: 2e3,
              },
              fogColor: {
                value: new lm(16777215),
              },
            },
            lights: {
              ambientLightColor: {
                value: [],
              },
              lightProbe: {
                value: [],
              },
              directionalLights: {
                value: [],
                properties: {
                  direction: {},
                  color: {},
                },
              },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: {
                value: [],
              },
              directionalShadowMatrix: {
                value: [],
              },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotLightMap: {
                value: [],
              },
              spotShadowMap: {
                value: [],
              },
              spotLightMatrix: {
                value: [],
              },
              pointLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {},
                },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: {
                value: [],
              },
              pointShadowMatrix: {
                value: [],
              },
              hemisphereLights: {
                value: [],
                properties: {
                  direction: {},
                  skyColor: {},
                  groundColor: {},
                },
              },
              rectAreaLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  width: {},
                  height: {},
                },
              },
              ltc_1: {
                value: null,
              },
              ltc_2: {
                value: null,
              },
            },
            points: {
              diffuse: {
                value: new lm(16777215),
              },
              opacity: {
                value: 1,
              },
              size: {
                value: 1,
              },
              scale: {
                value: 1,
              },
              map: {
                value: null,
              },
              alphaMap: {
                value: null,
              },
              alphaMapTransform: {
                value: new fp(),
              },
              alphaTest: {
                value: 0,
              },
              uvTransform: {
                value: new fp(),
              },
            },
            sprite: {
              diffuse: {
                value: new lm(16777215),
              },
              opacity: {
                value: 1,
              },
              center: {
                value: new pp(0.5, 0.5),
              },
              rotation: {
                value: 0,
              },
              map: {
                value: null,
              },
              mapTransform: {
                value: new fp(),
              },
              alphaMap: {
                value: null,
              },
              alphaMapTransform: {
                value: new fp(),
              },
              alphaTest: {
                value: 0,
              },
            },
          },
          _g = {
            basic: {
              uniforms: Zm([
                yg.common,
                yg.specularmap,
                yg.envmap,
                yg.aomap,
                yg.lightmap,
                yg.fog,
              ]),
              vertexShader: vg.meshbasic_vert,
              fragmentShader: vg.meshbasic_frag,
            },
            lambert: {
              uniforms: Zm([
                yg.common,
                yg.specularmap,
                yg.envmap,
                yg.aomap,
                yg.lightmap,
                yg.emissivemap,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                yg.fog,
                yg.lights,
                {
                  emissive: {
                    value: new lm(0),
                  },
                },
              ]),
              vertexShader: vg.meshlambert_vert,
              fragmentShader: vg.meshlambert_frag,
            },
            phong: {
              uniforms: Zm([
                yg.common,
                yg.specularmap,
                yg.envmap,
                yg.aomap,
                yg.lightmap,
                yg.emissivemap,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                yg.fog,
                yg.lights,
                {
                  emissive: {
                    value: new lm(0),
                  },
                  specular: {
                    value: new lm(1118481),
                  },
                  shininess: {
                    value: 30,
                  },
                },
              ]),
              vertexShader: vg.meshphong_vert,
              fragmentShader: vg.meshphong_frag,
            },
            standard: {
              uniforms: Zm([
                yg.common,
                yg.envmap,
                yg.aomap,
                yg.lightmap,
                yg.emissivemap,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                yg.roughnessmap,
                yg.metalnessmap,
                yg.fog,
                yg.lights,
                {
                  emissive: {
                    value: new lm(0),
                  },
                  roughness: {
                    value: 1,
                  },
                  metalness: {
                    value: 0,
                  },
                  envMapIntensity: {
                    value: 1,
                  },
                },
              ]),
              vertexShader: vg.meshphysical_vert,
              fragmentShader: vg.meshphysical_frag,
            },
            toon: {
              uniforms: Zm([
                yg.common,
                yg.aomap,
                yg.lightmap,
                yg.emissivemap,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                yg.gradientmap,
                yg.fog,
                yg.lights,
                {
                  emissive: {
                    value: new lm(0),
                  },
                },
              ]),
              vertexShader: vg.meshtoon_vert,
              fragmentShader: vg.meshtoon_frag,
            },
            matcap: {
              uniforms: Zm([
                yg.common,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                yg.fog,
                {
                  matcap: {
                    value: null,
                  },
                },
              ]),
              vertexShader: vg.meshmatcap_vert,
              fragmentShader: vg.meshmatcap_frag,
            },
            points: {
              uniforms: Zm([yg.points, yg.fog]),
              vertexShader: vg.points_vert,
              fragmentShader: vg.points_frag,
            },
            dashed: {
              uniforms: Zm([
                yg.common,
                yg.fog,
                {
                  scale: {
                    value: 1,
                  },
                  dashSize: {
                    value: 1,
                  },
                  totalSize: {
                    value: 2,
                  },
                },
              ]),
              vertexShader: vg.linedashed_vert,
              fragmentShader: vg.linedashed_frag,
            },
            depth: {
              uniforms: Zm([yg.common, yg.displacementmap]),
              vertexShader: vg.depth_vert,
              fragmentShader: vg.depth_frag,
            },
            normal: {
              uniforms: Zm([
                yg.common,
                yg.bumpmap,
                yg.normalmap,
                yg.displacementmap,
                {
                  opacity: {
                    value: 1,
                  },
                },
              ]),
              vertexShader: vg.meshnormal_vert,
              fragmentShader: vg.meshnormal_frag,
            },
            sprite: {
              uniforms: Zm([yg.sprite, yg.fog]),
              vertexShader: vg.sprite_vert,
              fragmentShader: vg.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: {
                  value: new fp(),
                },
                t2D: {
                  value: null,
                },
                backgroundIntensity: {
                  value: 1,
                },
              },
              vertexShader: vg.background_vert,
              fragmentShader: vg.background_frag,
            },
            backgroundCube: {
              uniforms: {
                envMap: {
                  value: null,
                },
                flipEnvMap: {
                  value: -1,
                },
                backgroundBlurriness: {
                  value: 0,
                },
                backgroundIntensity: {
                  value: 1,
                },
              },
              vertexShader: vg.backgroundCube_vert,
              fragmentShader: vg.backgroundCube_frag,
            },
            cube: {
              uniforms: {
                tCube: {
                  value: null,
                },
                tFlip: {
                  value: -1,
                },
                opacity: {
                  value: 1,
                },
              },
              vertexShader: vg.cube_vert,
              fragmentShader: vg.cube_frag,
            },
            equirect: {
              uniforms: {
                tEquirect: {
                  value: null,
                },
              },
              vertexShader: vg.equirect_vert,
              fragmentShader: vg.equirect_frag,
            },
            distanceRGBA: {
              uniforms: Zm([
                yg.common,
                yg.displacementmap,
                {
                  referencePosition: {
                    value: new Hp(),
                  },
                  nearDistance: {
                    value: 1,
                  },
                  farDistance: {
                    value: 1e3,
                  },
                },
              ]),
              vertexShader: vg.distanceRGBA_vert,
              fragmentShader: vg.distanceRGBA_frag,
            },
            shadow: {
              uniforms: Zm([
                yg.lights,
                yg.fog,
                {
                  color: {
                    value: new lm(0),
                  },
                  opacity: {
                    value: 1,
                  },
                },
              ]),
              vertexShader: vg.shadow_vert,
              fragmentShader: vg.shadow_frag,
            },
          };
        _g.physical = {
          uniforms: Zm([
            _g.standard.uniforms,
            {
              clearcoat: {
                value: 0,
              },
              clearcoatMap: {
                value: null,
              },
              clearcoatMapTransform: {
                value: new fp(),
              },
              clearcoatNormalMap: {
                value: null,
              },
              clearcoatNormalMapTransform: {
                value: new fp(),
              },
              clearcoatNormalScale: {
                value: new pp(1, 1),
              },
              clearcoatRoughness: {
                value: 0,
              },
              clearcoatRoughnessMap: {
                value: null,
              },
              clearcoatRoughnessMapTransform: {
                value: new fp(),
              },
              iridescence: {
                value: 0,
              },
              iridescenceMap: {
                value: null,
              },
              iridescenceMapTransform: {
                value: new fp(),
              },
              iridescenceIOR: {
                value: 1.3,
              },
              iridescenceThicknessMinimum: {
                value: 100,
              },
              iridescenceThicknessMaximum: {
                value: 400,
              },
              iridescenceThicknessMap: {
                value: null,
              },
              iridescenceThicknessMapTransform: {
                value: new fp(),
              },
              sheen: {
                value: 0,
              },
              sheenColor: {
                value: new lm(0),
              },
              sheenColorMap: {
                value: null,
              },
              sheenColorMapTransform: {
                value: new fp(),
              },
              sheenRoughness: {
                value: 1,
              },
              sheenRoughnessMap: {
                value: null,
              },
              sheenRoughnessMapTransform: {
                value: new fp(),
              },
              transmission: {
                value: 0,
              },
              transmissionMap: {
                value: null,
              },
              transmissionMapTransform: {
                value: new fp(),
              },
              transmissionSamplerSize: {
                value: new pp(),
              },
              transmissionSamplerMap: {
                value: null,
              },
              thickness: {
                value: 0,
              },
              thicknessMap: {
                value: null,
              },
              thicknessMapTransform: {
                value: new fp(),
              },
              attenuationDistance: {
                value: 0,
              },
              attenuationColor: {
                value: new lm(0),
              },
              specularColor: {
                value: new lm(1, 1, 1),
              },
              specularColorMap: {
                value: null,
              },
              specularColorMapTransform: {
                value: new fp(),
              },
              specularIntensity: {
                value: 1,
              },
              specularIntensityMap: {
                value: null,
              },
              specularIntensityMapTransform: {
                value: new fp(),
              },
              anisotropyVector: {
                value: new pp(),
              },
              anisotropyMap: {
                value: null,
              },
              anisotropyMapTransform: {
                value: new fp(),
              },
            },
          ]),
          vertexShader: vg.meshphysical_vert,
          fragmentShader: vg.meshphysical_frag,
        };
        const xg = {
          r: 0,
          b: 0,
          g: 0,
        };
        function bg(t, e, n, i, r, s, o) {
          const a = new lm(0);
          let l,
            c,
            u = !0 === s ? 0 : 1,
            h = null,
            d = 0,
            p = null;
          function f(e, n) {
            e.getRGB(xg, Jm(t)),
              i.buffers.color.setClear(xg.r, xg.g, xg.b, n, o);
          }
          return {
            getClearColor: function () {
              return a;
            },
            setClearColor: function (t, e = 1) {
              a.set(t), (u = e), f(a, u);
            },
            getClearAlpha: function () {
              return u;
            },
            setClearAlpha: function (t) {
              (u = t), f(a, u);
            },
            render: function (s, m) {
              let g = !1,
                v = !0 === m.isScene ? m.background : null;
              if (v && v.isTexture) {
                v = (m.backgroundBlurriness > 0 ? n : e).get(v);
              }
              null === v ? f(a, u) : v && v.isColor && (f(v, 1), (g = !0));
              const y = t.xr.getEnvironmentBlendMode();
              "additive" === y
                ? i.buffers.color.setClear(0, 0, 0, 1, o)
                : "alpha-blend" === y &&
                  i.buffers.color.setClear(0, 0, 0, 0, o),
                (t.autoClear || g) &&
                  t.clear(
                    t.autoClearColor,
                    t.autoClearDepth,
                    t.autoClearStencil
                  ),
                v && (v.isCubeTexture || v.mapping === nd)
                  ? (void 0 === c &&
                      ((c = new Xm(
                        new Km(1, 1, 1),
                        new tg({
                          name: "BackgroundCubeMaterial",
                          uniforms: $m(_g.backgroundCube.uniforms),
                          vertexShader: _g.backgroundCube.vertexShader,
                          fragmentShader: _g.backgroundCube.fragmentShader,
                          side: Ah,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      c.geometry.deleteAttribute("normal"),
                      c.geometry.deleteAttribute("uv"),
                      (c.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(c.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      r.update(c)),
                    (c.material.uniforms.envMap.value = v),
                    (c.material.uniforms.flipEnvMap.value =
                      v.isCubeTexture && !1 === v.isRenderTargetTexture
                        ? -1
                        : 1),
                    (c.material.uniforms.backgroundBlurriness.value =
                      m.backgroundBlurriness),
                    (c.material.uniforms.backgroundIntensity.value =
                      m.backgroundIntensity),
                    (c.material.toneMapped = v.colorSpace !== Dd),
                    (h === v && d === v.version && p === t.toneMapping) ||
                      ((c.material.needsUpdate = !0),
                      (h = v),
                      (d = v.version),
                      (p = t.toneMapping)),
                    c.layers.enableAll(),
                    s.unshift(c, c.geometry, c.material, 0, 0, null))
                  : v &&
                    v.isTexture &&
                    (void 0 === l &&
                      ((l = new Xm(
                        new gg(2, 2),
                        new tg({
                          name: "BackgroundMaterial",
                          uniforms: $m(_g.background.uniforms),
                          vertexShader: _g.background.vertexShader,
                          fragmentShader: _g.background.fragmentShader,
                          side: Th,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      l.geometry.deleteAttribute("normal"),
                      Object.defineProperty(l.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      r.update(l)),
                    (l.material.uniforms.t2D.value = v),
                    (l.material.uniforms.backgroundIntensity.value =
                      m.backgroundIntensity),
                    (l.material.toneMapped = v.colorSpace !== Dd),
                    !0 === v.matrixAutoUpdate && v.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(v.matrix),
                    (h === v && d === v.version && p === t.toneMapping) ||
                      ((l.material.needsUpdate = !0),
                      (h = v),
                      (d = v.version),
                      (p = t.toneMapping)),
                    l.layers.enableAll(),
                    s.unshift(l, l.geometry, l.material, 0, 0, null));
            },
          };
        }
        function wg(t, e, n, i) {
          const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            o = i.isWebGL2 || null !== s,
            a = {},
            l = p(null);
          let c = l,
            u = !1;
          function h(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
          }
          function d(e) {
            return i.isWebGL2
              ? t.deleteVertexArray(e)
              : s.deleteVertexArrayOES(e);
          }
          function p(t) {
            const e = [],
              n = [],
              i = [];
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function f() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            g(t, 0);
          }
          function g(n, r) {
            const s = c.newAttributes,
              o = c.enabledAttributes,
              a = c.attributeDivisors;
            if (
              ((s[n] = 1),
              0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
              a[n] !== r)
            ) {
              (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
                (a[n] = r);
            }
          }
          function v() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
              n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
          }
          function y(e, n, i, r, s, o, a) {
            !0 === a
              ? t.vertexAttribIPointer(e, n, i, s, o)
              : t.vertexAttribPointer(e, n, i, r, s, o);
          }
          function _() {
            x(), (u = !0), c !== l && ((c = l), h(c.object));
          }
          function x() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (r, l, d, _, x) {
              let b = !1;
              if (o) {
                const e = (function (e, n, r) {
                  const o = !0 === r.wireframe;
                  let l = a[e.id];
                  void 0 === l && ((l = {}), (a[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let u = c[o];
                  void 0 === u &&
                    ((u = p(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                    (c[o] = u));
                  return u;
                })(_, d, l);
                c !== e && ((c = e), h(c.object)),
                  (b = (function (t, e, n, i) {
                    const r = c.attributes,
                      s = e.attributes;
                    let o = 0;
                    const a = n.getAttributes();
                    for (const e in a) {
                      if (a[e].location >= 0) {
                        const n = r[e];
                        let i = s[e];
                        if (
                          (void 0 === i &&
                            ("instanceMatrix" === e &&
                              t.instanceMatrix &&
                              (i = t.instanceMatrix),
                            "instanceColor" === e &&
                              t.instanceColor &&
                              (i = t.instanceColor)),
                          void 0 === n)
                        )
                          return !0;
                        if (n.attribute !== i) return !0;
                        if (i && n.data !== i.data) return !0;
                        o++;
                      }
                    }
                    return c.attributesNum !== o || c.index !== i;
                  })(r, _, d, x)),
                  b &&
                    (function (t, e, n, i) {
                      const r = {},
                        s = e.attributes;
                      let o = 0;
                      const a = n.getAttributes();
                      for (const e in a) {
                        if (a[e].location >= 0) {
                          let n = s[e];
                          void 0 === n &&
                            ("instanceMatrix" === e &&
                              t.instanceMatrix &&
                              (n = t.instanceMatrix),
                            "instanceColor" === e &&
                              t.instanceColor &&
                              (n = t.instanceColor));
                          const i = {};
                          (i.attribute = n),
                            n && n.data && (i.data = n.data),
                            (r[e] = i),
                            o++;
                        }
                      }
                      (c.attributes = r), (c.attributesNum = o), (c.index = i);
                    })(r, _, d, x);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === _.id &&
                  c.program === d.id &&
                  c.wireframe === t) ||
                  ((c.geometry = _.id),
                  (c.program = d.id),
                  (c.wireframe = t),
                  (b = !0));
              }
              null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER),
                (b || u) &&
                  ((u = !1),
                  (function (r, s, o, a) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    f();
                    const l = a.attributes,
                      c = o.getAttributes(),
                      u = s.defaultAttributeValues;
                    for (const e in c) {
                      const s = c[e];
                      if (s.location >= 0) {
                        let o = l[e];
                        if (
                          (void 0 === o &&
                            ("instanceMatrix" === e &&
                              r.instanceMatrix &&
                              (o = r.instanceMatrix),
                            "instanceColor" === e &&
                              r.instanceColor &&
                              (o = r.instanceColor)),
                          void 0 !== o)
                        ) {
                          const e = o.normalized,
                            l = o.itemSize,
                            c = n.get(o);
                          if (void 0 === c) continue;
                          const u = c.buffer,
                            h = c.type,
                            d = c.bytesPerElement,
                            p =
                              !0 === i.isWebGL2 &&
                              (h === t.INT ||
                                h === t.UNSIGNED_INT ||
                                o.gpuType === fd);
                          if (o.isInterleavedBufferAttribute) {
                            const n = o.data,
                              i = n.stride,
                              c = o.offset;
                            if (n.isInstancedInterleavedBuffer) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, n.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  n.meshPerAttribute * n.count);
                            } else
                              for (let t = 0; t < s.locationSize; t++)
                                m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, u);
                            for (let t = 0; t < s.locationSize; t++)
                              y(
                                s.location + t,
                                l / s.locationSize,
                                h,
                                e,
                                i * d,
                                (c + (l / s.locationSize) * t) * d,
                                p
                              );
                          } else {
                            if (o.isInstancedBufferAttribute) {
                              for (let t = 0; t < s.locationSize; t++)
                                g(s.location + t, o.meshPerAttribute);
                              !0 !== r.isInstancedMesh &&
                                void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  o.meshPerAttribute * o.count);
                            } else
                              for (let t = 0; t < s.locationSize; t++)
                                m(s.location + t);
                            t.bindBuffer(t.ARRAY_BUFFER, u);
                            for (let t = 0; t < s.locationSize; t++)
                              y(
                                s.location + t,
                                l / s.locationSize,
                                h,
                                e,
                                l * d,
                                (l / s.locationSize) * t * d,
                                p
                              );
                          }
                        } else if (void 0 !== u) {
                          const n = u[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(s.location, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(s.location, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(s.location, n);
                                break;
                              default:
                                t.vertexAttrib1fv(s.location, n);
                            }
                        }
                      }
                    }
                    v();
                  })(r, l, d, _),
                  null !== x &&
                    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer));
            },
            reset: _,
            resetDefaultState: x,
            dispose: function () {
              _();
              for (const t in a) {
                const e = a[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) d(n[t].object), delete n[t];
                  delete e[t];
                }
                delete a[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === a[t.id]) return;
              const e = a[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) d(n[t].object), delete n[t];
                delete e[t];
              }
              delete a[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in a) {
                const n = a[e];
                if (void 0 === n[t.id]) continue;
                const i = n[t.id];
                for (const t in i) d(i[t].object), delete i[t];
                delete n[t.id];
              }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: v,
          };
        }
        function Eg(t, e, n, i) {
          const r = i.isWebGL2;
          let s;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.render = function (e, i) {
              t.drawArrays(s, e, i), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, o, a) {
              if (0 === a) return;
              let l, c;
              if (r) (l = t), (c = "drawArraysInstanced");
              else if (
                ((l = e.get("ANGLE_instanced_arrays")),
                (c = "drawArraysInstancedANGLE"),
                null === l)
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              l[c](s, i, o, a), n.update(o, s, a);
            });
        }
        function Sg(t, e, n) {
          let i;
          function r(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
                  .precision > 0 &&
                t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                  .precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
                .precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
                .precision > 0
              ? "mediump"
              : "lowp";
          }
          const s =
            "undefined" != typeof WebGL2RenderingContext &&
            "WebGL2RenderingContext" === t.constructor.name;
          let o = void 0 !== n.precision ? n.precision : "highp";
          const a = r(o);
          a !== o &&
            (console.warn(
              "THREE.WebGLRenderer:",
              o,
              "not supported, using",
              a,
              "instead."
            ),
            (o = a));
          const l = s || e.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            d = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            g = t.getParameter(t.MAX_VARYING_VECTORS),
            v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            y = h > 0,
            _ = s || e.has("OES_texture_float");
          return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else i = 0;
              return i;
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: c,
            maxTextures: u,
            maxVertexTextures: h,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: v,
            vertexTextures: y,
            floatFragmentTextures: _,
            floatVertexTextures: y && _,
            maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
          };
        }
        function Mg(t) {
          const e = this;
          let n = null,
            i = 0,
            r = !1,
            s = !1;
          const o = new ug(),
            a = new fp(),
            l = {
              value: null,
              needsUpdate: !1,
            };
          function c(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * s,
                  r = n.matrixWorldInverse;
                a.getNormalMatrix(r),
                  (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== s; ++e, n += 4)
                  o.copy(t[e]).applyMatrix4(r, a),
                    o.normal.toArray(c, n),
                    (c[n + 3] = o.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e) {
              const n = 0 !== t.length || e || 0 !== i || r;
              return (r = e), (i = t.length), n;
            }),
            (this.beginShadows = function () {
              (s = !0), c(null);
            }),
            (this.endShadows = function () {
              s = !1;
            }),
            (this.setGlobalState = function (t, e) {
              n = c(t, e, 0);
            }),
            (this.setState = function (o, a, u) {
              const h = o.clippingPlanes,
                d = o.clipIntersection,
                p = o.clipShadows,
                f = t.get(o);
              if (!r || null === h || 0 === h.length || (s && !p))
                s
                  ? c(null)
                  : (function () {
                      l.value !== n && ((l.value = n), (l.needsUpdate = i > 0));
                      (e.numPlanes = i), (e.numIntersection = 0);
                    })();
              else {
                const t = s ? 0 : i,
                  e = 4 * t;
                let r = f.clippingState || null;
                (l.value = r), (r = c(h, a, e, u));
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                (f.clippingState = r),
                  (this.numIntersection = d ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function Tg(t) {
          let e = new WeakMap();
          function n(t, e) {
            return (
              e === td ? (t.mapping = Jh) : e === ed && (t.mapping = Qh), t
            );
          }
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                const s = r.mapping;
                if (s === td || s === ed) {
                  if (e.has(r)) {
                    return n(e.get(r).texture, r.mapping);
                  }
                  {
                    const s = r.image;
                    if (s && s.height > 0) {
                      const o = new og(s.height / 2);
                      return (
                        o.fromEquirectangularTexture(t, r),
                        e.set(r, o),
                        r.addEventListener("dispose", i),
                        n(o.texture, r.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        class Ag extends eg {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
            super(),
              (this.isOrthographicCamera = !0),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = s),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, i, r, s) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - t,
              s = n + t,
              o = i + e,
              a = i - e;
            if (null !== this.view && this.view.enabled) {
              const t =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += t * this.view.offsetX),
                (s = r + t * this.view.width),
                (o -= e * this.view.offsetY),
                (a = o - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              s,
              o,
              a,
              this.near,
              this.far,
              this.coordinateSystem
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        const Rg = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          Cg = 20,
          Lg = new Ag(),
          Pg = new lm();
        let Og = null;
        const Ig = (1 + Math.sqrt(5)) / 2,
          Ng = 1 / Ig,
          Dg = [
            new Hp(1, 1, 1),
            new Hp(-1, 1, 1),
            new Hp(1, 1, -1),
            new Hp(-1, 1, -1),
            new Hp(0, Ig, Ng),
            new Hp(0, Ig, -Ng),
            new Hp(Ng, 0, Ig),
            new Hp(-Ng, 0, Ig),
            new Hp(Ig, Ng, 0),
            new Hp(-Ig, Ng, 0),
          ];
        class Ug {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, i = 100) {
            (Og = this._renderer.getRenderTarget()), this._setSize(256);
            const r = this._allocateTargets();
            return (
              (r.depthBuffer = !0),
              this._sceneToCubeUV(t, n, i, r),
              e > 0 && this._blur(r, 0, 0, e),
              this._applyPMREM(r),
              this._cleanup(r),
              r
            );
          }
          fromEquirectangular(t, e = null) {
            return this._fromTexture(t, e);
          }
          fromCubemap(t, e = null) {
            return this._fromTexture(t, e);
          }
          compileCubemapShader() {
            null === this._cubemapMaterial &&
              ((this._cubemapMaterial = zg()),
              this._compileMaterial(this._cubemapMaterial));
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial &&
              ((this._equirectMaterial = Bg()),
              this._compileMaterial(this._equirectMaterial));
          }
          dispose() {
            this._dispose(),
              null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
              null !== this._equirectMaterial &&
                this._equirectMaterial.dispose();
          }
          _setSize(t) {
            (this._lodMax = Math.floor(Math.log2(t))),
              (this._cubeSize = Math.pow(2, this._lodMax));
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
              null !== this._pingPongRenderTarget &&
                this._pingPongRenderTarget.dispose();
            for (let t = 0; t < this._lodPlanes.length; t++)
              this._lodPlanes[t].dispose();
          }
          _cleanup(t) {
            this._renderer.setRenderTarget(Og),
              (t.scissorTest = !1),
              kg(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t, e) {
            t.mapping === Jh || t.mapping === Qh
              ? this._setSize(
                  0 === t.image.length
                    ? 16
                    : t.image[0].width || t.image[0].image.width
                )
              : this._setSize(t.image.width / 4),
              (Og = this._renderer.getRenderTarget());
            const n = e || this._allocateTargets();
            return (
              this._textureToCubeUV(t, n),
              this._applyPMREM(n),
              this._cleanup(n),
              n
            );
          }
          _allocateTargets() {
            const t = 3 * Math.max(this._cubeSize, 112),
              e = 4 * this._cubeSize,
              n = {
                magFilter: cd,
                minFilter: cd,
                generateMipmaps: !1,
                type: vd,
                format: _d,
                colorSpace: Ud,
                depthBuffer: !1,
              },
              i = Fg(t, e, n);
            if (
              null === this._pingPongRenderTarget ||
              this._pingPongRenderTarget.width !== t ||
              this._pingPongRenderTarget.height !== e
            ) {
              null !== this._pingPongRenderTarget && this._dispose(),
                (this._pingPongRenderTarget = Fg(t, e, n));
              const { _lodMax: i } = this;
              ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
              } = (function (t) {
                const e = [],
                  n = [],
                  i = [];
                let r = t;
                const s = t - 4 + 1 + Rg.length;
                for (let o = 0; o < s; o++) {
                  const s = Math.pow(2, r);
                  n.push(s);
                  let a = 1 / s;
                  o > t - 4 ? (a = Rg[o - t + 4 - 1]) : 0 === o && (a = 0),
                    i.push(a);
                  const l = 1 / (s - 2),
                    c = -l,
                    u = 1 + l,
                    h = [c, c, u, c, u, u, c, c, u, u, c, u],
                    d = 6,
                    p = 6,
                    f = 3,
                    m = 2,
                    g = 1,
                    v = new Float32Array(f * p * d),
                    y = new Float32Array(m * p * d),
                    _ = new Float32Array(g * p * d);
                  for (let t = 0; t < d; t++) {
                    const e = ((t % 3) * 2) / 3 - 1,
                      n = t > 2 ? 0 : -1,
                      i = [
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n,
                        0,
                        e + 2 / 3,
                        n + 1,
                        0,
                        e,
                        n + 1,
                        0,
                      ];
                    v.set(i, f * p * t), y.set(h, m * p * t);
                    const r = [t, t, t, t, t, t];
                    _.set(r, g * p * t);
                  }
                  const x = new Cm();
                  x.setAttribute("position", new ym(v, f)),
                    x.setAttribute("uv", new ym(y, m)),
                    x.setAttribute("faceIndex", new ym(_, g)),
                    e.push(x),
                    r > 4 && r--;
                }
                return {
                  lodPlanes: e,
                  sizeLods: n,
                  sigmas: i,
                };
              })(i)),
                (this._blurMaterial = (function (t, e, n) {
                  const i = new Float32Array(Cg),
                    r = new Hp(0, 1, 0),
                    s = new tg({
                      name: "SphericalGaussianBlur",
                      defines: {
                        n: Cg,
                        CUBEUV_TEXEL_WIDTH: 1 / e,
                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                        CUBEUV_MAX_MIP: `${t}.0`,
                      },
                      uniforms: {
                        envMap: {
                          value: null,
                        },
                        samples: {
                          value: 1,
                        },
                        weights: {
                          value: i,
                        },
                        latitudinal: {
                          value: !1,
                        },
                        dTheta: {
                          value: 0,
                        },
                        mipInt: {
                          value: 0,
                        },
                        poleAxis: {
                          value: r,
                        },
                      },
                      vertexShader: Hg(),
                      fragmentShader:
                        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                      blending: 0,
                      depthTest: !1,
                      depthWrite: !1,
                    });
                  return s;
                })(i, t, e));
            }
            return i;
          }
          _compileMaterial(t) {
            const e = new Xm(this._lodPlanes[0], t);
            this._renderer.compile(e, Lg);
          }
          _sceneToCubeUV(t, e, n, i) {
            const r = new ng(90, 1, e, n),
              s = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              a = this._renderer,
              l = a.autoClear,
              c = a.toneMapping;
            a.getClearColor(Pg), (a.toneMapping = qh), (a.autoClear = !1);
            const u = new um({
                name: "PMREM.Background",
                side: Ah,
                depthWrite: !1,
                depthTest: !1,
              }),
              h = new Xm(new Km(), u);
            let d = !1;
            const p = t.background;
            p
              ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
              : (u.color.copy(Pg), (d = !0));
            for (let e = 0; e < 6; e++) {
              const n = e % 3;
              0 === n
                ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
                : 1 === n
                ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
                : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e]));
              const l = this._cubeSize;
              kg(i, n * l, e > 2 ? l : 0, l, l),
                a.setRenderTarget(i),
                d && a.render(h, r),
                a.render(t, r);
            }
            h.geometry.dispose(),
              h.material.dispose(),
              (a.toneMapping = c),
              (a.autoClear = l),
              (t.background = p);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer,
              i = t.mapping === Jh || t.mapping === Qh;
            i
              ? (null === this._cubemapMaterial &&
                  (this._cubemapMaterial = zg()),
                (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  !1 === t.isRenderTargetTexture ? -1 : 1))
              : null === this._equirectMaterial &&
                (this._equirectMaterial = Bg());
            const r = i ? this._cubemapMaterial : this._equirectMaterial,
              s = new Xm(this._lodPlanes[0], r);
            r.uniforms.envMap.value = t;
            const o = this._cubeSize;
            kg(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, Lg);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < this._lodPlanes.length; e++) {
              const n = Math.sqrt(
                  this._sigmas[e] * this._sigmas[e] -
                    this._sigmas[e - 1] * this._sigmas[e - 1]
                ),
                i = Dg[(e - 1) % Dg.length];
              this._blur(t, e - 1, e, n, i);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, i, "latitudinal", r),
              this._halfBlur(s, t, n, n, i, "longitudinal", r);
          }
          _halfBlur(t, e, n, i, r, s, o) {
            const a = this._renderer,
              l = this._blurMaterial;
            "latitudinal" !== s &&
              "longitudinal" !== s &&
              console.error(
                "blur direction must be either latitudinal or longitudinal!"
              );
            const c = new Xm(this._lodPlanes[i], l),
              u = l.uniforms,
              h = this._sizeLods[n] - 1,
              d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
              p = r / d,
              f = isFinite(r) ? 1 + Math.floor(3 * p) : Cg;
            f > Cg &&
              console.warn(
                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
              );
            const m = [];
            let g = 0;
            for (let t = 0; t < Cg; ++t) {
              const e = t / p,
                n = Math.exp((-e * e) / 2);
              m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            (u.envMap.value = t.texture),
              (u.samples.value = f),
              (u.weights.value = m),
              (u.latitudinal.value = "latitudinal" === s),
              o && (u.poleAxis.value = o);
            const { _lodMax: v } = this;
            (u.dTheta.value = d), (u.mipInt.value = v - n);
            const y = this._sizeLods[i];
            kg(
              e,
              3 * y * (i > v - 4 ? i - v + 4 : 0),
              4 * (this._cubeSize - y),
              3 * y,
              2 * y
            ),
              a.setRenderTarget(e),
              a.render(c, Lg);
          }
        }
        function Fg(t, e, n) {
          const i = new Fp(t, e, n);
          return (
            (i.texture.mapping = nd),
            (i.texture.name = "PMREM.cubeUv"),
            (i.scissorTest = !0),
            i
          );
        }
        function kg(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
        }
        function Bg() {
          return new tg({
            name: "EquirectangularToCubeUV",
            uniforms: {
              envMap: {
                value: null,
              },
            },
            vertexShader: Hg(),
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function zg() {
          return new tg({
            name: "CubemapToCubeUV",
            uniforms: {
              envMap: {
                value: null,
              },
              flipEnvMap: {
                value: -1,
              },
            },
            vertexShader: Hg(),
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function Hg() {
          return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
        }
        function Vg(t) {
          let e = new WeakMap(),
            n = null;
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping,
                  o = s === td || s === ed,
                  a = s === Jh || s === Qh;
                if (o || a) {
                  if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                    r.needsPMREMUpdate = !1;
                    let i = e.get(r);
                    return (
                      null === n && (n = new Ug(t)),
                      (i = o
                        ? n.fromEquirectangular(r, i)
                        : n.fromCubemap(r, i)),
                      e.set(r, i),
                      i.texture
                    );
                  }
                  if (e.has(r)) return e.get(r).texture;
                  {
                    const s = r.image;
                    if (
                      (o && s && s.height > 0) ||
                      (a &&
                        s &&
                        (function (t) {
                          let e = 0;
                          const n = 6;
                          for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                          return e === n;
                        })(s))
                    ) {
                      null === n && (n = new Ug(t));
                      const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                      return (
                        e.set(r, s), r.addEventListener("dispose", i), s.texture
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
            },
          };
        }
        function Gg(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
              case "WEBGL_depth_texture":
                i =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                i =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                i =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                i =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                i = t.getExtension(n);
            }
            return (e[n] = i), i;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? n("EXT_color_buffer_float")
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float"),
                n("WEBGL_multisampled_render_to_texture");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn(
                    "THREE.WebGLRenderer: " + t + " extension not supported."
                  ),
                e
              );
            },
          };
        }
        function Wg(t, e, n, i) {
          const r = {},
            s = new WeakMap();
          function o(t) {
            const a = t.target;
            null !== a.index && e.remove(a.index);
            for (const t in a.attributes) e.remove(a.attributes[t]);
            for (const t in a.morphAttributes) {
              const n = a.morphAttributes[t];
              for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
            }
            a.removeEventListener("dispose", o), delete r[a.id];
            const l = s.get(a);
            l && (e.remove(l), s.delete(a)),
              i.releaseStatesOfGeometry(a),
              !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
              n.memory.geometries--;
          }
          function a(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position;
            let o = 0;
            if (null !== i) {
              const t = i.array;
              o = i.version;
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  s = t[e + 2];
                n.push(i, r, r, s, s, i);
              }
            } else {
              if (void 0 === r) return;
              {
                const t = r.array;
                o = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                  const t = e + 0,
                    i = e + 1,
                    r = e + 2;
                  n.push(t, i, i, r, r, t);
                }
              }
            }
            const a = new (gp(n) ? xm : _m)(n, 1);
            a.version = o;
            const l = s.get(t);
            l && e.remove(l), s.set(t, a);
          }
          return {
            get: function (t, e) {
              return (
                !0 === r[e.id] ||
                  (e.addEventListener("dispose", o),
                  (r[e.id] = !0),
                  n.memory.geometries++),
                e
              );
            },
            update: function (n) {
              const i = n.attributes;
              for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
              const r = n.morphAttributes;
              for (const n in r) {
                const i = r[n];
                for (let n = 0, r = i.length; n < r; n++)
                  e.update(i[n], t.ARRAY_BUFFER);
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && a(t);
              } else a(t);
              return s.get(t);
            },
          };
        }
        function jg(t, e, n, i) {
          const r = i.isWebGL2;
          let s, o, a;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.setIndex = function (t) {
              (o = t.type), (a = t.bytesPerElement);
            }),
            (this.render = function (e, i) {
              t.drawElements(s, i, o, e * a), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return;
              let u, h;
              if (r) (u = t), (h = "drawElementsInstanced");
              else if (
                ((u = e.get("ANGLE_instanced_arrays")),
                (h = "drawElementsInstancedANGLE"),
                null === u)
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              u[h](s, l, o, i * a, c), n.update(l, s, c);
            });
        }
        function qg(t) {
          const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0,
          };
          return {
            memory: {
              geometries: 0,
              textures: 0,
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
            },
            update: function (n, i, r) {
              switch ((e.calls++, i)) {
                case t.TRIANGLES:
                  e.triangles += r * (n / 3);
                  break;
                case t.LINES:
                  e.lines += r * (n / 2);
                  break;
                case t.LINE_STRIP:
                  e.lines += r * (n - 1);
                  break;
                case t.LINE_LOOP:
                  e.lines += r * n;
                  break;
                case t.POINTS:
                  e.points += r * n;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", i);
              }
            },
          };
        }
        function Xg(t, e) {
          return t[0] - e[0];
        }
        function Yg(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function Kg(t, e, n) {
          const i = {},
            r = new Float32Array(8),
            s = new WeakMap(),
            o = new Dp(),
            a = [];
          for (let t = 0; t < 8; t++) a[t] = [t, 0];
          return {
            update: function (l, c, u) {
              const h = l.morphTargetInfluences;
              if (!0 === e.isWebGL2) {
                const d =
                    c.morphAttributes.position ||
                    c.morphAttributes.normal ||
                    c.morphAttributes.color,
                  p = void 0 !== d ? d.length : 0;
                let f = s.get(c);
                if (void 0 === f || f.count !== p) {
                  void 0 !== f && f.texture.dispose();
                  const v = void 0 !== c.morphAttributes.position,
                    y = void 0 !== c.morphAttributes.normal,
                    _ = void 0 !== c.morphAttributes.color,
                    x = c.morphAttributes.position || [],
                    b = c.morphAttributes.normal || [],
                    w = c.morphAttributes.color || [];
                  let E = 0;
                  !0 === v && (E = 1), !0 === y && (E = 2), !0 === _ && (E = 3);
                  let S = c.attributes.position.count * E,
                    M = 1;
                  S > e.maxTextureSize &&
                    ((M = Math.ceil(S / e.maxTextureSize)),
                    (S = e.maxTextureSize));
                  const T = new Float32Array(S * M * 4 * p),
                    A = new kp(T, S, M, p);
                  (A.type = gd), (A.needsUpdate = !0);
                  const R = 4 * E;
                  for (let L = 0; L < p; L++) {
                    const P = x[L],
                      O = b[L],
                      I = w[L],
                      N = S * M * 4 * L;
                    for (let D = 0; D < P.count; D++) {
                      const U = D * R;
                      !0 === v &&
                        (o.fromBufferAttribute(P, D),
                        (T[N + U + 0] = o.x),
                        (T[N + U + 1] = o.y),
                        (T[N + U + 2] = o.z),
                        (T[N + U + 3] = 0)),
                        !0 === y &&
                          (o.fromBufferAttribute(O, D),
                          (T[N + U + 4] = o.x),
                          (T[N + U + 5] = o.y),
                          (T[N + U + 6] = o.z),
                          (T[N + U + 7] = 0)),
                        !0 === _ &&
                          (o.fromBufferAttribute(I, D),
                          (T[N + U + 8] = o.x),
                          (T[N + U + 9] = o.y),
                          (T[N + U + 10] = o.z),
                          (T[N + U + 11] = 4 === I.itemSize ? o.w : 1));
                    }
                  }
                  function C() {
                    A.dispose(),
                      s.delete(c),
                      c.removeEventListener("dispose", C);
                  }
                  (f = {
                    count: p,
                    texture: A,
                    size: new pp(S, M),
                  }),
                    s.set(c, f),
                    c.addEventListener("dispose", C);
                }
                let m = 0;
                for (let F = 0; F < h.length; F++) m += h[F];
                const g = c.morphTargetsRelative ? 1 : 1 - m;
                u.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
                  u.getUniforms().setValue(t, "morphTargetInfluences", h),
                  u
                    .getUniforms()
                    .setValue(t, "morphTargetsTexture", f.texture, n),
                  u
                    .getUniforms()
                    .setValue(t, "morphTargetsTextureSize", f.size);
              } else {
                const k = void 0 === h ? 0 : h.length;
                let B = i[c.id];
                if (void 0 === B || B.length !== k) {
                  B = [];
                  for (let W = 0; W < k; W++) B[W] = [W, 0];
                  i[c.id] = B;
                }
                for (let j = 0; j < k; j++) {
                  const q = B[j];
                  (q[0] = j), (q[1] = h[j]);
                }
                B.sort(Yg);
                for (let X = 0; X < 8; X++)
                  X < k && B[X][1]
                    ? ((a[X][0] = B[X][0]), (a[X][1] = B[X][1]))
                    : ((a[X][0] = Number.MAX_SAFE_INTEGER), (a[X][1] = 0));
                a.sort(Xg);
                const z = c.morphAttributes.position,
                  H = c.morphAttributes.normal;
                let V = 0;
                for (let Y = 0; Y < 8; Y++) {
                  const K = a[Y],
                    $ = K[0],
                    Z = K[1];
                  $ !== Number.MAX_SAFE_INTEGER && Z
                    ? (z &&
                        c.getAttribute("morphTarget" + Y) !== z[$] &&
                        c.setAttribute("morphTarget" + Y, z[$]),
                      H &&
                        c.getAttribute("morphNormal" + Y) !== H[$] &&
                        c.setAttribute("morphNormal" + Y, H[$]),
                      (r[Y] = Z),
                      (V += Z))
                    : (z &&
                        !0 === c.hasAttribute("morphTarget" + Y) &&
                        c.deleteAttribute("morphTarget" + Y),
                      H &&
                        !0 === c.hasAttribute("morphNormal" + Y) &&
                        c.deleteAttribute("morphNormal" + Y),
                      (r[Y] = 0));
                }
                const G = c.morphTargetsRelative ? 1 : 1 - V;
                u.getUniforms().setValue(t, "morphTargetBaseInfluence", G),
                  u.getUniforms().setValue(t, "morphTargetInfluences", r);
              }
            },
          };
        }
        function $g(t, e, n, i) {
          let r = new WeakMap();
          function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (o) {
              const a = i.render.frame,
                l = o.geometry,
                c = e.get(o, l);
              if (
                (r.get(c) !== a && (e.update(c), r.set(c, a)),
                o.isInstancedMesh &&
                  (!1 === o.hasEventListener("dispose", s) &&
                    o.addEventListener("dispose", s),
                  r.get(o) !== a &&
                    (n.update(o.instanceMatrix, t.ARRAY_BUFFER),
                    null !== o.instanceColor &&
                      n.update(o.instanceColor, t.ARRAY_BUFFER),
                    r.set(o, a))),
                o.isSkinnedMesh)
              ) {
                const t = o.skeleton;
                r.get(t) !== a && (t.update(), r.set(t, a));
              }
              return c;
            },
            dispose: function () {
              r = new WeakMap();
            },
          };
        }
        const Zg = new Np(),
          Jg = new kp(),
          Qg = new Bp(),
          tv = new sg(),
          ev = [],
          nv = [],
          iv = new Float32Array(16),
          rv = new Float32Array(9),
          sv = new Float32Array(4);
        function ov(t, e, n) {
          const i = t[0];
          if (i <= 0 || i > 0) return t;
          const r = e * n;
          let s = ev[r];
          if (
            (void 0 === s && ((s = new Float32Array(r)), (ev[r] = s)), 0 !== e)
          ) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
          }
          return s;
        }
        function av(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
          return !0;
        }
        function lv(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
        }
        function cv(t, e) {
          let n = nv[e];
          void 0 === n && ((n = new Int32Array(e)), (nv[e] = n));
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
          return n;
        }
        function uv(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function hv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (av(n, e)) return;
            t.uniform2fv(this.addr, e), lv(n, e);
          }
        }
        function dv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b),
              (n[0] = e.r),
              (n[1] = e.g),
              (n[2] = e.b));
          else {
            if (av(n, e)) return;
            t.uniform3fv(this.addr, e), lv(n, e);
          }
        }
        function pv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (av(n, e)) return;
            t.uniform4fv(this.addr, e), lv(n, e);
          }
        }
        function fv(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (av(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), lv(n, e);
          } else {
            if (av(n, i)) return;
            sv.set(i), t.uniformMatrix2fv(this.addr, !1, sv), lv(n, i);
          }
        }
        function mv(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (av(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), lv(n, e);
          } else {
            if (av(n, i)) return;
            rv.set(i), t.uniformMatrix3fv(this.addr, !1, rv), lv(n, i);
          }
        }
        function gv(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (av(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), lv(n, e);
          } else {
            if (av(n, i)) return;
            iv.set(i), t.uniformMatrix4fv(this.addr, !1, iv), lv(n, i);
          }
        }
        function vv(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function yv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (av(n, e)) return;
            t.uniform2iv(this.addr, e), lv(n, e);
          }
        }
        function _v(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3i(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else {
            if (av(n, e)) return;
            t.uniform3iv(this.addr, e), lv(n, e);
          }
        }
        function xv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (av(n, e)) return;
            t.uniform4iv(this.addr, e), lv(n, e);
          }
        }
        function bv(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function wv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (av(n, e)) return;
            t.uniform2uiv(this.addr, e), lv(n, e);
          }
        }
        function Ev(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3ui(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else {
            if (av(n, e)) return;
            t.uniform3uiv(this.addr, e), lv(n, e);
          }
        }
        function Sv(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (av(n, e)) return;
            t.uniform4uiv(this.addr, e), lv(n, e);
          }
        }
        function Mv(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture2D(e || Zg, r);
        }
        function Tv(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture3D(e || Qg, r);
        }
        function Av(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTextureCube(e || tv, r);
        }
        function Rv(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture2DArray(e || Jg, r);
        }
        function Cv(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function Lv(t, e) {
          const n = ov(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function Pv(t, e) {
          const n = ov(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function Ov(t, e) {
          const n = ov(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function Iv(t, e) {
          const n = ov(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function Nv(t, e) {
          const n = ov(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function Dv(t, e) {
          const n = ov(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function Uv(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function Fv(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function kv(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function Bv(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function zv(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function Hv(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function Vv(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function Gv(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function Wv(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = cv(n, r);
          av(i, s) || (t.uniform1iv(this.addr, s), lv(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || Zg, s[t]);
        }
        function jv(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = cv(n, r);
          av(i, s) || (t.uniform1iv(this.addr, s), lv(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || Qg, s[t]);
        }
        function qv(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = cv(n, r);
          av(i, s) || (t.uniform1iv(this.addr, s), lv(i, s));
          for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || tv, s[t]);
        }
        function Xv(t, e, n) {
          const i = this.cache,
            r = e.length,
            s = cv(n, r);
          av(i, s) || (t.uniform1iv(this.addr, s), lv(i, s));
          for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || Jg, s[t]);
        }
        class Yv {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return uv;
                  case 35664:
                    return hv;
                  case 35665:
                    return dv;
                  case 35666:
                    return pv;
                  case 35674:
                    return fv;
                  case 35675:
                    return mv;
                  case 35676:
                    return gv;
                  case 5124:
                  case 35670:
                    return vv;
                  case 35667:
                  case 35671:
                    return yv;
                  case 35668:
                  case 35672:
                    return _v;
                  case 35669:
                  case 35673:
                    return xv;
                  case 5125:
                    return bv;
                  case 36294:
                    return wv;
                  case 36295:
                    return Ev;
                  case 36296:
                    return Sv;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Mv;
                  case 35679:
                  case 36299:
                  case 36307:
                    return Tv;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return Av;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Rv;
                }
              })(e.type));
          }
        }
        class Kv {
          constructor(t, e, n) {
            (this.id = t),
              (this.addr = n),
              (this.cache = []),
              (this.size = e.size),
              (this.setValue = (function (t) {
                switch (t) {
                  case 5126:
                    return Cv;
                  case 35664:
                    return Lv;
                  case 35665:
                    return Pv;
                  case 35666:
                    return Ov;
                  case 35674:
                    return Iv;
                  case 35675:
                    return Nv;
                  case 35676:
                    return Dv;
                  case 5124:
                  case 35670:
                    return Uv;
                  case 35667:
                  case 35671:
                    return Fv;
                  case 35668:
                  case 35672:
                    return kv;
                  case 35669:
                  case 35673:
                    return Bv;
                  case 5125:
                    return zv;
                  case 36294:
                    return Hv;
                  case 36295:
                    return Vv;
                  case 36296:
                    return Gv;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Wv;
                  case 35679:
                  case 36299:
                  case 36307:
                    return jv;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return qv;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Xv;
                }
              })(e.type));
          }
        }
        class $v {
          constructor(t) {
            (this.id = t), (this.seq = []), (this.map = {});
          }
          setValue(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
              const s = i[r];
              s.setValue(t, e[s.id], n);
            }
          }
        }
        const Zv = /(\w+)(\])?(\[|\.)?/g;
        function Jv(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function Qv(t, e, n) {
          const i = t.name,
            r = i.length;
          for (Zv.lastIndex = 0; ; ) {
            const s = Zv.exec(i),
              o = Zv.lastIndex;
            let a = s[1];
            const l = "]" === s[2],
              c = s[3];
            if ((l && (a |= 0), void 0 === c || ("[" === c && o + 2 === r))) {
              Jv(n, void 0 === c ? new Yv(a, t, e) : new Kv(a, t, e));
              break;
            }
            {
              let t = n.map[a];
              void 0 === t && ((t = new $v(a)), Jv(n, t)), (n = t);
            }
          }
        }
        class ty {
          constructor(t, e) {
            (this.seq = []), (this.map = {});
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
              const n = t.getActiveUniform(e, i);
              Qv(n, t.getUniformLocation(e, n.name), this);
            }
          }
          setValue(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i);
          }
          setOptional(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i);
          }
          static upload(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
              const s = e[r],
                o = n[s.id];
              !1 !== o.needsUpdate && s.setValue(t, o.value, i);
            }
          }
          static seqWithValue(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i];
              r.id in e && n.push(r);
            }
            return n;
          }
        }
        function ey(t, e, n) {
          const i = t.createShader(e);
          return t.shaderSource(i, n), t.compileShader(i), i;
        }
        let ny = 0;
        function iy(t, e, n) {
          const i = t.getShaderParameter(e, t.COMPILE_STATUS),
            r = t.getShaderInfoLog(e).trim();
          if (i && "" === r) return "";
          const s = /ERROR: 0:(\d+)/.exec(r);
          if (s) {
            const i = parseInt(s[1]);
            return (
              n.toUpperCase() +
              "\n\n" +
              r +
              "\n\n" +
              (function (t, e) {
                const n = t.split("\n"),
                  i = [],
                  r = Math.max(e - 6, 0),
                  s = Math.min(e + 6, n.length);
                for (let t = r; t < s; t++) {
                  const r = t + 1;
                  i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
                }
                return i.join("\n");
              })(t.getShaderSource(e), i)
            );
          }
          return r;
        }
        function ry(t, e) {
          const n = (function (t) {
            switch (t) {
              case Ud:
                return ["Linear", "( value )"];
              case Dd:
                return ["sRGB", "( value )"];
              default:
                return (
                  console.warn(
                    "THREE.WebGLProgram: Unsupported color space:",
                    t
                  ),
                  ["Linear", "( value )"]
                );
            }
          })(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return LinearTo" +
            n[0] +
            n[1] +
            "; }"
          );
        }
        function sy(t, e) {
          let n;
          switch (e) {
            case Xh:
              n = "Linear";
              break;
            case Yh:
              n = "Reinhard";
              break;
            case Kh:
              n = "OptimizedCineon";
              break;
            case $h:
              n = "ACESFilmic";
              break;
            case Zh:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                (n = "Linear");
          }
          return (
            "vec3 " +
            t +
            "( vec3 color ) { return " +
            n +
            "ToneMapping( color ); }"
          );
        }
        function oy(t) {
          return "" !== t;
        }
        function ay(t, e) {
          const n =
            e.numSpotLightShadows +
            e.numSpotLightMaps -
            e.numSpotLightShadowsWithMaps;
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
            .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(
              /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
              e.numSpotLightShadowsWithMaps
            )
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function ly(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              e.numClippingPlanes - e.numClipIntersection
            );
        }
        const cy = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function uy(t) {
          return t.replace(cy, dy);
        }
        const hy = new Map([
          ["encodings_fragment", "colorspace_fragment"],
          ["encodings_pars_fragment", "colorspace_pars_fragment"],
          ["output_fragment", "opaque_fragment"],
        ]);
        function dy(t, e) {
          let n = vg[e];
          if (void 0 === n) {
            const t = hy.get(e);
            if (void 0 === t)
              throw new Error("Can not resolve #include <" + e + ">");
            (n = vg[t]),
              console.warn(
                'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
                e,
                t
              );
          }
          return uy(n);
        }
        const py =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function fy(t) {
          return t.replace(py, my);
        }
        function my(t, e, n, i) {
          let r = "";
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i
              .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
              .replace(/UNROLLED_LOOP_INDEX/g, t);
          return r;
        }
        function gy(t) {
          let e =
            "precision " +
            t.precision +
            " float;\nprecision " +
            t.precision +
            " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
              ? (e += "\n#define MEDIUM_PRECISION")
              : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function vy(t, e, n, i) {
          const r = t.getContext(),
            s = n.defines;
          let o = n.vertexShader,
            a = n.fragmentShader;
          const l = (function (t) {
              let e = "SHADOWMAP_TYPE_BASIC";
              return (
                t.shadowMapType === Eh
                  ? (e = "SHADOWMAP_TYPE_PCF")
                  : t.shadowMapType === Sh
                  ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                  : t.shadowMapType === Mh && (e = "SHADOWMAP_TYPE_VSM"),
                e
              );
            })(n),
            c = (function (t) {
              let e = "ENVMAP_TYPE_CUBE";
              if (t.envMap)
                switch (t.envMapMode) {
                  case Jh:
                  case Qh:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                  case nd:
                    e = "ENVMAP_TYPE_CUBE_UV";
                }
              return e;
            })(n),
            u = (function (t) {
              let e = "ENVMAP_MODE_REFLECTION";
              t.envMap && t.envMapMode === Qh && (e = "ENVMAP_MODE_REFRACTION");
              return e;
            })(n),
            h = (function (t) {
              let e = "ENVMAP_BLENDING_NONE";
              if (t.envMap)
                switch (t.combine) {
                  case Gh:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case Wh:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                  case jh:
                    e = "ENVMAP_BLENDING_ADD";
                }
              return e;
            })(n),
            d = (function (t) {
              const e = t.envMapCubeUVHeight;
              if (null === e) return null;
              const n = Math.log2(e) - 2,
                i = 1 / e;
              return {
                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                texelHeight: i,
                maxMip: n,
              };
            })(n),
            p = n.isWebGL2
              ? ""
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUVHeight ||
                    t.bumpMap ||
                    t.normalMapTangentSpace ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD ||
                      t.envMap ||
                      t.transmission) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ]
                    .filter(oy)
                    .join("\n");
                })(n),
            f = (function (t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i);
              }
              return e.join("\n");
            })(s),
            m = r.createProgram();
          let g,
            v,
            y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((g = [
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                f,
              ]
                .filter(oy)
                .join("\n")),
              g.length > 0 && (g += "\n"),
              (v = [
                p,
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                f,
              ]
                .filter(oy)
                .join("\n")),
              v.length > 0 && (v += "\n"))
            : ((g = [
                gy(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                f,
                n.instancing ? "#define USE_INSTANCING" : "",
                n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + u : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace
                  ? "#define USE_NORMALMAP_OBJECTSPACE"
                  : "",
                n.normalMapTangentSpace
                  ? "#define USE_NORMALMAP_TANGENTSPACE"
                  : "",
                n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap
                  ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                  : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap
                  ? "#define USE_SPECULAR_INTENSITYMAP"
                  : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.mapUv ? "#define MAP_UV " + n.mapUv : "",
                n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
                n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
                n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
                n.emissiveMapUv
                  ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv
                  : "",
                n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
                n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
                n.displacementMapUv
                  ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
                  : "",
                n.metalnessMapUv
                  ? "#define METALNESSMAP_UV " + n.metalnessMapUv
                  : "",
                n.roughnessMapUv
                  ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv
                  : "",
                n.anisotropyMapUv
                  ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
                  : "",
                n.clearcoatMapUv
                  ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv
                  : "",
                n.clearcoatNormalMapUv
                  ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                  : "",
                n.clearcoatRoughnessMapUv
                  ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                    n.clearcoatRoughnessMapUv
                  : "",
                n.iridescenceMapUv
                  ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
                  : "",
                n.iridescenceThicknessMapUv
                  ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                    n.iridescenceThicknessMapUv
                  : "",
                n.sheenColorMapUv
                  ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
                  : "",
                n.sheenRoughnessMapUv
                  ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                  : "",
                n.specularMapUv
                  ? "#define SPECULARMAP_UV " + n.specularMapUv
                  : "",
                n.specularColorMapUv
                  ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
                  : "",
                n.specularIntensityMapUv
                  ? "#define SPECULAR_INTENSITYMAP_UV " +
                    n.specularIntensityMapUv
                  : "",
                n.transmissionMapUv
                  ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
                  : "",
                n.thicknessMapUv
                  ? "#define THICKNESSMAP_UV " + n.thicknessMapUv
                  : "",
                n.vertexTangents && !1 === n.flatShading
                  ? "#define USE_TANGENT"
                  : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE"
                  : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE_STRIDE " +
                    n.morphTextureStride
                  : "",
                n.morphTargetsCount > 0 && n.isWebGL2
                  ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + l : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                "\tattribute mat4 instanceMatrix;",
                "#endif",
                "#ifdef USE_INSTANCING_COLOR",
                "\tattribute vec3 instanceColor;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_UV1",
                "\tattribute vec2 uv1;",
                "#endif",
                "#ifdef USE_UV2",
                "\tattribute vec2 uv2;",
                "#endif",
                "#ifdef USE_UV3",
                "\tattribute vec2 uv3;",
                "#endif",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#if defined( USE_COLOR_ALPHA )",
                "\tattribute vec4 color;",
                "#elif defined( USE_COLOR )",
                "\tattribute vec3 color;",
                "#endif",
                "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(oy)
                .join("\n")),
              (v = [
                p,
                gy(n),
                "#define SHADER_TYPE " + n.shaderType,
                "#define SHADER_NAME " + n.shaderName,
                f,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + c : "",
                n.envMap ? "#define " + u : "",
                n.envMap ? "#define " + h : "",
                d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
                d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
                d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMapObjectSpace
                  ? "#define USE_NORMALMAP_OBJECTSPACE"
                  : "",
                n.normalMapTangentSpace
                  ? "#define USE_NORMALMAP_TANGENTSPACE"
                  : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.anisotropy ? "#define USE_ANISOTROPY" : "",
                n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                n.clearcoat ? "#define USE_CLEARCOAT" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.iridescence ? "#define USE_IRIDESCENCE" : "",
                n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                n.iridescenceThicknessMap
                  ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                  : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                n.specularIntensityMap
                  ? "#define USE_SPECULAR_INTENSITYMAP"
                  : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaTest ? "#define USE_ALPHATEST" : "",
                n.alphaHash ? "#define USE_ALPHAHASH" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.vertexTangents && !1 === n.flatShading
                  ? "#define USE_TANGENT"
                  : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUv1s ? "#define USE_UV1" : "",
                n.vertexUv2s ? "#define USE_UV2" : "",
                n.vertexUv3s ? "#define USE_UV3" : "",
                n.pointsUvs ? "#define USE_POINTS_UV" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + l : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                n.toneMapping !== qh ? "#define TONE_MAPPING" : "",
                n.toneMapping !== qh ? vg.tonemapping_pars_fragment : "",
                n.toneMapping !== qh ? sy("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                n.opaque ? "#define OPAQUE" : "",
                vg.colorspace_pars_fragment,
                ry("linearToOutputTexel", n.outputColorSpace),
                n.useDepthPacking
                  ? "#define DEPTH_PACKING " + n.depthPacking
                  : "",
                "\n",
              ]
                .filter(oy)
                .join("\n"))),
            (o = uy(o)),
            (o = ay(o, n)),
            (o = ly(o, n)),
            (a = uy(a)),
            (a = ay(a, n)),
            (a = ly(a, n)),
            (o = fy(o)),
            (a = fy(a)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((y = "#version 300 es\n"),
              (g =
                [
                  "precision mediump sampler2DArray;",
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                g),
              (v =
                [
                  "#define varying in",
                  n.glslVersion === Yd
                    ? ""
                    : "layout(location = 0) out highp vec4 pc_fragColor;",
                  n.glslVersion === Yd
                    ? ""
                    : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                v));
          const _ = y + g + o,
            x = y + v + a,
            b = ey(r, r.VERTEX_SHADER, _),
            w = ey(r, r.FRAGMENT_SHADER, x);
          if (
            (r.attachShader(m, b),
            r.attachShader(m, w),
            void 0 !== n.index0AttributeName
              ? r.bindAttribLocation(m, 0, n.index0AttributeName)
              : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            t.debug.checkShaderErrors)
          ) {
            const e = r.getProgramInfoLog(m).trim(),
              n = r.getShaderInfoLog(b).trim(),
              i = r.getShaderInfoLog(w).trim();
            let s = !0,
              o = !0;
            if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
              if (((s = !1), "function" == typeof t.debug.onShaderError))
                t.debug.onShaderError(r, m, b, w);
              else {
                const t = iy(r, b, "vertex"),
                  n = iy(r, w, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    r.getError() +
                    " - VALIDATE_STATUS " +
                    r.getProgramParameter(m, r.VALIDATE_STATUS) +
                    "\n\nProgram Info Log: " +
                    e +
                    "\n" +
                    t +
                    "\n" +
                    n
                );
              }
            else
              "" !== e
                ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
                : ("" !== n && "" !== i) || (o = !1);
            o &&
              (this.diagnostics = {
                runnable: s,
                programLog: e,
                vertexShader: {
                  log: n,
                  prefix: g,
                },
                fragmentShader: {
                  log: i,
                  prefix: v,
                },
              });
          }
          let E, S;
          return (
            r.deleteShader(b),
            r.deleteShader(w),
            (this.getUniforms = function () {
              return void 0 === E && (E = new ty(r, m)), E;
            }),
            (this.getAttributes = function () {
              return (
                void 0 === S &&
                  (S = (function (t, e) {
                    const n = {},
                      i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                      const i = t.getActiveAttrib(e, r),
                        s = i.name;
                      let o = 1;
                      i.type === t.FLOAT_MAT2 && (o = 2),
                        i.type === t.FLOAT_MAT3 && (o = 3),
                        i.type === t.FLOAT_MAT4 && (o = 4),
                        (n[s] = {
                          type: i.type,
                          location: t.getAttribLocation(e, s),
                          locationSize: o,
                        });
                    }
                    return n;
                  })(r, m)),
                S
              );
            }),
            (this.destroy = function () {
              i.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                (this.program = void 0);
            }),
            (this.type = n.shaderType),
            (this.name = n.shaderName),
            (this.id = ny++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = m),
            (this.vertexShader = b),
            (this.fragmentShader = w),
            this
          );
        }
        let yy = 0;
        class _y {
          constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
          }
          update(t) {
            const e = t.vertexShader,
              n = t.fragmentShader,
              i = this._getShaderStage(e),
              r = this._getShaderStage(n),
              s = this._getShaderCacheForMaterial(t);
            return (
              !1 === s.has(i) && (s.add(i), i.usedTimes++),
              !1 === s.has(r) && (s.add(r), r.usedTimes++),
              this
            );
          }
          remove(t) {
            const e = this.materialCache.get(t);
            for (const t of e)
              t.usedTimes--,
                0 === t.usedTimes && this.shaderCache.delete(t.code);
            return this.materialCache.delete(t), this;
          }
          getVertexShaderID(t) {
            return this._getShaderStage(t.vertexShader).id;
          }
          getFragmentShaderID(t) {
            return this._getShaderStage(t.fragmentShader).id;
          }
          dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
          }
          _getShaderCacheForMaterial(t) {
            const e = this.materialCache;
            let n = e.get(t);
            return void 0 === n && ((n = new Set()), e.set(t, n)), n;
          }
          _getShaderStage(t) {
            const e = this.shaderCache;
            let n = e.get(t);
            return void 0 === n && ((n = new xy(t)), e.set(t, n)), n;
          }
        }
        class xy {
          constructor(t) {
            (this.id = yy++), (this.code = t), (this.usedTimes = 0);
          }
        }
        function by(t, e, n, i, r, s, o) {
          const a = new Cf(),
            l = new _y(),
            c = [],
            u = r.isWebGL2,
            h = r.logarithmicDepthBuffer,
            d = r.vertexTextures;
          let p = r.precision;
          const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
          function m(t) {
            return 0 === t ? "uv" : `uv${t}`;
          }
          return {
            getParameters: function (s, a, c, g, v) {
              const y = g.fog,
                _ = v.geometry,
                x = s.isMeshStandardMaterial ? g.environment : null,
                b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
                w = b && b.mapping === nd ? b.image.height : null,
                E = f[s.type];
              null !== s.precision &&
                ((p = r.getMaxPrecision(s.precision)),
                p !== s.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    s.precision,
                    "not supported, using",
                    p,
                    "instead."
                  ));
              const S =
                  _.morphAttributes.position ||
                  _.morphAttributes.normal ||
                  _.morphAttributes.color,
                M = void 0 !== S ? S.length : 0;
              let T,
                A,
                R,
                C,
                L = 0;
              if (
                (void 0 !== _.morphAttributes.position && (L = 1),
                void 0 !== _.morphAttributes.normal && (L = 2),
                void 0 !== _.morphAttributes.color && (L = 3),
                E)
              ) {
                const t = _g[E];
                (T = t.vertexShader), (A = t.fragmentShader);
              } else
                (T = s.vertexShader),
                  (A = s.fragmentShader),
                  l.update(s),
                  (R = l.getVertexShaderID(s)),
                  (C = l.getFragmentShaderID(s));
              const P = t.getRenderTarget(),
                O = !0 === v.isInstancedMesh,
                I = !!s.map,
                N = !!s.matcap,
                D = !!b,
                U = !!s.aoMap,
                F = !!s.lightMap,
                k = !!s.bumpMap,
                B = !!s.normalMap,
                z = !!s.displacementMap,
                H = !!s.emissiveMap,
                V = !!s.metalnessMap,
                G = !!s.roughnessMap,
                W = s.anisotropy > 0,
                j = s.clearcoat > 0,
                q = s.iridescence > 0,
                X = s.sheen > 0,
                Y = s.transmission > 0,
                K = W && !!s.anisotropyMap,
                $ = j && !!s.clearcoatMap,
                Z = j && !!s.clearcoatNormalMap,
                J = j && !!s.clearcoatRoughnessMap,
                Q = q && !!s.iridescenceMap,
                tt = q && !!s.iridescenceThicknessMap,
                et = X && !!s.sheenColorMap,
                nt = X && !!s.sheenRoughnessMap,
                it = !!s.specularMap,
                rt = !!s.specularColorMap,
                st = !!s.specularIntensityMap,
                ot = Y && !!s.transmissionMap,
                at = Y && !!s.thicknessMap,
                lt = !!s.gradientMap,
                ct = !!s.alphaMap,
                ut = s.alphaTest > 0,
                ht = !!s.alphaHash,
                dt = !!s.extensions,
                pt = !!_.attributes.uv1,
                ft = !!_.attributes.uv2,
                mt = !!_.attributes.uv3;
              let gt = qh;
              return (
                s.toneMapped &&
                  ((null !== P && !0 !== P.isXRRenderTarget) ||
                    (gt = t.toneMapping)),
                {
                  isWebGL2: u,
                  shaderID: E,
                  shaderType: s.type,
                  shaderName: s.name,
                  vertexShader: T,
                  fragmentShader: A,
                  defines: s.defines,
                  customVertexShaderID: R,
                  customFragmentShaderID: C,
                  isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                  glslVersion: s.glslVersion,
                  precision: p,
                  instancing: O,
                  instancingColor: O && null !== v.instanceColor,
                  supportsVertexTextures: d,
                  outputColorSpace:
                    null === P
                      ? t.outputColorSpace
                      : !0 === P.isXRRenderTarget
                      ? P.texture.colorSpace
                      : Ud,
                  map: I,
                  matcap: N,
                  envMap: D,
                  envMapMode: D && b.mapping,
                  envMapCubeUVHeight: w,
                  aoMap: U,
                  lightMap: F,
                  bumpMap: k,
                  normalMap: B,
                  displacementMap: d && z,
                  emissiveMap: H,
                  normalMapObjectSpace: B && 1 === s.normalMapType,
                  normalMapTangentSpace: B && 0 === s.normalMapType,
                  metalnessMap: V,
                  roughnessMap: G,
                  anisotropy: W,
                  anisotropyMap: K,
                  clearcoat: j,
                  clearcoatMap: $,
                  clearcoatNormalMap: Z,
                  clearcoatRoughnessMap: J,
                  iridescence: q,
                  iridescenceMap: Q,
                  iridescenceThicknessMap: tt,
                  sheen: X,
                  sheenColorMap: et,
                  sheenRoughnessMap: nt,
                  specularMap: it,
                  specularColorMap: rt,
                  specularIntensityMap: st,
                  transmission: Y,
                  transmissionMap: ot,
                  thicknessMap: at,
                  gradientMap: lt,
                  opaque: !1 === s.transparent && 1 === s.blending,
                  alphaMap: ct,
                  alphaTest: ut,
                  alphaHash: ht,
                  combine: s.combine,
                  mapUv: I && m(s.map.channel),
                  aoMapUv: U && m(s.aoMap.channel),
                  lightMapUv: F && m(s.lightMap.channel),
                  bumpMapUv: k && m(s.bumpMap.channel),
                  normalMapUv: B && m(s.normalMap.channel),
                  displacementMapUv: z && m(s.displacementMap.channel),
                  emissiveMapUv: H && m(s.emissiveMap.channel),
                  metalnessMapUv: V && m(s.metalnessMap.channel),
                  roughnessMapUv: G && m(s.roughnessMap.channel),
                  anisotropyMapUv: K && m(s.anisotropyMap.channel),
                  clearcoatMapUv: $ && m(s.clearcoatMap.channel),
                  clearcoatNormalMapUv: Z && m(s.clearcoatNormalMap.channel),
                  clearcoatRoughnessMapUv:
                    J && m(s.clearcoatRoughnessMap.channel),
                  iridescenceMapUv: Q && m(s.iridescenceMap.channel),
                  iridescenceThicknessMapUv:
                    tt && m(s.iridescenceThicknessMap.channel),
                  sheenColorMapUv: et && m(s.sheenColorMap.channel),
                  sheenRoughnessMapUv: nt && m(s.sheenRoughnessMap.channel),
                  specularMapUv: it && m(s.specularMap.channel),
                  specularColorMapUv: rt && m(s.specularColorMap.channel),
                  specularIntensityMapUv:
                    st && m(s.specularIntensityMap.channel),
                  transmissionMapUv: ot && m(s.transmissionMap.channel),
                  thicknessMapUv: at && m(s.thicknessMap.channel),
                  alphaMapUv: ct && m(s.alphaMap.channel),
                  vertexTangents: !!_.attributes.tangent && (B || W),
                  vertexColors: s.vertexColors,
                  vertexAlphas:
                    !0 === s.vertexColors &&
                    !!_.attributes.color &&
                    4 === _.attributes.color.itemSize,
                  vertexUv1s: pt,
                  vertexUv2s: ft,
                  vertexUv3s: mt,
                  pointsUvs:
                    !0 === v.isPoints && !!_.attributes.uv && (I || ct),
                  fog: !!y,
                  useFog: !0 === s.fog,
                  fogExp2: y && y.isFogExp2,
                  flatShading: !0 === s.flatShading,
                  sizeAttenuation: !0 === s.sizeAttenuation,
                  logarithmicDepthBuffer: h,
                  skinning: !0 === v.isSkinnedMesh,
                  morphTargets: void 0 !== _.morphAttributes.position,
                  morphNormals: void 0 !== _.morphAttributes.normal,
                  morphColors: void 0 !== _.morphAttributes.color,
                  morphTargetsCount: M,
                  morphTextureStride: L,
                  numDirLights: a.directional.length,
                  numPointLights: a.point.length,
                  numSpotLights: a.spot.length,
                  numSpotLightMaps: a.spotLightMap.length,
                  numRectAreaLights: a.rectArea.length,
                  numHemiLights: a.hemi.length,
                  numDirLightShadows: a.directionalShadowMap.length,
                  numPointLightShadows: a.pointShadowMap.length,
                  numSpotLightShadows: a.spotShadowMap.length,
                  numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                  numClippingPlanes: o.numPlanes,
                  numClipIntersection: o.numIntersection,
                  dithering: s.dithering,
                  shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                  shadowMapType: t.shadowMap.type,
                  toneMapping: gt,
                  useLegacyLights: t._useLegacyLights,
                  decodeVideoTexture:
                    I && !0 === s.map.isVideoTexture && s.map.colorSpace === Dd,
                  premultipliedAlpha: s.premultipliedAlpha,
                  doubleSided: 2 === s.side,
                  flipSided: s.side === Ah,
                  useDepthPacking: s.depthPacking >= 0,
                  depthPacking: s.depthPacking || 0,
                  index0AttributeName: s.index0AttributeName,
                  extensionDerivatives: dt && !0 === s.extensions.derivatives,
                  extensionFragDepth: dt && !0 === s.extensions.fragDepth,
                  extensionDrawBuffers: dt && !0 === s.extensions.drawBuffers,
                  extensionShaderTextureLOD:
                    dt && !0 === s.extensions.shaderTextureLOD,
                  rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                  rendererExtensionDrawBuffers:
                    u || i.has("WEBGL_draw_buffers"),
                  rendererExtensionShaderTextureLod:
                    u || i.has("EXT_shader_texture_lod"),
                  customProgramCacheKey: s.customProgramCacheKey(),
                }
              );
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.customVertexShaderID),
                    n.push(e.customFragmentShaderID)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              return (
                !1 === e.isRawShaderMaterial &&
                  (!(function (t, e) {
                    t.push(e.precision),
                      t.push(e.outputColorSpace),
                      t.push(e.envMapMode),
                      t.push(e.envMapCubeUVHeight),
                      t.push(e.mapUv),
                      t.push(e.alphaMapUv),
                      t.push(e.lightMapUv),
                      t.push(e.aoMapUv),
                      t.push(e.bumpMapUv),
                      t.push(e.normalMapUv),
                      t.push(e.displacementMapUv),
                      t.push(e.emissiveMapUv),
                      t.push(e.metalnessMapUv),
                      t.push(e.roughnessMapUv),
                      t.push(e.anisotropyMapUv),
                      t.push(e.clearcoatMapUv),
                      t.push(e.clearcoatNormalMapUv),
                      t.push(e.clearcoatRoughnessMapUv),
                      t.push(e.iridescenceMapUv),
                      t.push(e.iridescenceThicknessMapUv),
                      t.push(e.sheenColorMapUv),
                      t.push(e.sheenRoughnessMapUv),
                      t.push(e.specularMapUv),
                      t.push(e.specularColorMapUv),
                      t.push(e.specularIntensityMapUv),
                      t.push(e.transmissionMapUv),
                      t.push(e.thicknessMapUv),
                      t.push(e.combine),
                      t.push(e.fogExp2),
                      t.push(e.sizeAttenuation),
                      t.push(e.morphTargetsCount),
                      t.push(e.morphAttributeCount),
                      t.push(e.numDirLights),
                      t.push(e.numPointLights),
                      t.push(e.numSpotLights),
                      t.push(e.numSpotLightMaps),
                      t.push(e.numHemiLights),
                      t.push(e.numRectAreaLights),
                      t.push(e.numDirLightShadows),
                      t.push(e.numPointLightShadows),
                      t.push(e.numSpotLightShadows),
                      t.push(e.numSpotLightShadowsWithMaps),
                      t.push(e.shadowMapType),
                      t.push(e.toneMapping),
                      t.push(e.numClippingPlanes),
                      t.push(e.numClipIntersection),
                      t.push(e.depthPacking);
                  })(n, e),
                  (function (t, e) {
                    a.disableAll(), e.isWebGL2 && a.enable(0);
                    e.supportsVertexTextures && a.enable(1);
                    e.instancing && a.enable(2);
                    e.instancingColor && a.enable(3);
                    e.matcap && a.enable(4);
                    e.envMap && a.enable(5);
                    e.normalMapObjectSpace && a.enable(6);
                    e.normalMapTangentSpace && a.enable(7);
                    e.clearcoat && a.enable(8);
                    e.iridescence && a.enable(9);
                    e.alphaTest && a.enable(10);
                    e.vertexColors && a.enable(11);
                    e.vertexAlphas && a.enable(12);
                    e.vertexUv1s && a.enable(13);
                    e.vertexUv2s && a.enable(14);
                    e.vertexUv3s && a.enable(15);
                    e.vertexTangents && a.enable(16);
                    e.anisotropy && a.enable(17);
                    t.push(a.mask), a.disableAll(), e.fog && a.enable(0);
                    e.useFog && a.enable(1);
                    e.flatShading && a.enable(2);
                    e.logarithmicDepthBuffer && a.enable(3);
                    e.skinning && a.enable(4);
                    e.morphTargets && a.enable(5);
                    e.morphNormals && a.enable(6);
                    e.morphColors && a.enable(7);
                    e.premultipliedAlpha && a.enable(8);
                    e.shadowMapEnabled && a.enable(9);
                    e.useLegacyLights && a.enable(10);
                    e.doubleSided && a.enable(11);
                    e.flipSided && a.enable(12);
                    e.useDepthPacking && a.enable(13);
                    e.dithering && a.enable(14);
                    e.transmission && a.enable(15);
                    e.sheen && a.enable(16);
                    e.opaque && a.enable(17);
                    e.pointsUvs && a.enable(18);
                    e.decodeVideoTexture && a.enable(19);
                    t.push(a.mask);
                  })(n, e),
                  n.push(t.outputColorSpace)),
                n.push(e.customProgramCacheKey),
                n.join()
              );
            },
            getUniforms: function (t) {
              const e = f[t.type];
              let n;
              if (e) {
                const t = _g[e];
                n = Qm.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let i;
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                if (e.cacheKey === n) {
                  (i = e), ++i.usedTimes;
                  break;
                }
              }
              return void 0 === i && ((i = new vy(t, n, e, s)), c.push(i)), i;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = c.indexOf(t);
                (c[e] = c[c.length - 1]), c.pop(), t.destroy();
              }
            },
            releaseShaderCache: function (t) {
              l.remove(t);
            },
            programs: c,
            dispose: function () {
              l.dispose();
            },
          };
        }
        function wy() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, i) {
              t.get(e)[n] = i;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function Ey(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function Sy(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function My() {
          const t = [];
          let e = 0;
          const n = [],
            i = [],
            r = [];
          function s(n, i, r, s, o, a) {
            let l = t[e];
            return (
              void 0 === l
                ? ((l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: a,
                  }),
                  (t[e] = l))
                : ((l.id = n.id),
                  (l.object = n),
                  (l.geometry = i),
                  (l.material = r),
                  (l.groupOrder = s),
                  (l.renderOrder = n.renderOrder),
                  (l.z = o),
                  (l.group = a)),
              e++,
              l
            );
          }
          return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function () {
              (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, o, a, l, c) {
              const u = s(t, e, o, a, l, c);
              o.transmission > 0
                ? i.push(u)
                : !0 === o.transparent
                ? r.push(u)
                : n.push(u);
            },
            unshift: function (t, e, o, a, l, c) {
              const u = s(t, e, o, a, l, c);
              o.transmission > 0
                ? i.unshift(u)
                : !0 === o.transparent
                ? r.unshift(u)
                : n.unshift(u);
            },
            finish: function () {
              for (let n = e, i = t.length; n < i; n++) {
                const e = t[n];
                if (null === e.id) break;
                (e.id = null),
                  (e.object = null),
                  (e.geometry = null),
                  (e.material = null),
                  (e.group = null);
              }
            },
            sort: function (t, e) {
              n.length > 1 && n.sort(t || Ey),
                i.length > 1 && i.sort(e || Sy),
                r.length > 1 && r.sort(e || Sy);
            },
          };
        }
        function Ty() {
          let t = new WeakMap();
          return {
            get: function (e, n) {
              const i = t.get(e);
              let r;
              return (
                void 0 === i
                  ? ((r = new My()), t.set(e, [r]))
                  : n >= i.length
                  ? ((r = new My()), i.push(r))
                  : (r = i[n]),
                r
              );
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function Ay() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = {
                    direction: new Hp(),
                    color: new lm(),
                  };
                  break;
                case "SpotLight":
                  n = {
                    position: new Hp(),
                    direction: new Hp(),
                    color: new lm(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = {
                    position: new Hp(),
                    color: new lm(),
                    distance: 0,
                    decay: 0,
                  };
                  break;
                case "HemisphereLight":
                  n = {
                    direction: new Hp(),
                    skyColor: new lm(),
                    groundColor: new lm(),
                  };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new lm(),
                    position: new Hp(),
                    halfWidth: new Hp(),
                    halfHeight: new Hp(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let Ry = 0;
        function Cy(t, e) {
          return (
            (e.castShadow ? 2 : 0) -
            (t.castShadow ? 2 : 0) +
            (e.map ? 1 : 0) -
            (t.map ? 1 : 0)
          );
        }
        function Ly(t, e) {
          const n = new Ay(),
            i = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new pp(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new pp(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotLightMap: [],
              spotShadow: [],
              spotShadowMap: [],
              spotLightMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
              numSpotLightShadowsWithMaps: 0,
            };
          for (let t = 0; t < 9; t++) r.probe.push(new Hp());
          const s = new Hp(),
            o = new yf(),
            a = new yf();
          return {
            setup: function (s, o) {
              let a = 0,
                l = 0,
                c = 0;
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
              let u = 0,
                h = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                g = 0,
                v = 0,
                y = 0,
                _ = 0;
              s.sort(Cy);
              const x = !0 === o ? Math.PI : 1;
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  o = e.color,
                  b = e.intensity,
                  w = e.distance,
                  E = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight)
                  (a += o.r * b * x), (l += o.g * b * x), (c += o.b * b * x);
                else if (e.isLightProbe)
                  for (let t = 0; t < 9; t++)
                    r.probe[t].addScaledVector(e.sh.coefficients[t], b);
                else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[u] = n),
                      (r.directionalShadowMap[u] = E),
                      (r.directionalShadowMatrix[u] = e.shadow.matrix),
                      m++;
                  }
                  (r.directional[u] = t), u++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(o).multiplyScalar(b * x),
                    (t.distance = w),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    (r.spot[d] = t);
                  const s = e.shadow;
                  if (
                    (e.map &&
                      ((r.spotLightMap[y] = e.map),
                      y++,
                      s.updateMatrices(e),
                      e.castShadow && _++),
                    (r.spotLightMatrix[d] = s.matrix),
                    e.castShadow)
                  ) {
                    const t = i.get(e);
                    (t.shadowBias = s.bias),
                      (t.shadowNormalBias = s.normalBias),
                      (t.shadowRadius = s.radius),
                      (t.shadowMapSize = s.mapSize),
                      (r.spotShadow[d] = t),
                      (r.spotShadowMap[d] = E),
                      v++;
                  }
                  d++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(o).multiplyScalar(b),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[p] = t),
                    p++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[h] = n),
                      (r.pointShadowMap[h] = E),
                      (r.pointShadowMatrix[h] = e.shadow.matrix),
                      g++;
                  }
                  (r.point[h] = t), h++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(b * x),
                    t.groundColor.copy(e.groundColor).multiplyScalar(b * x),
                    (r.hemi[f] = t),
                    f++;
                }
              }
              p > 0 &&
                (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                  ? ((r.rectAreaLTC1 = yg.LTC_FLOAT_1),
                    (r.rectAreaLTC2 = yg.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_half_float_linear")
                  ? ((r.rectAreaLTC1 = yg.LTC_HALF_1),
                    (r.rectAreaLTC2 = yg.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                    )),
                (r.ambient[0] = a),
                (r.ambient[1] = l),
                (r.ambient[2] = c);
              const b = r.hash;
              (b.directionalLength === u &&
                b.pointLength === h &&
                b.spotLength === d &&
                b.rectAreaLength === p &&
                b.hemiLength === f &&
                b.numDirectionalShadows === m &&
                b.numPointShadows === g &&
                b.numSpotShadows === v &&
                b.numSpotMaps === y) ||
                ((r.directional.length = u),
                (r.spot.length = d),
                (r.rectArea.length = p),
                (r.point.length = h),
                (r.hemi.length = f),
                (r.directionalShadow.length = m),
                (r.directionalShadowMap.length = m),
                (r.pointShadow.length = g),
                (r.pointShadowMap.length = g),
                (r.spotShadow.length = v),
                (r.spotShadowMap.length = v),
                (r.directionalShadowMatrix.length = m),
                (r.pointShadowMatrix.length = g),
                (r.spotLightMatrix.length = v + y - _),
                (r.spotLightMap.length = y),
                (r.numSpotLightShadowsWithMaps = _),
                (b.directionalLength = u),
                (b.pointLength = h),
                (b.spotLength = d),
                (b.rectAreaLength = p),
                (b.hemiLength = f),
                (b.numDirectionalShadows = m),
                (b.numPointShadows = g),
                (b.numSpotShadows = v),
                (b.numSpotMaps = y),
                (r.version = Ry++));
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                u = 0;
              const h = e.matrixWorldInverse;
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                  const t = r.directional[n];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(h),
                    n++;
                } else if (d.isSpotLight) {
                  const t = r.spot[l];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(h),
                    l++;
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    a.identity(),
                    o.copy(d.matrixWorld),
                    o.premultiply(h),
                    a.extractRotation(o),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(a),
                    t.halfHeight.applyMatrix4(a),
                    c++;
                } else if (d.isPointLight) {
                  const t = r.point[i];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    i++;
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[u];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(h),
                    u++;
                }
              }
            },
            state: r,
          };
        }
        function Py(t, e) {
          const n = new Ly(t, e),
            i = [],
            r = [];
          return {
            init: function () {
              (i.length = 0), (r.length = 0);
            },
            state: {
              lightsArray: i,
              shadowsArray: r,
              lights: n,
            },
            setupLights: function (t) {
              n.setup(i, t);
            },
            setupLightsView: function (t) {
              n.setupView(i, t);
            },
            pushLight: function (t) {
              i.push(t);
            },
            pushShadow: function (t) {
              r.push(t);
            },
          };
        }
        function Oy(t, e) {
          let n = new WeakMap();
          return {
            get: function (i, r = 0) {
              const s = n.get(i);
              let o;
              return (
                void 0 === s
                  ? ((o = new Py(t, e)), n.set(i, [o]))
                  : r >= s.length
                  ? ((o = new Py(t, e)), s.push(o))
                  : (o = s[r]),
                o
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class Iy extends im {
          constructor(t) {
            super(),
              (this.isMeshDepthMaterial = !0),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        class Ny extends im {
          constructor(t) {
            super(),
              (this.isMeshDistanceMaterial = !0),
              (this.type = "MeshDistanceMaterial"),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        function Dy(t, e, n) {
          let i = new pg();
          const r = new pp(),
            s = new pp(),
            o = new Dp(),
            a = new Iy({
              depthPacking: 3201,
            }),
            l = new Ny(),
            c = {},
            u = n.maxTextureSize,
            h = {
              [Th]: Ah,
              [Ah]: Th,
              [Rh]: 2,
            },
            d = new tg({
              defines: {
                VSM_SAMPLES: 8,
              },
              uniforms: {
                shadow_pass: {
                  value: null,
                },
                resolution: {
                  value: new pp(),
                },
                radius: {
                  value: 4,
                },
              },
              vertexShader:
                "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            }),
            p = d.clone();
          p.defines.HORIZONTAL_PASS = 1;
          const f = new Cm();
          f.setAttribute(
            "position",
            new ym(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const m = new Xm(f, d),
            g = this;
          (this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = Eh);
          let v = this.type;
          function y(n, i) {
            const s = e.update(m);
            d.defines.VSM_SAMPLES !== n.blurSamples &&
              ((d.defines.VSM_SAMPLES = n.blurSamples),
              (p.defines.VSM_SAMPLES = n.blurSamples),
              (d.needsUpdate = !0),
              (p.needsUpdate = !0)),
              null === n.mapPass && (n.mapPass = new Fp(r.x, r.y)),
              (d.uniforms.shadow_pass.value = n.map.texture),
              (d.uniforms.resolution.value = n.mapSize),
              (d.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, s, d, m, null),
              (p.uniforms.shadow_pass.value = n.mapPass.texture),
              (p.uniforms.resolution.value = n.mapSize),
              (p.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, s, p, m, null);
          }
          function _(e, n, i, r) {
            let s = null;
            const o =
              !0 === i.isPointLight
                ? e.customDistanceMaterial
                : e.customDepthMaterial;
            if (void 0 !== o) s = o;
            else if (
              ((s = !0 === i.isPointLight ? l : a),
              (t.localClippingEnabled &&
                !0 === n.clipShadows &&
                Array.isArray(n.clippingPlanes) &&
                0 !== n.clippingPlanes.length) ||
                (n.displacementMap && 0 !== n.displacementScale) ||
                (n.alphaMap && n.alphaTest > 0) ||
                (n.map && n.alphaTest > 0))
            ) {
              const t = s.uuid,
                e = n.uuid;
              let i = c[t];
              void 0 === i && ((i = {}), (c[t] = i));
              let r = i[e];
              void 0 === r && ((r = s.clone()), (i[e] = r)), (s = r);
            }
            if (
              ((s.visible = n.visible),
              (s.wireframe = n.wireframe),
              (s.side =
                r === Mh
                  ? null !== n.shadowSide
                    ? n.shadowSide
                    : n.side
                  : null !== n.shadowSide
                  ? n.shadowSide
                  : h[n.side]),
              (s.alphaMap = n.alphaMap),
              (s.alphaTest = n.alphaTest),
              (s.map = n.map),
              (s.clipShadows = n.clipShadows),
              (s.clippingPlanes = n.clippingPlanes),
              (s.clipIntersection = n.clipIntersection),
              (s.displacementMap = n.displacementMap),
              (s.displacementScale = n.displacementScale),
              (s.displacementBias = n.displacementBias),
              (s.wireframeLinewidth = n.wireframeLinewidth),
              (s.linewidth = n.linewidth),
              !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial)
            ) {
              t.properties.get(s).light = i;
            }
            return s;
          }
          function x(n, r, s, o, a) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(r.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && a === Mh)) &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                s.matrixWorldInverse,
                n.matrixWorld
              );
              const i = e.update(n),
                r = n.material;
              if (Array.isArray(r)) {
                const e = i.groups;
                for (let l = 0, c = e.length; l < c; l++) {
                  const c = e[l],
                    u = r[c.materialIndex];
                  if (u && u.visible) {
                    const e = _(n, u, o, a);
                    t.renderBufferDirect(s, null, i, e, n, c);
                  }
                }
              } else if (r.visible) {
                const e = _(n, r, o, a);
                t.renderBufferDirect(s, null, i, e, n, null);
              }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, o, a);
          }
          this.render = function (e, n, a) {
            if (!1 === g.enabled) return;
            if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
            if (0 === e.length) return;
            const l = t.getRenderTarget(),
              c = t.getActiveCubeFace(),
              h = t.getActiveMipmapLevel(),
              d = t.state;
            d.setBlending(0),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1);
            const p = v !== Mh && this.type === Mh,
              f = v === Mh && this.type !== Mh;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                h = c.shadow;
              if (void 0 === h) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue;
              }
              if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
              r.copy(h.mapSize);
              const m = h.getFrameExtents();
              if (
                (r.multiply(m),
                s.copy(h.mapSize),
                (r.x > u || r.y > u) &&
                  (r.x > u &&
                    ((s.x = Math.floor(u / m.x)),
                    (r.x = s.x * m.x),
                    (h.mapSize.x = s.x)),
                  r.y > u &&
                    ((s.y = Math.floor(u / m.y)),
                    (r.y = s.y * m.y),
                    (h.mapSize.y = s.y))),
                null === h.map || !0 === p || !0 === f)
              ) {
                const t =
                  this.type !== Mh
                    ? {
                        minFilter: od,
                        magFilter: od,
                      }
                    : {};
                null !== h.map && h.map.dispose(),
                  (h.map = new Fp(r.x, r.y, t)),
                  (h.map.texture.name = c.name + ".shadowMap"),
                  h.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(h.map), t.clear();
              const g = h.getViewportCount();
              for (let t = 0; t < g; t++) {
                const e = h.getViewport(t);
                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                  d.viewport(o),
                  h.updateMatrices(c, t),
                  (i = h.getFrustum()),
                  x(n, a, h.camera, c, this.type);
              }
              !0 !== h.isPointLightShadow && this.type === Mh && y(h, a),
                (h.needsUpdate = !1);
            }
            (v = this.type), (g.needsUpdate = !1), t.setRenderTarget(l, c, h);
          };
        }
        function Uy(t, e, n) {
          const i = n.isWebGL2;
          const r = new (function () {
              let e = !1;
              const n = new Dp();
              let i = null;
              const r = new Dp(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, i, s, o, a) {
                  !0 === a && ((e *= o), (i *= o), (s *= o)),
                    n.set(e, i, s, o),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n));
                },
                reset: function () {
                  (e = !1), (i = null), r.set(-1, 0, 0, 0);
                },
              };
            })(),
            s = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null;
              return {
                setTest: function (e) {
                  e ? z(t.DEPTH_TEST) : H(t.DEPTH_TEST);
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i));
                },
                setFunc: function (e) {
                  if (i !== e) {
                    switch (e) {
                      case 0:
                        t.depthFunc(t.NEVER);
                        break;
                      case 1:
                        t.depthFunc(t.ALWAYS);
                        break;
                      case 2:
                        t.depthFunc(t.LESS);
                        break;
                      case 3:
                      default:
                        t.depthFunc(t.LEQUAL);
                        break;
                      case 4:
                        t.depthFunc(t.EQUAL);
                        break;
                      case 5:
                        t.depthFunc(t.GEQUAL);
                        break;
                      case 6:
                        t.depthFunc(t.GREATER);
                        break;
                      case 7:
                        t.depthFunc(t.NOTEQUAL);
                    }
                    i = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e));
                },
                reset: function () {
                  (e = !1), (n = null), (i = null), (r = null);
                },
              };
            })(),
            o = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                o = null,
                a = null,
                l = null,
                c = null;
              return {
                setTest: function (n) {
                  e || (n ? z(t.STENCIL_TEST) : H(t.STENCIL_TEST));
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i));
                },
                setFunc: function (e, n, o) {
                  (i === e && r === n && s === o) ||
                    (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o));
                },
                setOp: function (e, n, i) {
                  (o === e && a === n && l === i) ||
                    (t.stencilOp(e, n, i), (o = e), (a = n), (l = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (s = null),
                    (o = null),
                    (a = null),
                    (l = null),
                    (c = null);
                },
              };
            })(),
            a = new WeakMap(),
            l = new WeakMap();
          let c = {},
            u = {},
            h = new WeakMap(),
            d = [],
            p = null,
            f = !1,
            m = null,
            g = null,
            v = null,
            y = null,
            _ = null,
            x = null,
            b = null,
            w = !1,
            E = null,
            S = null,
            M = null,
            T = null,
            A = null;
          const R = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          let C = !1,
            L = 0;
          const P = t.getParameter(t.VERSION);
          -1 !== P.indexOf("WebGL")
            ? ((L = parseFloat(/^WebGL (\d)/.exec(P)[1])), (C = L >= 1))
            : -1 !== P.indexOf("OpenGL ES") &&
              ((L = parseFloat(/^OpenGL ES (\d)/.exec(P)[1])), (C = L >= 2));
          let O = null,
            I = {};
          const N = t.getParameter(t.SCISSOR_BOX),
            D = t.getParameter(t.VIEWPORT),
            U = new Dp().fromArray(N),
            F = new Dp().fromArray(D);
          function k(e, n, r, s) {
            const o = new Uint8Array(4),
              a = t.createTexture();
            t.bindTexture(e, a),
              t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
              t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (let a = 0; a < r; a++)
              !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
                ? t.texImage2D(
                    n + a,
                    0,
                    t.RGBA,
                    1,
                    1,
                    0,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    o
                  )
                : t.texImage3D(
                    n,
                    0,
                    t.RGBA,
                    1,
                    1,
                    s,
                    0,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    o
                  );
            return a;
          }
          const B = {};
          function z(e) {
            !0 !== c[e] && (t.enable(e), (c[e] = !0));
          }
          function H(e) {
            !1 !== c[e] && (t.disable(e), (c[e] = !1));
          }
          (B[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
            (B[t.TEXTURE_CUBE_MAP] = k(
              t.TEXTURE_CUBE_MAP,
              t.TEXTURE_CUBE_MAP_POSITIVE_X,
              6
            )),
            i &&
              ((B[t.TEXTURE_2D_ARRAY] = k(
                t.TEXTURE_2D_ARRAY,
                t.TEXTURE_2D_ARRAY,
                1,
                1
              )),
              (B[t.TEXTURE_3D] = k(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            o.setClear(0),
            z(t.DEPTH_TEST),
            s.setFunc(3),
            j(!1),
            q(1),
            z(t.CULL_FACE),
            W(0);
          const V = {
            [Ch]: t.FUNC_ADD,
            [Lh]: t.FUNC_SUBTRACT,
            [Ph]: t.FUNC_REVERSE_SUBTRACT,
          };
          if (i) (V[103] = t.MIN), (V[104] = t.MAX);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((V[103] = t.MIN_EXT), (V[104] = t.MAX_EXT));
          }
          const G = {
            [Oh]: t.ZERO,
            [Ih]: t.ONE,
            [Nh]: t.SRC_COLOR,
            [Uh]: t.SRC_ALPHA,
            [Vh]: t.SRC_ALPHA_SATURATE,
            [zh]: t.DST_COLOR,
            [kh]: t.DST_ALPHA,
            [Dh]: t.ONE_MINUS_SRC_COLOR,
            [Fh]: t.ONE_MINUS_SRC_ALPHA,
            [Hh]: t.ONE_MINUS_DST_COLOR,
            [Bh]: t.ONE_MINUS_DST_ALPHA,
          };
          function W(e, n, i, r, s, o, a, l) {
            if (0 !== e) {
              if ((!1 === f && (z(t.BLEND), (f = !0)), 5 === e))
                (s = s || n),
                  (o = o || i),
                  (a = a || r),
                  (n === g && s === _) ||
                    (t.blendEquationSeparate(V[n], V[s]), (g = n), (_ = s)),
                  (i === v && r === y && o === x && a === b) ||
                    (t.blendFuncSeparate(G[i], G[r], G[o], G[a]),
                    (v = i),
                    (y = r),
                    (x = o),
                    (b = a)),
                  (m = e),
                  (w = !1);
              else if (e !== m || l !== w) {
                if (
                  ((g === Ch && _ === Ch) ||
                    (t.blendEquation(t.FUNC_ADD), (g = Ch), (_ = Ch)),
                  l)
                )
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.ONE, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(
                        t.ZERO,
                        t.ONE_MINUS_SRC_COLOR,
                        t.ZERO,
                        t.ONE
                      );
                      break;
                    case 4:
                      t.blendFuncSeparate(
                        t.ZERO,
                        t.SRC_COLOR,
                        t.ZERO,
                        t.SRC_ALPHA
                      );
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(
                        t.SRC_ALPHA,
                        t.ONE_MINUS_SRC_ALPHA,
                        t.ONE,
                        t.ONE_MINUS_SRC_ALPHA
                      );
                      break;
                    case 2:
                      t.blendFunc(t.SRC_ALPHA, t.ONE);
                      break;
                    case 3:
                      t.blendFuncSeparate(
                        t.ZERO,
                        t.ONE_MINUS_SRC_COLOR,
                        t.ZERO,
                        t.ONE
                      );
                      break;
                    case 4:
                      t.blendFunc(t.ZERO, t.SRC_COLOR);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (v = null),
                  (y = null),
                  (x = null),
                  (b = null),
                  (m = e),
                  (w = l);
              }
            } else !0 === f && (H(t.BLEND), (f = !1));
          }
          function j(e) {
            E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (E = e));
          }
          function q(e) {
            0 !== e
              ? (z(t.CULL_FACE),
                e !== S &&
                  (1 === e
                    ? t.cullFace(t.BACK)
                    : 2 === e
                    ? t.cullFace(t.FRONT)
                    : t.cullFace(t.FRONT_AND_BACK)))
              : H(t.CULL_FACE),
              (S = e);
          }
          function X(e, n, i) {
            e
              ? (z(t.POLYGON_OFFSET_FILL),
                (T === n && A === i) ||
                  (t.polygonOffset(n, i), (T = n), (A = i)))
              : H(t.POLYGON_OFFSET_FILL);
          }
          return {
            buffers: {
              color: r,
              depth: s,
              stencil: o,
            },
            enable: z,
            disable: H,
            bindFramebuffer: function (e, n) {
              return (
                u[e] !== n &&
                (t.bindFramebuffer(e, n),
                (u[e] = n),
                i &&
                  (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n),
                  e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)),
                !0)
              );
            },
            drawBuffers: function (i, r) {
              let s = d,
                o = !1;
              if (i)
                if (
                  ((s = h.get(r)),
                  void 0 === s && ((s = []), h.set(r, s)),
                  i.isWebGLMultipleRenderTargets)
                ) {
                  const e = i.texture;
                  if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                    for (let n = 0, i = e.length; n < i; n++)
                      s[n] = t.COLOR_ATTACHMENT0 + n;
                    (s.length = e.length), (o = !0);
                  }
                } else
                  s[0] !== t.COLOR_ATTACHMENT0 &&
                    ((s[0] = t.COLOR_ATTACHMENT0), (o = !0));
              else s[0] !== t.BACK && ((s[0] = t.BACK), (o = !0));
              o &&
                (n.isWebGL2
                  ? t.drawBuffers(s)
                  : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
            },
            useProgram: function (e) {
              return p !== e && (t.useProgram(e), (p = e), !0);
            },
            setBlending: W,
            setMaterial: function (e, n) {
              2 === e.side ? H(t.CULL_FACE) : z(t.CULL_FACE);
              let i = e.side === Ah;
              n && (i = !i),
                j(i),
                1 === e.blending && !1 === e.transparent
                  ? W(0)
                  : W(
                      e.blending,
                      e.blendEquation,
                      e.blendSrc,
                      e.blendDst,
                      e.blendEquationAlpha,
                      e.blendSrcAlpha,
                      e.blendDstAlpha,
                      e.premultipliedAlpha
                    ),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
              const a = e.stencilWrite;
              o.setTest(a),
                a &&
                  (o.setMask(e.stencilWriteMask),
                  o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                  o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage
                  ? z(t.SAMPLE_ALPHA_TO_COVERAGE)
                  : H(t.SAMPLE_ALPHA_TO_COVERAGE);
            },
            setFlipSided: j,
            setCullFace: q,
            setLineWidth: function (e) {
              e !== M && (C && t.lineWidth(e), (M = e));
            },
            setPolygonOffset: X,
            setScissorTest: function (e) {
              e ? z(t.SCISSOR_TEST) : H(t.SCISSOR_TEST);
            },
            activeTexture: function (e) {
              void 0 === e && (e = t.TEXTURE0 + R - 1),
                O !== e && (t.activeTexture(e), (O = e));
            },
            bindTexture: function (e, n, i) {
              void 0 === i && (i = null === O ? t.TEXTURE0 + R - 1 : O);
              let r = I[i];
              void 0 === r &&
                ((r = {
                  type: void 0,
                  texture: void 0,
                }),
                (I[i] = r)),
                (r.type === e && r.texture === n) ||
                  (O !== i && (t.activeTexture(i), (O = i)),
                  t.bindTexture(e, n || B[e]),
                  (r.type = e),
                  (r.texture = n));
            },
            unbindTexture: function () {
              const e = I[O];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null),
                (e.type = void 0),
                (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexImage3D: function () {
              try {
                t.compressedTexImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            updateUBOMapping: function (e, n) {
              let i = l.get(n);
              void 0 === i && ((i = new WeakMap()), l.set(n, i));
              let r = i.get(e);
              void 0 === r &&
                ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
            },
            uniformBlockBinding: function (e, n) {
              const i = l.get(n).get(e);
              a.get(n) !== i &&
                (t.uniformBlockBinding(n, i, e.__bindingPointIndex),
                a.set(n, i));
            },
            texStorage2D: function () {
              try {
                t.texStorage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texStorage3D: function () {
              try {
                t.texStorage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage2D: function () {
              try {
                t.texSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texSubImage3D: function () {
              try {
                t.texSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage2D: function () {
              try {
                t.compressedTexSubImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            compressedTexSubImage3D: function () {
              try {
                t.compressedTexSubImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            scissor: function (e) {
              !1 === U.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), U.copy(e));
            },
            viewport: function (e) {
              !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e));
            },
            reset: function () {
              t.disable(t.BLEND),
                t.disable(t.CULL_FACE),
                t.disable(t.DEPTH_TEST),
                t.disable(t.POLYGON_OFFSET_FILL),
                t.disable(t.SCISSOR_TEST),
                t.disable(t.STENCIL_TEST),
                t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                t.blendEquation(t.FUNC_ADD),
                t.blendFunc(t.ONE, t.ZERO),
                t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(t.LESS),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(t.ALWAYS, 0, 4294967295),
                t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                t.clearStencil(0),
                t.cullFace(t.BACK),
                t.frontFace(t.CCW),
                t.polygonOffset(0, 0),
                t.activeTexture(t.TEXTURE0),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                !0 === i &&
                  (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (c = {}),
                (O = null),
                (I = {}),
                (u = {}),
                (h = new WeakMap()),
                (d = []),
                (p = null),
                (f = !1),
                (m = null),
                (g = null),
                (v = null),
                (y = null),
                (_ = null),
                (x = null),
                (b = null),
                (w = !1),
                (E = null),
                (S = null),
                (M = null),
                (T = null),
                (A = null),
                U.set(0, 0, t.canvas.width, t.canvas.height),
                F.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                o.reset();
            },
          };
        }
        function Fy(t, e, n, i, r, s, o) {
          const a = r.isWebGL2,
            l = r.maxTextures,
            c = r.maxCubemapSize,
            u = r.maxTextureSize,
            h = r.maxSamples,
            d = e.has("WEBGL_multisampled_render_to_texture")
              ? e.get("WEBGL_multisampled_render_to_texture")
              : null,
            p =
              "undefined" != typeof navigator &&
              /OculusBrowser/g.test(navigator.userAgent),
            f = new WeakMap();
          let m;
          const g = new WeakMap();
          let v = !1;
          try {
            v =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (t) {}
          function y(t, e) {
            return v ? new OffscreenCanvas(t, e) : vp("canvas");
          }
          function _(t, e, n, i) {
            let r = 1;
            if (
              ((t.width > i || t.height > i) &&
                (r = i / Math.max(t.width, t.height)),
              r < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement &&
                  t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement &&
                  t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? cp : Math.floor,
                  s = i(r * t.width),
                  o = i(r * t.height);
                void 0 === m && (m = y(s, o));
                const a = n ? y(s, o) : m;
                (a.width = s), (a.height = o);
                return (
                  a.getContext("2d").drawImage(t, 0, 0, s, o),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      t.width +
                      "x" +
                      t.height +
                      ") to (" +
                      s +
                      "x" +
                      o +
                      ")."
                  ),
                  a
                );
              }
              return (
                "data" in t &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      t.width +
                      "x" +
                      t.height +
                      ")."
                  ),
                t
              );
            }
            return t;
          }
          function x(t) {
            return ap(t.width) && ap(t.height);
          }
          function b(t, e) {
            return (
              t.generateMipmaps && e && t.minFilter !== od && t.minFilter !== cd
            );
          }
          function w(e) {
            t.generateMipmap(e);
          }
          function E(n, i, r, s, o = !1) {
            if (!1 === a) return i;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                  n +
                  "'"
              );
            }
            let l = i;
            return (
              i === t.RED &&
                (r === t.FLOAT && (l = t.R32F),
                r === t.HALF_FLOAT && (l = t.R16F),
                r === t.UNSIGNED_BYTE && (l = t.R8)),
              i === t.RED_INTEGER &&
                (r === t.UNSIGNED_BYTE && (l = t.R8UI),
                r === t.UNSIGNED_SHORT && (l = t.R16UI),
                r === t.UNSIGNED_INT && (l = t.R32UI),
                r === t.BYTE && (l = t.R8I),
                r === t.SHORT && (l = t.R16I),
                r === t.INT && (l = t.R32I)),
              i === t.RG &&
                (r === t.FLOAT && (l = t.RG32F),
                r === t.HALF_FLOAT && (l = t.RG16F),
                r === t.UNSIGNED_BYTE && (l = t.RG8)),
              i === t.RGBA &&
                (r === t.FLOAT && (l = t.RGBA32F),
                r === t.HALF_FLOAT && (l = t.RGBA16F),
                r === t.UNSIGNED_BYTE &&
                  (l = s === Dd && !1 === o ? t.SRGB8_ALPHA8 : t.RGBA8),
                r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
                r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)),
              (l !== t.R16F &&
                l !== t.R32F &&
                l !== t.RG16F &&
                l !== t.RG32F &&
                l !== t.RGBA16F &&
                l !== t.RGBA32F) ||
                e.get("EXT_color_buffer_float"),
              l
            );
          }
          function S(t, e, n) {
            return !0 === b(t, n) ||
              (t.isFramebufferTexture &&
                t.minFilter !== od &&
                t.minFilter !== cd)
              ? Math.log2(Math.max(e.width, e.height)) + 1
              : void 0 !== t.mipmaps && t.mipmaps.length > 0
              ? t.mipmaps.length
              : t.isCompressedTexture && Array.isArray(t.image)
              ? e.mipmaps.length
              : 1;
          }
          function M(e) {
            return e === od || e === ad || e === ld ? t.NEAREST : t.LINEAR;
          }
          function T(t) {
            const e = t.target;
            e.removeEventListener("dispose", T),
              (function (t) {
                const e = i.get(t);
                if (void 0 === e.__webglInit) return;
                const n = t.source,
                  r = g.get(n);
                if (r) {
                  const i = r[e.__cacheKey];
                  i.usedTimes--,
                    0 === i.usedTimes && R(t),
                    0 === Object.keys(r).length && g.delete(n);
                }
                i.remove(t);
              })(e),
              e.isVideoTexture && f.delete(e);
          }
          function A(e) {
            const n = e.target;
            n.removeEventListener("dispose", A),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  s = i.get(n);
                void 0 !== s.__webglTexture &&
                  (t.deleteTexture(s.__webglTexture), o.memory.textures--);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                  for (let e = 0; e < 6; e++) {
                    if (Array.isArray(r.__webglFramebuffer[e]))
                      for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                        t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                    else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                  }
                else {
                  if (Array.isArray(r.__webglFramebuffer))
                    for (let e = 0; e < r.__webglFramebuffer.length; e++)
                      t.deleteFramebuffer(r.__webglFramebuffer[e]);
                  else t.deleteFramebuffer(r.__webglFramebuffer);
                  if (
                    (r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer)
                  )
                    for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                      r.__webglColorRenderbuffer[e] &&
                        t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                  r.__webglDepthRenderbuffer &&
                    t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                }
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e]);
                    r.__webglTexture &&
                      (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                      i.remove(n[e]);
                  }
                i.remove(n), i.remove(e);
              })(n);
          }
          function R(e) {
            const n = i.get(e);
            t.deleteTexture(n.__webglTexture);
            const r = e.source;
            delete g.get(r)[n.__cacheKey], o.memory.textures--;
          }
          let C = 0;
          function L(e, r) {
            const s = i.get(e);
            if (
              (e.isVideoTexture &&
                (function (t) {
                  const e = o.render.frame;
                  f.get(t) !== e && (f.set(t, e), t.update());
                })(e),
              !1 === e.isRenderTargetTexture &&
                e.version > 0 &&
                s.__version !== e.version)
            ) {
              const t = e.image;
              if (null === t)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but no image data found."
                );
              else {
                if (!1 !== t.complete) return void U(s, e, r);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
          }
          const P = {
              [id]: t.REPEAT,
              [rd]: t.CLAMP_TO_EDGE,
              [sd]: t.MIRRORED_REPEAT,
            },
            O = {
              [od]: t.NEAREST,
              [ad]: t.NEAREST_MIPMAP_NEAREST,
              [ld]: t.NEAREST_MIPMAP_LINEAR,
              [cd]: t.LINEAR,
              [ud]: t.LINEAR_MIPMAP_NEAREST,
              [hd]: t.LINEAR_MIPMAP_LINEAR,
            },
            I = {
              [Bd]: t.NEVER,
              [qd]: t.ALWAYS,
              [zd]: t.LESS,
              [Vd]: t.LEQUAL,
              [Hd]: t.EQUAL,
              [jd]: t.GEQUAL,
              [Gd]: t.GREATER,
              [Wd]: t.NOTEQUAL,
            };
          function N(n, s, o) {
            if (
              (o
                ? (t.texParameteri(n, t.TEXTURE_WRAP_S, P[s.wrapS]),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, P[s.wrapT]),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, P[s.wrapR]),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, O[s.magFilter]),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, O[s.minFilter]))
                : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                  t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                  (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                    t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                  (s.wrapS === rd && s.wrapT === rd) ||
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                    ),
                  t.texParameteri(n, t.TEXTURE_MAG_FILTER, M(s.magFilter)),
                  t.texParameteri(n, t.TEXTURE_MIN_FILTER, M(s.minFilter)),
                  s.minFilter !== od &&
                    s.minFilter !== cd &&
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                    )),
              s.compareFunction &&
                (t.texParameteri(
                  n,
                  t.TEXTURE_COMPARE_MODE,
                  t.COMPARE_REF_TO_TEXTURE
                ),
                t.texParameteri(
                  n,
                  t.TEXTURE_COMPARE_FUNC,
                  I[s.compareFunction]
                )),
              !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const o = e.get("EXT_texture_filter_anisotropic");
              if (s.magFilter === od) return;
              if (s.minFilter !== ld && s.minFilter !== hd) return;
              if (s.type === gd && !1 === e.has("OES_texture_float_linear"))
                return;
              if (
                !1 === a &&
                s.type === vd &&
                !1 === e.has("OES_texture_half_float_linear")
              )
                return;
              (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  o.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(s.anisotropy, r.getMaxAnisotropy())
                ),
                (i.get(s).__currentAnisotropy = s.anisotropy));
            }
          }
          function D(e, n) {
            let i = !1;
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0), n.addEventListener("dispose", T));
            const r = n.source;
            let s = g.get(r);
            void 0 === s && ((s = {}), g.set(r, s));
            const a = (function (t) {
              const e = [];
              return (
                e.push(t.wrapS),
                e.push(t.wrapT),
                e.push(t.wrapR || 0),
                e.push(t.magFilter),
                e.push(t.minFilter),
                e.push(t.anisotropy),
                e.push(t.internalFormat),
                e.push(t.format),
                e.push(t.type),
                e.push(t.generateMipmaps),
                e.push(t.premultiplyAlpha),
                e.push(t.flipY),
                e.push(t.unpackAlignment),
                e.push(t.colorSpace),
                e.join()
              );
            })(n);
            if (a !== e.__cacheKey) {
              void 0 === s[a] &&
                ((s[a] = {
                  texture: t.createTexture(),
                  usedTimes: 0,
                }),
                o.memory.textures++,
                (i = !0)),
                s[a].usedTimes++;
              const r = s[e.__cacheKey];
              void 0 !== r &&
                (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && R(n)),
                (e.__cacheKey = a),
                (e.__webglTexture = s[a].texture);
            }
            return i;
          }
          function U(e, r, o) {
            let l = t.TEXTURE_2D;
            (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
              (l = t.TEXTURE_2D_ARRAY),
              r.isData3DTexture && (l = t.TEXTURE_3D);
            const c = D(e, r),
              h = r.source;
            n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
            const d = i.get(h);
            if (h.version !== d.__version || !0 === c) {
              n.activeTexture(t.TEXTURE0 + o),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                t.pixelStorei(
                  t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  r.premultiplyAlpha
                ),
                t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
              const e =
                (function (t) {
                  return (
                    !a &&
                    (t.wrapS !== rd ||
                      t.wrapT !== rd ||
                      (t.minFilter !== od && t.minFilter !== cd))
                  );
                })(r) && !1 === x(r.image);
              let i = _(r.image, e, !1, u);
              i = V(r, i);
              const p = x(i) || a,
                f = s.convert(r.format, r.colorSpace);
              let m,
                g = s.convert(r.type),
                v = E(r.internalFormat, f, g, r.colorSpace, r.isVideoTexture);
              N(l, r, p);
              const y = r.mipmaps,
                M = a && !0 !== r.isVideoTexture,
                T = void 0 === d.__version || !0 === c,
                A = S(r, i, p);
              if (r.isDepthTexture)
                (v = t.DEPTH_COMPONENT),
                  a
                    ? (v =
                        r.type === gd
                          ? t.DEPTH_COMPONENT32F
                          : r.type === md
                          ? t.DEPTH_COMPONENT24
                          : r.type === yd
                          ? t.DEPTH24_STENCIL8
                          : t.DEPTH_COMPONENT16)
                    : r.type === gd &&
                      console.error(
                        "WebGLRenderer: Floating point depth texture requires WebGL2."
                      ),
                  r.format === xd &&
                    v === t.DEPTH_COMPONENT &&
                    r.type !== pd &&
                    r.type !== md &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (r.type = md),
                    (g = s.convert(r.type))),
                  r.format === bd &&
                    v === t.DEPTH_COMPONENT &&
                    ((v = t.DEPTH_STENCIL),
                    r.type !== yd &&
                      (console.warn(
                        "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                      ),
                      (r.type = yd),
                      (g = s.convert(r.type)))),
                  T &&
                    (M
                      ? n.texStorage2D(t.TEXTURE_2D, 1, v, i.width, i.height)
                      : n.texImage2D(
                          t.TEXTURE_2D,
                          0,
                          v,
                          i.width,
                          i.height,
                          0,
                          f,
                          g,
                          null
                        ));
              else if (r.isDataTexture)
                if (y.length > 0 && p) {
                  M &&
                    T &&
                    n.texStorage2D(t.TEXTURE_2D, A, v, y[0].width, y[0].height);
                  for (let e = 0, i = y.length; e < i; e++)
                    (m = y[e]),
                      M
                        ? n.texSubImage2D(
                            t.TEXTURE_2D,
                            e,
                            0,
                            0,
                            m.width,
                            m.height,
                            f,
                            g,
                            m.data
                          )
                        : n.texImage2D(
                            t.TEXTURE_2D,
                            e,
                            v,
                            m.width,
                            m.height,
                            0,
                            f,
                            g,
                            m.data
                          );
                  r.generateMipmaps = !1;
                } else
                  M
                    ? (T &&
                        n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height),
                      n.texSubImage2D(
                        t.TEXTURE_2D,
                        0,
                        0,
                        0,
                        i.width,
                        i.height,
                        f,
                        g,
                        i.data
                      ))
                    : n.texImage2D(
                        t.TEXTURE_2D,
                        0,
                        v,
                        i.width,
                        i.height,
                        0,
                        f,
                        g,
                        i.data
                      );
              else if (r.isCompressedTexture)
                if (r.isCompressedArrayTexture) {
                  M &&
                    T &&
                    n.texStorage3D(
                      t.TEXTURE_2D_ARRAY,
                      A,
                      v,
                      y[0].width,
                      y[0].height,
                      i.depth
                    );
                  for (let e = 0, s = y.length; e < s; e++)
                    (m = y[e]),
                      r.format !== _d
                        ? null !== f
                          ? M
                            ? n.compressedTexSubImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                0,
                                0,
                                0,
                                m.width,
                                m.height,
                                i.depth,
                                f,
                                m.data,
                                0,
                                0
                              )
                            : n.compressedTexImage3D(
                                t.TEXTURE_2D_ARRAY,
                                e,
                                v,
                                m.width,
                                m.height,
                                i.depth,
                                0,
                                m.data,
                                0,
                                0
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : M
                        ? n.texSubImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            0,
                            0,
                            0,
                            m.width,
                            m.height,
                            i.depth,
                            f,
                            g,
                            m.data
                          )
                        : n.texImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            v,
                            m.width,
                            m.height,
                            i.depth,
                            0,
                            f,
                            g,
                            m.data
                          );
                } else {
                  M &&
                    T &&
                    n.texStorage2D(t.TEXTURE_2D, A, v, y[0].width, y[0].height);
                  for (let e = 0, i = y.length; e < i; e++)
                    (m = y[e]),
                      r.format !== _d
                        ? null !== f
                          ? M
                            ? n.compressedTexSubImage2D(
                                t.TEXTURE_2D,
                                e,
                                0,
                                0,
                                m.width,
                                m.height,
                                f,
                                m.data
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_2D,
                                e,
                                v,
                                m.width,
                                m.height,
                                0,
                                m.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : M
                        ? n.texSubImage2D(
                            t.TEXTURE_2D,
                            e,
                            0,
                            0,
                            m.width,
                            m.height,
                            f,
                            g,
                            m.data
                          )
                        : n.texImage2D(
                            t.TEXTURE_2D,
                            e,
                            v,
                            m.width,
                            m.height,
                            0,
                            f,
                            g,
                            m.data
                          );
                }
              else if (r.isDataArrayTexture)
                M
                  ? (T &&
                      n.texStorage3D(
                        t.TEXTURE_2D_ARRAY,
                        A,
                        v,
                        i.width,
                        i.height,
                        i.depth
                      ),
                    n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      i.width,
                      i.height,
                      i.depth,
                      f,
                      g,
                      i.data
                    ))
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      0,
                      v,
                      i.width,
                      i.height,
                      i.depth,
                      0,
                      f,
                      g,
                      i.data
                    );
              else if (r.isData3DTexture)
                M
                  ? (T &&
                      n.texStorage3D(
                        t.TEXTURE_3D,
                        A,
                        v,
                        i.width,
                        i.height,
                        i.depth
                      ),
                    n.texSubImage3D(
                      t.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      i.width,
                      i.height,
                      i.depth,
                      f,
                      g,
                      i.data
                    ))
                  : n.texImage3D(
                      t.TEXTURE_3D,
                      0,
                      v,
                      i.width,
                      i.height,
                      i.depth,
                      0,
                      f,
                      g,
                      i.data
                    );
              else if (r.isFramebufferTexture) {
                if (T)
                  if (M) n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height);
                  else {
                    let e = i.width,
                      r = i.height;
                    for (let i = 0; i < A; i++)
                      n.texImage2D(t.TEXTURE_2D, i, v, e, r, 0, f, g, null),
                        (e >>= 1),
                        (r >>= 1);
                  }
              } else if (y.length > 0 && p) {
                M &&
                  T &&
                  n.texStorage2D(t.TEXTURE_2D, A, v, y[0].width, y[0].height);
                for (let e = 0, i = y.length; e < i; e++)
                  (m = y[e]),
                    M
                      ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, g, m)
                      : n.texImage2D(t.TEXTURE_2D, e, v, f, g, m);
                r.generateMipmaps = !1;
              } else
                M
                  ? (T && n.texStorage2D(t.TEXTURE_2D, A, v, i.width, i.height),
                    n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, g, i))
                  : n.texImage2D(t.TEXTURE_2D, 0, v, f, g, i);
              b(r, p) && w(l),
                (d.__version = h.version),
                r.onUpdate && r.onUpdate(r);
            }
            e.__version = r.version;
          }
          function F(e, r, o, a, l, c) {
            const u = s.convert(o.format, o.colorSpace),
              h = s.convert(o.type),
              p = E(o.internalFormat, u, h, o.colorSpace);
            if (!i.get(r).__hasExternalTextures) {
              const e = Math.max(1, r.width >> c),
                i = Math.max(1, r.height >> c);
              l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY
                ? n.texImage3D(l, c, p, e, i, r.depth, 0, u, h, null)
                : n.texImage2D(l, c, p, e, i, 0, u, h, null);
            }
            n.bindFramebuffer(t.FRAMEBUFFER, e),
              H(r)
                ? d.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    a,
                    l,
                    i.get(o).__webglTexture,
                    0,
                    z(r)
                  )
                : (l === t.TEXTURE_2D ||
                    (l >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                      l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                  t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    a,
                    l,
                    i.get(o).__webglTexture,
                    c
                  ),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function k(e, n, i) {
            if (
              (t.bindRenderbuffer(t.RENDERBUFFER, e),
              n.depthBuffer && !n.stencilBuffer)
            ) {
              let r = t.DEPTH_COMPONENT16;
              if (i || H(n)) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === gd
                    ? (r = t.DEPTH_COMPONENT32F)
                    : e.type === md && (r = t.DEPTH_COMPONENT24));
                const i = z(n);
                H(n)
                  ? d.renderbufferStorageMultisampleEXT(
                      t.RENDERBUFFER,
                      i,
                      r,
                      n.width,
                      n.height
                    )
                  : t.renderbufferStorageMultisample(
                      t.RENDERBUFFER,
                      i,
                      r,
                      n.width,
                      n.height
                    );
              } else
                t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.DEPTH_ATTACHMENT,
                t.RENDERBUFFER,
                e
              );
            } else if (n.depthBuffer && n.stencilBuffer) {
              const r = z(n);
              i && !1 === H(n)
                ? t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : H(n)
                ? d.renderbufferStorageMultisampleEXT(
                    t.RENDERBUFFER,
                    r,
                    t.DEPTH24_STENCIL8,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorage(
                    t.RENDERBUFFER,
                    t.DEPTH_STENCIL,
                    n.width,
                    n.height
                  ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.RENDERBUFFER,
                  e
                );
            } else {
              const e =
                !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
              for (let r = 0; r < e.length; r++) {
                const o = e[r],
                  a = s.convert(o.format, o.colorSpace),
                  l = s.convert(o.type),
                  c = E(o.internalFormat, a, l, o.colorSpace),
                  u = z(n);
                i && !1 === H(n)
                  ? t.renderbufferStorageMultisample(
                      t.RENDERBUFFER,
                      u,
                      c,
                      n.width,
                      n.height
                    )
                  : H(n)
                  ? d.renderbufferStorageMultisampleEXT(
                      t.RENDERBUFFER,
                      u,
                      c,
                      n.width,
                      n.height
                    )
                  : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height);
              }
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null);
          }
          function B(e) {
            const r = i.get(e),
              s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
              if (s)
                throw new Error(
                  "target.depthTexture not supported in Cube render targets"
                );
              !(function (e, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                if (
                  (n.bindFramebuffer(t.FRAMEBUFFER, e),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (i.get(r.depthTexture).__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                  L(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture,
                  o = z(r);
                if (r.depthTexture.format === xd)
                  H(r)
                    ? d.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        o
                      )
                    : t.framebufferTexture2D(
                        t.FRAMEBUFFER,
                        t.DEPTH_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                else {
                  if (r.depthTexture.format !== bd)
                    throw new Error("Unknown depthTexture format");
                  H(r)
                    ? d.framebufferTexture2DMultisampleEXT(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0,
                        o
                      )
                    : t.framebufferTexture2D(
                        t.FRAMEBUFFER,
                        t.DEPTH_STENCIL_ATTACHMENT,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                }
              })(r.__webglFramebuffer, e);
            } else if (s) {
              r.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                  (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                  k(r.__webglDepthbuffer[i], e, !1);
            } else
              n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
                (r.__webglDepthbuffer = t.createRenderbuffer()),
                k(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
          function z(t) {
            return Math.min(h, t.samples);
          }
          function H(t) {
            const n = i.get(t);
            return (
              a &&
              t.samples > 0 &&
              !0 === e.has("WEBGL_multisampled_render_to_texture") &&
              !1 !== n.__useRenderToTexture
            );
          }
          function V(t, n) {
            const i = t.colorSpace,
              r = t.format,
              s = t.type;
            return (
              !0 === t.isCompressedTexture ||
                !0 === t.isVideoTexture ||
                t.format === Kd ||
                (i !== Ud &&
                  i !== Nd &&
                  (i === Dd || i === Fd
                    ? !1 === a
                      ? !0 === e.has("EXT_sRGB") && r === _d
                        ? ((t.format = Kd),
                          (t.minFilter = cd),
                          (t.generateMipmaps = !1))
                        : (n = Cp.sRGBToLinear(n))
                      : (r === _d && s === dd) ||
                        console.warn(
                          "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                        )
                    : console.error(
                        "THREE.WebGLTextures: Unsupported texture color space:",
                        i
                      ))),
              n
            );
          }
          (this.allocateTextureUnit = function () {
            const t = C;
            return (
              t >= l &&
                console.warn(
                  "THREE.WebGLTextures: Trying to use " +
                    t +
                    " texture units while this GPU supports only " +
                    l
                ),
              (C += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              C = 0;
            }),
            (this.setTexture2D = L),
            (this.setTexture2DArray = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? U(s, e, r)
                : n.bindTexture(
                    t.TEXTURE_2D_ARRAY,
                    s.__webglTexture,
                    t.TEXTURE0 + r
                  );
            }),
            (this.setTexture3D = function (e, r) {
              const s = i.get(e);
              e.version > 0 && s.__version !== e.version
                ? U(s, e, r)
                : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
            }),
            (this.setTextureCube = function (e, r) {
              const o = i.get(e);
              e.version > 0 && o.__version !== e.version
                ? (function (e, r, o) {
                    if (6 !== r.image.length) return;
                    const l = D(e, r),
                      u = r.source;
                    n.bindTexture(
                      t.TEXTURE_CUBE_MAP,
                      e.__webglTexture,
                      t.TEXTURE0 + o
                    );
                    const h = i.get(u);
                    if (u.version !== h.__version || !0 === l) {
                      n.activeTexture(t.TEXTURE0 + o),
                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                        t.pixelStorei(
                          t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                          r.premultiplyAlpha
                        ),
                        t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                        t.pixelStorei(
                          t.UNPACK_COLORSPACE_CONVERSION_WEBGL,
                          t.NONE
                        );
                      const e =
                          r.isCompressedTexture ||
                          r.image[0].isCompressedTexture,
                        i = r.image[0] && r.image[0].isDataTexture,
                        d = [];
                      for (let t = 0; t < 6; t++)
                        (d[t] =
                          e || i
                            ? i
                              ? r.image[t].image
                              : r.image[t]
                            : _(r.image[t], !1, !0, c)),
                          (d[t] = V(r, d[t]));
                      const p = d[0],
                        f = x(p) || a,
                        m = s.convert(r.format, r.colorSpace),
                        g = s.convert(r.type),
                        v = E(r.internalFormat, m, g, r.colorSpace),
                        y = a && !0 !== r.isVideoTexture,
                        M = void 0 === h.__version || !0 === l;
                      let T,
                        A = S(r, p, f);
                      if ((N(t.TEXTURE_CUBE_MAP, r, f), e)) {
                        y &&
                          M &&
                          n.texStorage2D(
                            t.TEXTURE_CUBE_MAP,
                            A,
                            v,
                            p.width,
                            p.height
                          );
                        for (let e = 0; e < 6; e++) {
                          T = d[e].mipmaps;
                          for (let i = 0; i < T.length; i++) {
                            const s = T[i];
                            r.format !== _d
                              ? null !== m
                                ? y
                                  ? n.compressedTexSubImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      0,
                                      0,
                                      s.width,
                                      s.height,
                                      m,
                                      s.data
                                    )
                                  : n.compressedTexImage2D(
                                      t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                      i,
                                      v,
                                      s.width,
                                      s.height,
                                      0,
                                      s.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : y
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  0,
                                  0,
                                  s.width,
                                  s.height,
                                  m,
                                  g,
                                  s.data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  v,
                                  s.width,
                                  s.height,
                                  0,
                                  m,
                                  g,
                                  s.data
                                );
                          }
                        }
                      } else {
                        (T = r.mipmaps),
                          y &&
                            M &&
                            (T.length > 0 && A++,
                            n.texStorage2D(
                              t.TEXTURE_CUBE_MAP,
                              A,
                              v,
                              d[0].width,
                              d[0].height
                            ));
                        for (let e = 0; e < 6; e++)
                          if (i) {
                            y
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  d[e].width,
                                  d[e].height,
                                  m,
                                  g,
                                  d[e].data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  v,
                                  d[e].width,
                                  d[e].height,
                                  0,
                                  m,
                                  g,
                                  d[e].data
                                );
                            for (let i = 0; i < T.length; i++) {
                              const r = T[i].image[e].image;
                              y
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    m,
                                    g,
                                    r.data
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    v,
                                    r.width,
                                    r.height,
                                    0,
                                    m,
                                    g,
                                    r.data
                                  );
                            }
                          } else {
                            y
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  0,
                                  0,
                                  m,
                                  g,
                                  d[e]
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  0,
                                  v,
                                  m,
                                  g,
                                  d[e]
                                );
                            for (let i = 0; i < T.length; i++) {
                              const r = T[i];
                              y
                                ? n.texSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    0,
                                    0,
                                    m,
                                    g,
                                    r.image[e]
                                  )
                                : n.texImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i + 1,
                                    v,
                                    m,
                                    g,
                                    r.image[e]
                                  );
                            }
                          }
                      }
                      b(r, f) && w(t.TEXTURE_CUBE_MAP),
                        (h.__version = u.version),
                        r.onUpdate && r.onUpdate(r);
                    }
                    e.__version = r.version;
                  })(o, e, r)
                : n.bindTexture(
                    t.TEXTURE_CUBE_MAP,
                    o.__webglTexture,
                    t.TEXTURE0 + r
                  );
            }),
            (this.rebindTextures = function (e, n, r) {
              const s = i.get(e);
              void 0 !== n &&
                F(
                  s.__webglFramebuffer,
                  e,
                  e.texture,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_2D,
                  0
                ),
                void 0 !== r && B(e);
            }),
            (this.setupRenderTarget = function (e) {
              const l = e.texture,
                c = i.get(e),
                u = i.get(l);
              e.addEventListener("dispose", A),
                !0 !== e.isWebGLMultipleRenderTargets &&
                  (void 0 === u.__webglTexture &&
                    (u.__webglTexture = t.createTexture()),
                  (u.__version = l.version),
                  o.memory.textures++);
              const h = !0 === e.isWebGLCubeRenderTarget,
                d = !0 === e.isWebGLMultipleRenderTargets,
                p = x(e) || a;
              if (h) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  if (a && l.mipmaps && l.mipmaps.length > 0) {
                    c.__webglFramebuffer[e] = [];
                    for (let n = 0; n < l.mipmaps.length; n++)
                      c.__webglFramebuffer[e][n] = t.createFramebuffer();
                  } else c.__webglFramebuffer[e] = t.createFramebuffer();
              } else {
                if (a && l.mipmaps && l.mipmaps.length > 0) {
                  c.__webglFramebuffer = [];
                  for (let e = 0; e < l.mipmaps.length; e++)
                    c.__webglFramebuffer[e] = t.createFramebuffer();
                } else c.__webglFramebuffer = t.createFramebuffer();
                if (d)
                  if (r.drawBuffers) {
                    const n = e.texture;
                    for (let e = 0, r = n.length; e < r; e++) {
                      const r = i.get(n[e]);
                      void 0 === r.__webglTexture &&
                        ((r.__webglTexture = t.createTexture()),
                        o.memory.textures++);
                    }
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                    );
                if (a && e.samples > 0 && !1 === H(e)) {
                  const i = d ? l : [l];
                  (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (c.__webglColorRenderbuffer = []),
                    n.bindFramebuffer(
                      t.FRAMEBUFFER,
                      c.__webglMultisampledFramebuffer
                    );
                  for (let n = 0; n < i.length; n++) {
                    const r = i[n];
                    (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                      t.bindRenderbuffer(
                        t.RENDERBUFFER,
                        c.__webglColorRenderbuffer[n]
                      );
                    const o = s.convert(r.format, r.colorSpace),
                      a = s.convert(r.type),
                      l = E(
                        r.internalFormat,
                        o,
                        a,
                        r.colorSpace,
                        !0 === e.isXRRenderTarget
                      ),
                      u = z(e);
                    t.renderbufferStorageMultisample(
                      t.RENDERBUFFER,
                      u,
                      l,
                      e.width,
                      e.height
                    ),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + n,
                        t.RENDERBUFFER,
                        c.__webglColorRenderbuffer[n]
                      );
                  }
                  t.bindRenderbuffer(t.RENDERBUFFER, null),
                    e.depthBuffer &&
                      ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      k(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(t.FRAMEBUFFER, null);
                }
              }
              if (h) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture),
                  N(t.TEXTURE_CUBE_MAP, l, p);
                for (let n = 0; n < 6; n++)
                  if (a && l.mipmaps && l.mipmaps.length > 0)
                    for (let i = 0; i < l.mipmaps.length; i++)
                      F(
                        c.__webglFramebuffer[n][i],
                        e,
                        l,
                        t.COLOR_ATTACHMENT0,
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        i
                      );
                  else
                    F(
                      c.__webglFramebuffer[n],
                      e,
                      l,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      0
                    );
                b(l, p) && w(t.TEXTURE_CUBE_MAP), n.unbindTexture();
              } else if (d) {
                const r = e.texture;
                for (let s = 0, o = r.length; s < o; s++) {
                  const o = r[s],
                    a = i.get(o);
                  n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                    N(t.TEXTURE_2D, o, p),
                    F(
                      c.__webglFramebuffer,
                      e,
                      o,
                      t.COLOR_ATTACHMENT0 + s,
                      t.TEXTURE_2D,
                      0
                    ),
                    b(o, p) && w(t.TEXTURE_2D);
                }
                n.unbindTexture();
              } else {
                let i = t.TEXTURE_2D;
                if (
                  ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                    (a
                      ? (i = e.isWebGL3DRenderTarget
                          ? t.TEXTURE_3D
                          : t.TEXTURE_2D_ARRAY)
                      : console.error(
                          "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                        )),
                  n.bindTexture(i, u.__webglTexture),
                  N(i, l, p),
                  a && l.mipmaps && l.mipmaps.length > 0)
                )
                  for (let n = 0; n < l.mipmaps.length; n++)
                    F(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                else F(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                b(l, p) && w(i), n.unbindTexture();
              }
              e.depthBuffer && B(e);
            }),
            (this.updateRenderTargetMipmap = function (e) {
              const r = x(e) || a,
                s =
                  !0 === e.isWebGLMultipleRenderTargets
                    ? e.texture
                    : [e.texture];
              for (let o = 0, a = s.length; o < a; o++) {
                const a = s[o];
                if (b(a, r)) {
                  const r = e.isWebGLCubeRenderTarget
                      ? t.TEXTURE_CUBE_MAP
                      : t.TEXTURE_2D,
                    s = i.get(a).__webglTexture;
                  n.bindTexture(r, s), w(r), n.unbindTexture();
                }
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (a && e.samples > 0 && !1 === H(e)) {
                const r = e.isWebGLMultipleRenderTargets
                    ? e.texture
                    : [e.texture],
                  s = e.width,
                  o = e.height;
                let a = t.COLOR_BUFFER_BIT;
                const l = [],
                  c = e.stencilBuffer
                    ? t.DEPTH_STENCIL_ATTACHMENT
                    : t.DEPTH_ATTACHMENT,
                  u = i.get(e),
                  h = !0 === e.isWebGLMultipleRenderTargets;
                if (h)
                  for (let e = 0; e < r.length; e++)
                    n.bindFramebuffer(
                      t.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        null
                      ),
                      n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        null,
                        0
                      );
                n.bindFramebuffer(
                  t.READ_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                  l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
                  const d =
                    void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                  if (
                    (!1 === d &&
                      (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                      e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)),
                    h &&
                      t.framebufferRenderbuffer(
                        t.READ_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[n]
                      ),
                    !0 === d &&
                      (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]),
                      t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])),
                    h)
                  ) {
                    const e = i.get(r[n]).__webglTexture;
                    t.framebufferTexture2D(
                      t.DRAW_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_2D,
                      e,
                      0
                    );
                  }
                  t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, t.NEAREST),
                    p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
                }
                if (
                  (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                  n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                  h)
                )
                  for (let e = 0; e < r.length; e++) {
                    n.bindFramebuffer(
                      t.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      t.framebufferRenderbuffer(
                        t.FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.RENDERBUFFER,
                        u.__webglColorRenderbuffer[e]
                      );
                    const s = i.get(r[e]).__webglTexture;
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                      t.framebufferTexture2D(
                        t.DRAW_FRAMEBUFFER,
                        t.COLOR_ATTACHMENT0 + e,
                        t.TEXTURE_2D,
                        s,
                        0
                      );
                  }
                n.bindFramebuffer(
                  t.DRAW_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                );
              }
            }),
            (this.setupDepthRenderbuffer = B),
            (this.setupFrameBufferTexture = F),
            (this.useMultisampledRTT = H);
        }
        function ky(t, e, n) {
          const i = n.isWebGL2;
          return {
            convert: function (n, r = "") {
              let s;
              const o = r === Dd || r === Fd ? 1 : 0;
              if (n === dd) return t.UNSIGNED_BYTE;
              if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
              if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
              if (1010 === n) return t.BYTE;
              if (1011 === n) return t.SHORT;
              if (n === pd) return t.UNSIGNED_SHORT;
              if (n === fd) return t.INT;
              if (n === md) return t.UNSIGNED_INT;
              if (n === gd) return t.FLOAT;
              if (n === vd)
                return i
                  ? t.HALF_FLOAT
                  : ((s = e.get("OES_texture_half_float")),
                    null !== s ? s.HALF_FLOAT_OES : null);
              if (1021 === n) return t.ALPHA;
              if (n === _d) return t.RGBA;
              if (1024 === n) return t.LUMINANCE;
              if (1025 === n) return t.LUMINANCE_ALPHA;
              if (n === xd) return t.DEPTH_COMPONENT;
              if (n === bd) return t.DEPTH_STENCIL;
              if (n === Kd)
                return (
                  (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null
                );
              if (1028 === n) return t.RED;
              if (1029 === n) return t.RED_INTEGER;
              if (1030 === n) return t.RG;
              if (1031 === n) return t.RG_INTEGER;
              if (1033 === n) return t.RGBA_INTEGER;
              if (n === wd || n === Ed || n === Sd || n === Md)
                if (1 === o) {
                  if (
                    ((s = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                    null === s)
                  )
                    return null;
                  if (n === wd) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (n === Ed) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (n === Sd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (n === Md) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else {
                  if (
                    ((s = e.get("WEBGL_compressed_texture_s3tc")), null === s)
                  )
                    return null;
                  if (n === wd) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (n === Ed) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (n === Sd) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (n === Md) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
                  return null;
                if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (36196 === n)
                return (
                  (s = e.get("WEBGL_compressed_texture_etc1")),
                  null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (37492 === n || 37496 === n) {
                if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
                  return null;
                if (37492 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ETC2
                    : s.COMPRESSED_RGB8_ETC2;
                if (37496 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                    : s.COMPRESSED_RGBA8_ETC2_EAC;
              }
              if (
                37808 === n ||
                37809 === n ||
                37810 === n ||
                37811 === n ||
                37812 === n ||
                37813 === n ||
                37814 === n ||
                37815 === n ||
                37816 === n ||
                37817 === n ||
                37818 === n ||
                37819 === n ||
                37820 === n ||
                37821 === n
              ) {
                if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
                  return null;
                if (37808 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (37809 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (37810 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (37811 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (37812 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (37813 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (37814 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (37815 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (37816 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (37817 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (37818 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (37819 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (37820 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (37821 === n)
                  return 1 === o
                    ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                    : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
              }
              if (n === Td || 36494 === n || 36495 === n) {
                if (((s = e.get("EXT_texture_compression_bptc")), null === s))
                  return null;
                if (n === Td)
                  return 1 === o
                    ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                    : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (36495 === n)
                  return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
              }
              if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                if (((s = e.get("EXT_texture_compression_rgtc")), null === s))
                  return null;
                if (n === Td) return s.COMPRESSED_RED_RGTC1_EXT;
                if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
              }
              return n === yd
                ? i
                  ? t.UNSIGNED_INT_24_8
                  : ((s = e.get("WEBGL_depth_texture")),
                    null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0 !== t[n]
                ? t[n]
                : null;
            },
          };
        }
        class By extends ng {
          constructor(t = []) {
            super(), (this.isArrayCamera = !0), (this.cameras = t);
          }
        }
        class zy extends Gf {
          constructor() {
            super(), (this.isGroup = !0), (this.type = "Group");
          }
        }
        const Hy = {
          type: "move",
        };
        class Vy {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new zy()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = {
                  pinching: !1,
                })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new zy()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new Hp()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new Hp())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new zy()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new Hp()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new Hp())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          connect(t) {
            if (t && t.hand) {
              const e = this._hand;
              if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
            }
            return (
              this.dispatchEvent({
                type: "connected",
                data: t,
              }),
              this
            );
          }
          disconnect(t) {
            return (
              this.dispatchEvent({
                type: "disconnected",
                data: t,
              }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let i = null,
              r = null,
              s = null;
            const o = this._targetRay,
              a = this._grip,
              l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState) {
              if (l && t.hand) {
                s = !0;
                for (const i of t.hand.values()) {
                  const t = e.getJointPose(i, n),
                    r = this._getHandJoint(l, i);
                  null !== t &&
                    (r.matrix.fromArray(t.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    (r.matrixWorldNeedsUpdate = !0),
                    (r.jointRadius = t.radius)),
                    (r.visible = null !== t);
                }
                const i = l.joints["index-finger-tip"],
                  r = l.joints["thumb-tip"],
                  o = i.position.distanceTo(r.position),
                  a = 0.02,
                  c = 0.005;
                l.inputState.pinching && o > a + c
                  ? ((l.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !l.inputState.pinching &&
                    o <= a - c &&
                    ((l.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== a &&
                  t.gripSpace &&
                  ((r = e.getPose(t.gripSpace, n)),
                  null !== r &&
                    (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    (a.matrixWorldNeedsUpdate = !0),
                    r.linearVelocity
                      ? ((a.hasLinearVelocity = !0),
                        a.linearVelocity.copy(r.linearVelocity))
                      : (a.hasLinearVelocity = !1),
                    r.angularVelocity
                      ? ((a.hasAngularVelocity = !0),
                        a.angularVelocity.copy(r.angularVelocity))
                      : (a.hasAngularVelocity = !1)));
              null !== o &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null === i && null !== r && (i = r),
                null !== i &&
                  (o.matrix.fromArray(i.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  (o.matrixWorldNeedsUpdate = !0),
                  i.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(i.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(i.angularVelocity))
                    : (o.hasAngularVelocity = !1),
                  this.dispatchEvent(Hy)));
            }
            return (
              null !== o && (o.visible = null !== i),
              null !== a && (a.visible = null !== r),
              null !== l && (l.visible = null !== s),
              this
            );
          }
          _getHandJoint(t, e) {
            if (void 0 === t.joints[e.jointName]) {
              const n = new zy();
              (n.matrixAutoUpdate = !1),
                (n.visible = !1),
                (t.joints[e.jointName] = n),
                t.add(n);
            }
            return t.joints[e.jointName];
          }
        }
        class Gy extends Np {
          constructor(t, e, n, i, r, s, o, a, l, c) {
            if ((c = void 0 !== c ? c : xd) !== xd && c !== bd)
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === n && c === xd && (n = md),
              void 0 === n && c === bd && (n = yd),
              super(null, i, r, s, o, a, c, n, l),
              (this.isDepthTexture = !0),
              (this.image = {
                width: t,
                height: e,
              }),
              (this.magFilter = void 0 !== o ? o : od),
              (this.minFilter = void 0 !== a ? a : od),
              (this.flipY = !1),
              (this.generateMipmaps = !1),
              (this.compareFunction = null);
          }
          copy(t) {
            return (
              super.copy(t), (this.compareFunction = t.compareFunction), this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.compareFunction &&
                (e.compareFunction = this.compareFunction),
              e
            );
          }
        }
        class Wy extends Jd {
          constructor(t, e) {
            super();
            const n = this;
            let i = null,
              r = 1,
              s = null,
              o = "local-floor",
              a = 1,
              l = null,
              c = null,
              u = null,
              h = null,
              d = null,
              p = null;
            const f = e.getContextAttributes();
            let m = null,
              g = null;
            const v = [],
              y = [],
              _ = new ng();
            _.layers.enable(1), (_.viewport = new Dp());
            const x = new ng();
            x.layers.enable(2), (x.viewport = new Dp());
            const b = [_, x],
              w = new By();
            w.layers.enable(1), w.layers.enable(2);
            let E = null,
              S = null;
            function M(t) {
              const e = y.indexOf(t.inputSource);
              if (-1 === e) return;
              const n = v[e];
              void 0 !== n &&
                (n.update(t.inputSource, t.frame, l || s),
                n.dispatchEvent({
                  type: t.type,
                  data: t.inputSource,
                }));
            }
            function T() {
              i.removeEventListener("select", M),
                i.removeEventListener("selectstart", M),
                i.removeEventListener("selectend", M),
                i.removeEventListener("squeeze", M),
                i.removeEventListener("squeezestart", M),
                i.removeEventListener("squeezeend", M),
                i.removeEventListener("end", T),
                i.removeEventListener("inputsourceschange", A);
              for (let t = 0; t < v.length; t++) {
                const e = y[t];
                null !== e && ((y[t] = null), v[t].disconnect(e));
              }
              (E = null),
                (S = null),
                t.setRenderTarget(m),
                (d = null),
                (h = null),
                (u = null),
                (i = null),
                (g = null),
                O.stop(),
                (n.isPresenting = !1),
                n.dispatchEvent({
                  type: "sessionend",
                });
            }
            function A(t) {
              for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                  i = y.indexOf(n);
                i >= 0 && ((y[i] = null), v[i].disconnect(n));
              }
              for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e];
                let i = y.indexOf(n);
                if (-1 === i) {
                  for (let t = 0; t < v.length; t++) {
                    if (t >= y.length) {
                      y.push(n), (i = t);
                      break;
                    }
                    if (null === y[t]) {
                      (y[t] = n), (i = t);
                      break;
                    }
                  }
                  if (-1 === i) break;
                }
                const r = v[i];
                r && r.connect(n);
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = v[t];
                return (
                  void 0 === e && ((e = new Vy()), (v[t] = e)),
                  e.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (t) {
                let e = v[t];
                return (
                  void 0 === e && ((e = new Vy()), (v[t] = e)), e.getGripSpace()
                );
              }),
              (this.getHand = function (t) {
                let e = v[t];
                return (
                  void 0 === e && ((e = new Vy()), (v[t] = e)), e.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (r = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (t) {
                (o = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return l || s;
              }),
              (this.setReferenceSpace = function (t) {
                l = t;
              }),
              (this.getBaseLayer = function () {
                return null !== h ? h : d;
              }),
              (this.getBinding = function () {
                return u;
              }),
              (this.getFrame = function () {
                return p;
              }),
              (this.getSession = function () {
                return i;
              }),
              (this.setSession = async function (c) {
                if (((i = c), null !== i)) {
                  if (
                    ((m = t.getRenderTarget()),
                    i.addEventListener("select", M),
                    i.addEventListener("selectstart", M),
                    i.addEventListener("selectend", M),
                    i.addEventListener("squeeze", M),
                    i.addEventListener("squeezestart", M),
                    i.addEventListener("squeezeend", M),
                    i.addEventListener("end", T),
                    i.addEventListener("inputsourceschange", A),
                    !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                    void 0 === i.renderState.layers ||
                      !1 === t.capabilities.isWebGL2)
                  ) {
                    const n = {
                      antialias: void 0 !== i.renderState.layers || f.antialias,
                      alpha: !0,
                      depth: f.depth,
                      stencil: f.stencil,
                      framebufferScaleFactor: r,
                    };
                    (d = new XRWebGLLayer(i, e, n)),
                      i.updateRenderState({
                        baseLayer: d,
                      }),
                      (g = new Fp(d.framebufferWidth, d.framebufferHeight, {
                        format: _d,
                        type: dd,
                        colorSpace: t.outputColorSpace,
                        stencilBuffer: f.stencil,
                      }));
                  } else {
                    let n = null,
                      s = null,
                      o = null;
                    f.depth &&
                      ((o = f.stencil
                        ? e.DEPTH24_STENCIL8
                        : e.DEPTH_COMPONENT24),
                      (n = f.stencil ? bd : xd),
                      (s = f.stencil ? yd : md));
                    const a = {
                      colorFormat: e.RGBA8,
                      depthFormat: o,
                      scaleFactor: r,
                    };
                    (u = new XRWebGLBinding(i, e)),
                      (h = u.createProjectionLayer(a)),
                      i.updateRenderState({
                        layers: [h],
                      }),
                      (g = new Fp(h.textureWidth, h.textureHeight, {
                        format: _d,
                        type: dd,
                        depthTexture: new Gy(
                          h.textureWidth,
                          h.textureHeight,
                          s,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          n
                        ),
                        stencilBuffer: f.stencil,
                        colorSpace: t.outputColorSpace,
                        samples: f.antialias ? 4 : 0,
                      }));
                    t.properties.get(g).__ignoreDepthValues =
                      h.ignoreDepthValues;
                  }
                  (g.isXRRenderTarget = !0),
                    this.setFoveation(a),
                    (l = null),
                    (s = await i.requestReferenceSpace(o)),
                    O.setContext(i),
                    O.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({
                      type: "sessionstart",
                    });
                }
              }),
              (this.getEnvironmentBlendMode = function () {
                if (null !== i) return i.environmentBlendMode;
              });
            const R = new Hp(),
              C = new Hp();
            function L(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            (this.updateCamera = function (t) {
              if (null === i) return;
              (w.near = x.near = _.near = t.near),
                (w.far = x.far = _.far = t.far),
                (E === w.near && S === w.far) ||
                  (i.updateRenderState({
                    depthNear: w.near,
                    depthFar: w.far,
                  }),
                  (E = w.near),
                  (S = w.far));
              const e = t.parent,
                n = w.cameras;
              L(w, e);
              for (let t = 0; t < n.length; t++) L(n[t], e);
              2 === n.length
                ? (function (t, e, n) {
                    R.setFromMatrixPosition(e.matrixWorld),
                      C.setFromMatrixPosition(n.matrixWorld);
                    const i = R.distanceTo(C),
                      r = e.projectionMatrix.elements,
                      s = n.projectionMatrix.elements,
                      o = r[14] / (r[10] - 1),
                      a = r[14] / (r[10] + 1),
                      l = (r[9] + 1) / r[5],
                      c = (r[9] - 1) / r[5],
                      u = (r[8] - 1) / r[0],
                      h = (s[8] + 1) / s[0],
                      d = o * u,
                      p = o * h,
                      f = i / (-u + h),
                      m = f * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(m),
                      t.translateZ(f),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f,
                      v = a + f,
                      y = d - m,
                      _ = p + (i - m),
                      x = ((l * a) / v) * g,
                      b = ((c * a) / v) * g;
                    t.projectionMatrix.makePerspective(y, _, x, b, g, v),
                      t.projectionMatrixInverse
                        .copy(t.projectionMatrix)
                        .invert();
                  })(w, _, x)
                : w.projectionMatrix.copy(_.projectionMatrix),
                (function (t, e, n) {
                  null === n
                    ? t.matrix.copy(e.matrixWorld)
                    : (t.matrix.copy(n.matrixWorld),
                      t.matrix.invert(),
                      t.matrix.multiply(e.matrixWorld));
                  t.matrix.decompose(t.position, t.quaternion, t.scale),
                    t.updateMatrixWorld(!0),
                    t.projectionMatrix.copy(e.projectionMatrix),
                    t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    t.isPerspectiveCamera &&
                      ((t.fov =
                        2 * np * Math.atan(1 / t.projectionMatrix.elements[5])),
                      (t.zoom = 1));
                })(t, w, e);
            }),
              (this.getCamera = function () {
                return w;
              }),
              (this.getFoveation = function () {
                if (null !== h || null !== d) return a;
              }),
              (this.setFoveation = function (t) {
                (a = t),
                  null !== h && (h.fixedFoveation = t),
                  null !== d &&
                    void 0 !== d.fixedFoveation &&
                    (d.fixedFoveation = t);
              });
            let P = null;
            const O = new fg();
            O.setAnimationLoop(function (e, i) {
              if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
                const e = c.views;
                null !== d &&
                  (t.setRenderTargetFramebuffer(g, d.framebuffer),
                  t.setRenderTarget(g));
                let n = !1;
                e.length !== w.cameras.length &&
                  ((w.cameras.length = 0), (n = !0));
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  let s = null;
                  if (null !== d) s = d.getViewport(r);
                  else {
                    const e = u.getViewSubImage(h, r);
                    (s = e.viewport),
                      0 === i &&
                        (t.setRenderTargetTextures(
                          g,
                          e.colorTexture,
                          h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                        ),
                        t.setRenderTarget(g));
                  }
                  let o = b[i];
                  void 0 === o &&
                    ((o = new ng()),
                    o.layers.enable(i),
                    (o.viewport = new Dp()),
                    (b[i] = o)),
                    o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.quaternion, o.scale),
                    o.projectionMatrix.fromArray(r.projectionMatrix),
                    o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                    o.viewport.set(s.x, s.y, s.width, s.height),
                    0 === i &&
                      (w.matrix.copy(o.matrix),
                      w.matrix.decompose(w.position, w.quaternion, w.scale)),
                    !0 === n && w.cameras.push(o);
                }
              }
              for (let t = 0; t < v.length; t++) {
                const e = y[t],
                  n = v[t];
                null !== e && void 0 !== n && n.update(e, i, l || s);
              }
              P && P(e, i),
                i.detectedPlanes &&
                  n.dispatchEvent({
                    type: "planesdetected",
                    data: i,
                  }),
                (p = null);
            }),
              (this.setAnimationLoop = function (t) {
                P = t;
              }),
              (this.dispose = function () {});
          }
        }
        function jy(t, e) {
          function n(t, e) {
            !0 === t.matrixAutoUpdate && t.updateMatrix(),
              e.value.copy(t.matrix);
          }
          function i(i, r) {
            (i.opacity.value = r.opacity),
              r.color && i.diffuse.value.copy(r.color),
              r.emissive &&
                i.emissive.value
                  .copy(r.emissive)
                  .multiplyScalar(r.emissiveIntensity),
              r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
              r.alphaMap &&
                ((i.alphaMap.value = r.alphaMap),
                n(r.alphaMap, i.alphaMapTransform)),
              r.bumpMap &&
                ((i.bumpMap.value = r.bumpMap),
                n(r.bumpMap, i.bumpMapTransform),
                (i.bumpScale.value = r.bumpScale),
                r.side === Ah && (i.bumpScale.value *= -1)),
              r.normalMap &&
                ((i.normalMap.value = r.normalMap),
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                r.side === Ah && i.normalScale.value.negate()),
              r.displacementMap &&
                ((i.displacementMap.value = r.displacementMap),
                n(r.displacementMap, i.displacementMapTransform),
                (i.displacementScale.value = r.displacementScale),
                (i.displacementBias.value = r.displacementBias)),
              r.emissiveMap &&
                ((i.emissiveMap.value = r.emissiveMap),
                n(r.emissiveMap, i.emissiveMapTransform)),
              r.specularMap &&
                ((i.specularMap.value = r.specularMap),
                n(r.specularMap, i.specularMapTransform)),
              r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
            const s = e.get(r).envMap;
            if (
              (s &&
                ((i.envMap.value = s),
                (i.flipEnvMap.value =
                  s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
                (i.reflectivity.value = r.reflectivity),
                (i.ior.value = r.ior),
                (i.refractionRatio.value = r.refractionRatio)),
              r.lightMap)
            ) {
              i.lightMap.value = r.lightMap;
              const e = !0 === t._useLegacyLights ? Math.PI : 1;
              (i.lightMapIntensity.value = r.lightMapIntensity * e),
                n(r.lightMap, i.lightMapTransform);
            }
            r.aoMap &&
              ((i.aoMap.value = r.aoMap),
              (i.aoMapIntensity.value = r.aoMapIntensity),
              n(r.aoMap, i.aoMapTransform));
          }
          return {
            refreshFogUniforms: function (e, n) {
              n.color.getRGB(e.fogColor.value, Jm(t)),
                n.isFog
                  ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
                  : n.isFogExp2 && (e.fogDensity.value = n.density);
            },
            refreshMaterialUniforms: function (t, r, s, o, a) {
              r.isMeshBasicMaterial || r.isMeshLambertMaterial
                ? i(t, r)
                : r.isMeshToonMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                  })(t, r))
                : r.isMeshPhongMaterial
                ? (i(t, r),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4));
                  })(t, r))
                : r.isMeshStandardMaterial
                ? (i(t, r),
                  (function (t, i) {
                    (t.metalness.value = i.metalness),
                      i.metalnessMap &&
                        ((t.metalnessMap.value = i.metalnessMap),
                        n(i.metalnessMap, t.metalnessMapTransform));
                    (t.roughness.value = i.roughness),
                      i.roughnessMap &&
                        ((t.roughnessMap.value = i.roughnessMap),
                        n(i.roughnessMap, t.roughnessMapTransform));
                    const r = e.get(i).envMap;
                    r && (t.envMapIntensity.value = i.envMapIntensity);
                  })(t, r),
                  r.isMeshPhysicalMaterial &&
                    (function (t, e, i) {
                      (t.ior.value = e.ior),
                        e.sheen > 0 &&
                          (t.sheenColor.value
                            .copy(e.sheenColor)
                            .multiplyScalar(e.sheen),
                          (t.sheenRoughness.value = e.sheenRoughness),
                          e.sheenColorMap &&
                            ((t.sheenColorMap.value = e.sheenColorMap),
                            n(e.sheenColorMap, t.sheenColorMapTransform)),
                          e.sheenRoughnessMap &&
                            ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                            n(
                              e.sheenRoughnessMap,
                              t.sheenRoughnessMapTransform
                            )));
                      e.clearcoat > 0 &&
                        ((t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.clearcoatMap &&
                          ((t.clearcoatMap.value = e.clearcoatMap),
                          n(e.clearcoatMap, t.clearcoatMapTransform)),
                        e.clearcoatRoughnessMap &&
                          ((t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap),
                          n(
                            e.clearcoatRoughnessMap,
                            t.clearcoatRoughnessMapTransform
                          )),
                        e.clearcoatNormalMap &&
                          ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          n(
                            e.clearcoatNormalMap,
                            t.clearcoatNormalMapTransform
                          ),
                          t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale
                          ),
                          e.side === Ah &&
                            t.clearcoatNormalScale.value.negate()));
                      e.iridescence > 0 &&
                        ((t.iridescence.value = e.iridescence),
                        (t.iridescenceIOR.value = e.iridescenceIOR),
                        (t.iridescenceThicknessMinimum.value =
                          e.iridescenceThicknessRange[0]),
                        (t.iridescenceThicknessMaximum.value =
                          e.iridescenceThicknessRange[1]),
                        e.iridescenceMap &&
                          ((t.iridescenceMap.value = e.iridescenceMap),
                          n(e.iridescenceMap, t.iridescenceMapTransform)),
                        e.iridescenceThicknessMap &&
                          ((t.iridescenceThicknessMap.value =
                            e.iridescenceThicknessMap),
                          n(
                            e.iridescenceThicknessMap,
                            t.iridescenceThicknessMapTransform
                          )));
                      e.transmission > 0 &&
                        ((t.transmission.value = e.transmission),
                        (t.transmissionSamplerMap.value = i.texture),
                        t.transmissionSamplerSize.value.set(i.width, i.height),
                        e.transmissionMap &&
                          ((t.transmissionMap.value = e.transmissionMap),
                          n(e.transmissionMap, t.transmissionMapTransform)),
                        (t.thickness.value = e.thickness),
                        e.thicknessMap &&
                          ((t.thicknessMap.value = e.thicknessMap),
                          n(e.thicknessMap, t.thicknessMapTransform)),
                        (t.attenuationDistance.value = e.attenuationDistance),
                        t.attenuationColor.value.copy(e.attenuationColor));
                      e.anisotropy > 0 &&
                        (t.anisotropyVector.value.set(
                          e.anisotropy * Math.cos(e.anisotropyRotation),
                          e.anisotropy * Math.sin(e.anisotropyRotation)
                        ),
                        e.anisotropyMap &&
                          ((t.anisotropyMap.value = e.anisotropyMap),
                          n(e.anisotropyMap, t.anisotropyMapTransform)));
                      (t.specularIntensity.value = e.specularIntensity),
                        t.specularColor.value.copy(e.specularColor),
                        e.specularColorMap &&
                          ((t.specularColorMap.value = e.specularColorMap),
                          n(e.specularColorMap, t.specularColorMapTransform));
                      e.specularIntensityMap &&
                        ((t.specularIntensityMap.value =
                          e.specularIntensityMap),
                        n(
                          e.specularIntensityMap,
                          t.specularIntensityMapTransform
                        ));
                    })(t, r, a))
                : r.isMeshMatcapMaterial
                ? (i(t, r),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                  })(t, r))
                : r.isMeshDepthMaterial
                ? i(t, r)
                : r.isMeshDistanceMaterial
                ? (i(t, r),
                  (function (t, n) {
                    const i = e.get(n).light;
                    t.referencePosition.value.setFromMatrixPosition(
                      i.matrixWorld
                    ),
                      (t.nearDistance.value = i.shadow.camera.near),
                      (t.farDistance.value = i.shadow.camera.far);
                  })(t, r))
                : r.isMeshNormalMaterial
                ? i(t, r)
                : r.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      e.map &&
                        ((t.map.value = e.map), n(e.map, t.mapTransform));
                  })(t, r),
                  r.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, r))
                : r.isPointsMaterial
                ? (function (t, e, i, r) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * i),
                      (t.scale.value = 0.5 * r),
                      e.map && ((t.map.value = e.map), n(e.map, t.uvTransform));
                    e.alphaMap &&
                      ((t.alphaMap.value = e.alphaMap),
                      n(e.alphaMap, t.alphaMapTransform));
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r, s, o)
                : r.isSpriteMaterial
                ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map &&
                        ((t.map.value = e.map), n(e.map, t.mapTransform));
                    e.alphaMap &&
                      ((t.alphaMap.value = e.alphaMap),
                      n(e.alphaMap, t.alphaMapTransform));
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                  })(t, r)
                : r.isShadowMaterial
                ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
                : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
            },
          };
        }
        function qy(t, e, n, i) {
          let r = {},
            s = {},
            o = [];
          const a = n.isWebGL2
            ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)
            : 0;
          function l(t, e, n) {
            const i = t.value;
            if (void 0 === n[e]) {
              if ("number" == typeof i) n[e] = i;
              else {
                const t = Array.isArray(i) ? i : [i],
                  r = [];
                for (let e = 0; e < t.length; e++) r.push(t[e].clone());
                n[e] = r;
              }
              return !0;
            }
            if ("number" == typeof i) {
              if (n[e] !== i) return (n[e] = i), !0;
            } else {
              const t = Array.isArray(n[e]) ? n[e] : [n[e]],
                r = Array.isArray(i) ? i : [i];
              for (let e = 0; e < t.length; e++) {
                const n = t[e];
                if (!1 === n.equals(r[e])) return n.copy(r[e]), !0;
              }
            }
            return !1;
          }
          function c(t) {
            const e = {
              boundary: 0,
              storage: 0,
            };
            return (
              "number" == typeof t
                ? ((e.boundary = 4), (e.storage = 4))
                : t.isVector2
                ? ((e.boundary = 8), (e.storage = 8))
                : t.isVector3 || t.isColor
                ? ((e.boundary = 16), (e.storage = 12))
                : t.isVector4
                ? ((e.boundary = 16), (e.storage = 16))
                : t.isMatrix3
                ? ((e.boundary = 48), (e.storage = 48))
                : t.isMatrix4
                ? ((e.boundary = 64), (e.storage = 64))
                : t.isTexture
                ? console.warn(
                    "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Unsupported uniform value type.",
                    t
                  ),
              e
            );
          }
          function u(e) {
            const n = e.target;
            n.removeEventListener("dispose", u);
            const i = o.indexOf(n.__bindingPointIndex);
            o.splice(i, 1),
              t.deleteBuffer(r[n.id]),
              delete r[n.id],
              delete s[n.id];
          }
          return {
            bind: function (t, e) {
              const n = e.program;
              i.uniformBlockBinding(t, n);
            },
            update: function (n, h) {
              let d = r[n.id];
              void 0 === d &&
                (!(function (t) {
                  const e = t.uniforms;
                  let n = 0;
                  const i = 16;
                  let r = 0;
                  for (let t = 0, s = e.length; t < s; t++) {
                    const s = e[t],
                      o = {
                        boundary: 0,
                        storage: 0,
                      },
                      a = Array.isArray(s.value) ? s.value : [s.value];
                    for (let t = 0, e = a.length; t < e; t++) {
                      const e = c(a[t]);
                      (o.boundary += e.boundary), (o.storage += e.storage);
                    }
                    if (
                      ((s.__data = new Float32Array(
                        o.storage / Float32Array.BYTES_PER_ELEMENT
                      )),
                      (s.__offset = n),
                      t > 0)
                    ) {
                      r = n % i;
                      0 !== r &&
                        i - r - o.boundary < 0 &&
                        ((n += i - r), (s.__offset = n));
                    }
                    n += o.storage;
                  }
                  (r = n % i), r > 0 && (n += i - r);
                  (t.__size = n), (t.__cache = {});
                })(n),
                (d = (function (e) {
                  const n = (function () {
                    for (let t = 0; t < a; t++)
                      if (-1 === o.indexOf(t)) return o.push(t), t;
                    return (
                      console.error(
                        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                      ),
                      0
                    );
                  })();
                  e.__bindingPointIndex = n;
                  const i = t.createBuffer(),
                    r = e.__size,
                    s = e.usage;
                  return (
                    t.bindBuffer(t.UNIFORM_BUFFER, i),
                    t.bufferData(t.UNIFORM_BUFFER, r, s),
                    t.bindBuffer(t.UNIFORM_BUFFER, null),
                    t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                    i
                  );
                })(n)),
                (r[n.id] = d),
                n.addEventListener("dispose", u));
              const p = h.program;
              i.updateUBOMapping(n, p);
              const f = e.render.frame;
              s[n.id] !== f &&
                (!(function (e) {
                  const n = r[e.id],
                    i = e.uniforms,
                    s = e.__cache;
                  t.bindBuffer(t.UNIFORM_BUFFER, n);
                  for (let e = 0, n = i.length; e < n; e++) {
                    const n = i[e];
                    if (!0 === l(n, e, s)) {
                      const e = n.__offset,
                        i = Array.isArray(n.value) ? n.value : [n.value];
                      let r = 0;
                      for (let s = 0; s < i.length; s++) {
                        const o = i[s],
                          a = c(o);
                        "number" == typeof o
                          ? ((n.__data[0] = o),
                            t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data))
                          : o.isMatrix3
                          ? ((n.__data[0] = o.elements[0]),
                            (n.__data[1] = o.elements[1]),
                            (n.__data[2] = o.elements[2]),
                            (n.__data[3] = o.elements[0]),
                            (n.__data[4] = o.elements[3]),
                            (n.__data[5] = o.elements[4]),
                            (n.__data[6] = o.elements[5]),
                            (n.__data[7] = o.elements[0]),
                            (n.__data[8] = o.elements[6]),
                            (n.__data[9] = o.elements[7]),
                            (n.__data[10] = o.elements[8]),
                            (n.__data[11] = o.elements[0]))
                          : (o.toArray(n.__data, r),
                            (r += a.storage / Float32Array.BYTES_PER_ELEMENT));
                      }
                      t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data);
                    }
                  }
                  t.bindBuffer(t.UNIFORM_BUFFER, null);
                })(n),
                (s[n.id] = f));
            },
            dispose: function () {
              for (const e in r) t.deleteBuffer(r[e]);
              (o = []), (r = {}), (s = {});
            },
          };
        }
        class Xy {
          constructor(t = {}) {
            const {
              canvas: e = yp(),
              context: n = null,
              depth: i = !0,
              stencil: r = !0,
              alpha: s = !1,
              antialias: o = !1,
              premultipliedAlpha: a = !0,
              preserveDrawingBuffer: l = !1,
              powerPreference: c = "default",
              failIfMajorPerformanceCaveat: u = !1,
            } = t;
            let h;
            (this.isWebGLRenderer = !0),
              (h = null !== n ? n.getContextAttributes().alpha : s);
            const d = new Uint32Array(4),
              p = new Int32Array(4);
            let f = null,
              m = null;
            const g = [],
              v = [];
            (this.domElement = e),
              (this.debug = {
                checkShaderErrors: !0,
                onShaderError: null,
              }),
              (this.autoClear = !0),
              (this.autoClearColor = !0),
              (this.autoClearDepth = !0),
              (this.autoClearStencil = !0),
              (this.sortObjects = !0),
              (this.clippingPlanes = []),
              (this.localClippingEnabled = !1),
              (this.outputColorSpace = Dd),
              (this._useLegacyLights = !1),
              (this.toneMapping = qh),
              (this.toneMappingExposure = 1);
            const y = this;
            let _ = !1,
              x = 0,
              b = 0,
              w = null,
              E = -1,
              S = null;
            const M = new Dp(),
              T = new Dp();
            let A = null;
            const R = new lm(0);
            let C = 0,
              L = e.width,
              P = e.height,
              O = 1,
              I = null,
              N = null;
            const D = new Dp(0, 0, L, P),
              U = new Dp(0, 0, L, P);
            let F = !1;
            const k = new pg();
            let B = !1,
              z = !1,
              H = null;
            const V = new yf(),
              G = new pp(),
              W = new Hp(),
              j = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0,
              };
            function q() {
              return null === w ? O : 1;
            }
            let X,
              Y,
              K,
              $,
              Z,
              J,
              Q,
              tt,
              et,
              nt,
              it,
              rt,
              st,
              ot,
              at,
              lt,
              ct,
              ut,
              ht,
              dt,
              pt,
              ft,
              mt,
              gt,
              vt = n;
            function yt(t, n) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i],
                  s = e.getContext(r, n);
                if (null !== s) return s;
              }
              return null;
            }
            try {
              const t = {
                alpha: !0,
                depth: i,
                stencil: r,
                antialias: o,
                premultipliedAlpha: a,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: u,
              };
              if (
                ("setAttribute" in e &&
                  e.setAttribute("data-engine", `three.js r${mh}`),
                e.addEventListener("webglcontextlost", bt, !1),
                e.addEventListener("webglcontextrestored", wt, !1),
                e.addEventListener("webglcontextcreationerror", Et, !1),
                null === vt)
              ) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if (
                  (!0 === y.isWebGL1Renderer && e.shift(),
                  (vt = yt(e, t)),
                  null === vt)
                )
                  throw yt(e)
                    ? new Error(
                        "Error creating WebGL context with your selected attributes."
                      )
                    : new Error("Error creating WebGL context.");
              }
              "undefined" != typeof WebGLRenderingContext &&
                vt instanceof WebGLRenderingContext &&
                console.warn(
                  "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
                ),
                void 0 === vt.getShaderPrecisionFormat &&
                  (vt.getShaderPrecisionFormat = function () {
                    return {
                      rangeMin: 1,
                      rangeMax: 1,
                      precision: 1,
                    };
                  });
            } catch (t) {
              throw (console.error("THREE.WebGLRenderer: " + t.message), t);
            }
            function _t() {
              (X = new Gg(vt)),
                (Y = new Sg(vt, X, t)),
                X.init(Y),
                (ft = new ky(vt, X, Y)),
                (K = new Uy(vt, X, Y)),
                ($ = new qg(vt)),
                (Z = new wy()),
                (J = new Fy(vt, X, K, Z, Y, ft, $)),
                (Q = new Tg(y)),
                (tt = new Vg(y)),
                (et = new mg(vt, Y)),
                (mt = new wg(vt, X, et, Y)),
                (nt = new Wg(vt, et, $, mt)),
                (it = new $g(vt, nt, et, $)),
                (ht = new Kg(vt, Y, J)),
                (lt = new Mg(Z)),
                (rt = new by(y, Q, tt, X, Y, mt, lt)),
                (st = new jy(y, Z)),
                (ot = new Ty()),
                (at = new Oy(X, Y)),
                (ut = new bg(y, Q, tt, K, it, h, a)),
                (ct = new Dy(y, it, Y)),
                (gt = new qy(vt, $, Y, K)),
                (dt = new Eg(vt, X, $, Y)),
                (pt = new jg(vt, X, $, Y)),
                ($.programs = rt.programs),
                (y.capabilities = Y),
                (y.extensions = X),
                (y.properties = Z),
                (y.renderLists = ot),
                (y.shadowMap = ct),
                (y.state = K),
                (y.info = $);
            }
            _t();
            const xt = new Wy(y, vt);
            function bt(t) {
              t.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                (_ = !0);
            }
            function wt() {
              console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
              const t = $.autoReset,
                e = ct.enabled,
                n = ct.autoUpdate,
                i = ct.needsUpdate,
                r = ct.type;
              _t(),
                ($.autoReset = t),
                (ct.enabled = e),
                (ct.autoUpdate = n),
                (ct.needsUpdate = i),
                (ct.type = r);
            }
            function Et(t) {
              console.error(
                "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
                t.statusMessage
              );
            }
            function St(t) {
              const e = t.target;
              e.removeEventListener("dispose", St),
                (function (t) {
                  (function (t) {
                    const e = Z.get(t).programs;
                    void 0 !== e &&
                      (e.forEach(function (t) {
                        rt.releaseProgram(t);
                      }),
                      t.isShaderMaterial && rt.releaseShaderCache(t));
                  })(t),
                    Z.remove(t);
                })(e);
            }
            (this.xr = xt),
              (this.getContext = function () {
                return vt;
              }),
              (this.getContextAttributes = function () {
                return vt.getContextAttributes();
              }),
              (this.forceContextLoss = function () {
                const t = X.get("WEBGL_lose_context");
                t && t.loseContext();
              }),
              (this.forceContextRestore = function () {
                const t = X.get("WEBGL_lose_context");
                t && t.restoreContext();
              }),
              (this.getPixelRatio = function () {
                return O;
              }),
              (this.setPixelRatio = function (t) {
                void 0 !== t && ((O = t), this.setSize(L, P, !1));
              }),
              (this.getSize = function (t) {
                return t.set(L, P);
              }),
              (this.setSize = function (t, n, i = !0) {
                xt.isPresenting
                  ? console.warn(
                      "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                    )
                  : ((L = t),
                    (P = n),
                    (e.width = Math.floor(t * O)),
                    (e.height = Math.floor(n * O)),
                    !0 === i &&
                      ((e.style.width = t + "px"), (e.style.height = n + "px")),
                    this.setViewport(0, 0, t, n));
              }),
              (this.getDrawingBufferSize = function (t) {
                return t.set(L * O, P * O).floor();
              }),
              (this.setDrawingBufferSize = function (t, n, i) {
                (L = t),
                  (P = n),
                  (O = i),
                  (e.width = Math.floor(t * i)),
                  (e.height = Math.floor(n * i)),
                  this.setViewport(0, 0, t, n);
              }),
              (this.getCurrentViewport = function (t) {
                return t.copy(M);
              }),
              (this.getViewport = function (t) {
                return t.copy(D);
              }),
              (this.setViewport = function (t, e, n, i) {
                t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i),
                  K.viewport(M.copy(D).multiplyScalar(O).floor());
              }),
              (this.getScissor = function (t) {
                return t.copy(U);
              }),
              (this.setScissor = function (t, e, n, i) {
                t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, n, i),
                  K.scissor(T.copy(U).multiplyScalar(O).floor());
              }),
              (this.getScissorTest = function () {
                return F;
              }),
              (this.setScissorTest = function (t) {
                K.setScissorTest((F = t));
              }),
              (this.setOpaqueSort = function (t) {
                I = t;
              }),
              (this.setTransparentSort = function (t) {
                N = t;
              }),
              (this.getClearColor = function (t) {
                return t.copy(ut.getClearColor());
              }),
              (this.setClearColor = function () {
                ut.setClearColor.apply(ut, arguments);
              }),
              (this.getClearAlpha = function () {
                return ut.getClearAlpha();
              }),
              (this.setClearAlpha = function () {
                ut.setClearAlpha.apply(ut, arguments);
              }),
              (this.clear = function (t = !0, e = !0, n = !0) {
                let i = 0;
                if (t) {
                  let t = !1;
                  if (null !== w) {
                    const e = w.texture.format;
                    t = 1033 === e || 1031 === e || 1029 === e;
                  }
                  if (t) {
                    const t = w.texture.type,
                      e =
                        t === dd ||
                        t === md ||
                        t === pd ||
                        t === yd ||
                        1017 === t ||
                        1018 === t,
                      n = ut.getClearColor(),
                      i = ut.getClearAlpha(),
                      r = n.r,
                      s = n.g,
                      o = n.b;
                    e
                      ? ((d[0] = r),
                        (d[1] = s),
                        (d[2] = o),
                        (d[3] = i),
                        vt.clearBufferuiv(vt.COLOR, 0, d))
                      : ((p[0] = r),
                        (p[1] = s),
                        (p[2] = o),
                        (p[3] = i),
                        vt.clearBufferiv(vt.COLOR, 0, p));
                  } else i |= vt.COLOR_BUFFER_BIT;
                }
                e && (i |= vt.DEPTH_BUFFER_BIT),
                  n && (i |= vt.STENCIL_BUFFER_BIT),
                  vt.clear(i);
              }),
              (this.clearColor = function () {
                this.clear(!0, !1, !1);
              }),
              (this.clearDepth = function () {
                this.clear(!1, !0, !1);
              }),
              (this.clearStencil = function () {
                this.clear(!1, !1, !0);
              }),
              (this.dispose = function () {
                e.removeEventListener("webglcontextlost", bt, !1),
                  e.removeEventListener("webglcontextrestored", wt, !1),
                  e.removeEventListener("webglcontextcreationerror", Et, !1),
                  ot.dispose(),
                  at.dispose(),
                  Z.dispose(),
                  Q.dispose(),
                  tt.dispose(),
                  it.dispose(),
                  mt.dispose(),
                  gt.dispose(),
                  rt.dispose(),
                  xt.dispose(),
                  xt.removeEventListener("sessionstart", Tt),
                  xt.removeEventListener("sessionend", At),
                  H && (H.dispose(), (H = null)),
                  Rt.stop();
              }),
              (this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = j);
                const o = r.isMesh && r.matrixWorld.determinant() < 0,
                  a = (function (t, e, n, i, r) {
                    !0 !== e.isScene && (e = j);
                    J.resetTextureUnits();
                    const s = e.fog,
                      o = i.isMeshStandardMaterial ? e.environment : null,
                      a =
                        null === w
                          ? y.outputColorSpace
                          : !0 === w.isXRRenderTarget
                          ? w.texture.colorSpace
                          : Ud,
                      l = (i.isMeshStandardMaterial ? tt : Q).get(
                        i.envMap || o
                      ),
                      c =
                        !0 === i.vertexColors &&
                        !!n.attributes.color &&
                        4 === n.attributes.color.itemSize,
                      u =
                        !!n.attributes.tangent &&
                        (!!i.normalMap || i.anisotropy > 0),
                      h = !!n.morphAttributes.position,
                      d = !!n.morphAttributes.normal,
                      p = !!n.morphAttributes.color;
                    let f = qh;
                    i.toneMapped &&
                      ((null !== w && !0 !== w.isXRRenderTarget) ||
                        (f = y.toneMapping));
                    const g =
                        n.morphAttributes.position ||
                        n.morphAttributes.normal ||
                        n.morphAttributes.color,
                      v = void 0 !== g ? g.length : 0,
                      _ = Z.get(i),
                      x = m.state.lights;
                    if (!0 === B && (!0 === z || t !== S)) {
                      const e = t === S && i.id === E;
                      lt.setState(i, t, e);
                    }
                    let b = !1;
                    i.version === _.__version
                      ? (_.needsLights &&
                          _.lightsStateVersion !== x.state.version) ||
                        _.outputColorSpace !== a ||
                        (r.isInstancedMesh && !1 === _.instancing)
                        ? (b = !0)
                        : r.isInstancedMesh || !0 !== _.instancing
                        ? r.isSkinnedMesh && !1 === _.skinning
                          ? (b = !0)
                          : r.isSkinnedMesh || !0 !== _.skinning
                          ? (r.isInstancedMesh &&
                              !0 === _.instancingColor &&
                              null === r.instanceColor) ||
                            (r.isInstancedMesh &&
                              !1 === _.instancingColor &&
                              null !== r.instanceColor) ||
                            _.envMap !== l ||
                            (!0 === i.fog && _.fog !== s)
                            ? (b = !0)
                            : void 0 === _.numClippingPlanes ||
                              (_.numClippingPlanes === lt.numPlanes &&
                                _.numIntersection === lt.numIntersection)
                            ? (_.vertexAlphas !== c ||
                                _.vertexTangents !== u ||
                                _.morphTargets !== h ||
                                _.morphNormals !== d ||
                                _.morphColors !== p ||
                                _.toneMapping !== f ||
                                (!0 === Y.isWebGL2 &&
                                  _.morphTargetsCount !== v)) &&
                              (b = !0)
                            : (b = !0)
                          : (b = !0)
                        : (b = !0)
                      : ((b = !0), (_.__version = i.version));
                    let M = _.currentProgram;
                    !0 === b && (M = It(i, e, r));
                    let T = !1,
                      A = !1,
                      R = !1;
                    const C = M.getUniforms(),
                      L = _.uniforms;
                    K.useProgram(M.program) && ((T = !0), (A = !0), (R = !0));
                    i.id !== E && ((E = i.id), (A = !0));
                    if (T || S !== t) {
                      C.setValue(vt, "projectionMatrix", t.projectionMatrix),
                        C.setValue(vt, "viewMatrix", t.matrixWorldInverse);
                      const e = C.map.cameraPosition;
                      void 0 !== e &&
                        e.setValue(vt, W.setFromMatrixPosition(t.matrixWorld)),
                        Y.logarithmicDepthBuffer &&
                          C.setValue(
                            vt,
                            "logDepthBufFC",
                            2 / (Math.log(t.far + 1) / Math.LN2)
                          ),
                        (i.isMeshPhongMaterial ||
                          i.isMeshToonMaterial ||
                          i.isMeshLambertMaterial ||
                          i.isMeshBasicMaterial ||
                          i.isMeshStandardMaterial ||
                          i.isShaderMaterial) &&
                          C.setValue(
                            vt,
                            "isOrthographic",
                            !0 === t.isOrthographicCamera
                          ),
                        S !== t && ((S = t), (A = !0), (R = !0));
                    }
                    if (r.isSkinnedMesh) {
                      C.setOptional(vt, r, "bindMatrix"),
                        C.setOptional(vt, r, "bindMatrixInverse");
                      const t = r.skeleton;
                      t &&
                        (Y.floatVertexTextures
                          ? (null === t.boneTexture && t.computeBoneTexture(),
                            C.setValue(vt, "boneTexture", t.boneTexture, J),
                            C.setValue(
                              vt,
                              "boneTextureSize",
                              t.boneTextureSize
                            ))
                          : console.warn(
                              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                            ));
                    }
                    const I = n.morphAttributes;
                    (void 0 !== I.position ||
                      void 0 !== I.normal ||
                      (void 0 !== I.color && !0 === Y.isWebGL2)) &&
                      ht.update(r, n, M);
                    (A || _.receiveShadow !== r.receiveShadow) &&
                      ((_.receiveShadow = r.receiveShadow),
                      C.setValue(vt, "receiveShadow", r.receiveShadow));
                    i.isMeshGouraudMaterial &&
                      null !== i.envMap &&
                      ((L.envMap.value = l),
                      (L.flipEnvMap.value =
                        l.isCubeTexture && !1 === l.isRenderTargetTexture
                          ? -1
                          : 1));
                    A &&
                      (C.setValue(
                        vt,
                        "toneMappingExposure",
                        y.toneMappingExposure
                      ),
                      _.needsLights &&
                        ((D = R),
                        ((N = L).ambientLightColor.needsUpdate = D),
                        (N.lightProbe.needsUpdate = D),
                        (N.directionalLights.needsUpdate = D),
                        (N.directionalLightShadows.needsUpdate = D),
                        (N.pointLights.needsUpdate = D),
                        (N.pointLightShadows.needsUpdate = D),
                        (N.spotLights.needsUpdate = D),
                        (N.spotLightShadows.needsUpdate = D),
                        (N.rectAreaLights.needsUpdate = D),
                        (N.hemisphereLights.needsUpdate = D)),
                      s && !0 === i.fog && st.refreshFogUniforms(L, s),
                      st.refreshMaterialUniforms(L, i, O, P, H),
                      ty.upload(vt, _.uniformsList, L, J));
                    var N, D;
                    i.isShaderMaterial &&
                      !0 === i.uniformsNeedUpdate &&
                      (ty.upload(vt, _.uniformsList, L, J),
                      (i.uniformsNeedUpdate = !1));
                    i.isSpriteMaterial && C.setValue(vt, "center", r.center);
                    if (
                      (C.setValue(vt, "modelViewMatrix", r.modelViewMatrix),
                      C.setValue(vt, "normalMatrix", r.normalMatrix),
                      C.setValue(vt, "modelMatrix", r.matrixWorld),
                      i.isShaderMaterial || i.isRawShaderMaterial)
                    ) {
                      const t = i.uniformsGroups;
                      for (let e = 0, n = t.length; e < n; e++)
                        if (Y.isWebGL2) {
                          const n = t[e];
                          gt.update(n, M), gt.bind(n, M);
                        } else
                          console.warn(
                            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                          );
                    }
                    return M;
                  })(t, e, n, i, r);
                K.setMaterial(i, o);
                let l = n.index,
                  c = 1;
                if (!0 === i.wireframe) {
                  if (((l = nt.getWireframeAttribute(n)), void 0 === l)) return;
                  c = 2;
                }
                const u = n.drawRange,
                  h = n.attributes.position;
                let d = u.start * c,
                  p = (u.start + u.count) * c;
                null !== s &&
                  ((d = Math.max(d, s.start * c)),
                  (p = Math.min(p, (s.start + s.count) * c))),
                  null !== l
                    ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
                    : null != h &&
                      ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
                const f = p - d;
                if (f < 0 || f === 1 / 0) return;
                let g;
                mt.setup(r, i, a, n, l);
                let v = dt;
                if (
                  (null !== l && ((g = et.get(l)), (v = pt), v.setIndex(g)),
                  r.isMesh)
                )
                  !0 === i.wireframe
                    ? (K.setLineWidth(i.wireframeLinewidth * q()),
                      v.setMode(vt.LINES))
                    : v.setMode(vt.TRIANGLES);
                else if (r.isLine) {
                  let t = i.linewidth;
                  void 0 === t && (t = 1),
                    K.setLineWidth(t * q()),
                    r.isLineSegments
                      ? v.setMode(vt.LINES)
                      : r.isLineLoop
                      ? v.setMode(vt.LINE_LOOP)
                      : v.setMode(vt.LINE_STRIP);
                } else
                  r.isPoints
                    ? v.setMode(vt.POINTS)
                    : r.isSprite && v.setMode(vt.TRIANGLES);
                if (r.isInstancedMesh) v.renderInstances(d, f, r.count);
                else if (n.isInstancedBufferGeometry) {
                  const t =
                      void 0 !== n._maxInstanceCount
                        ? n._maxInstanceCount
                        : 1 / 0,
                    e = Math.min(n.instanceCount, t);
                  v.renderInstances(d, f, e);
                } else v.render(d, f);
              }),
              (this.compile = function (t, e) {
                function n(t, e, n) {
                  !0 === t.transparent &&
                  2 === t.side &&
                  !1 === t.forceSinglePass
                    ? ((t.side = Ah),
                      (t.needsUpdate = !0),
                      It(t, e, n),
                      (t.side = Th),
                      (t.needsUpdate = !0),
                      It(t, e, n),
                      (t.side = 2))
                    : It(t, e, n);
                }
                (m = at.get(t)),
                  m.init(),
                  v.push(m),
                  t.traverseVisible(function (t) {
                    t.isLight &&
                      t.layers.test(e.layers) &&
                      (m.pushLight(t), t.castShadow && m.pushShadow(t));
                  }),
                  m.setupLights(y._useLegacyLights),
                  t.traverse(function (e) {
                    const i = e.material;
                    if (i)
                      if (Array.isArray(i))
                        for (let r = 0; r < i.length; r++) {
                          n(i[r], t, e);
                        }
                      else n(i, t, e);
                  }),
                  v.pop(),
                  (m = null);
              });
            let Mt = null;
            function Tt() {
              Rt.stop();
            }
            function At() {
              Rt.start();
            }
            const Rt = new fg();
            function Ct(t, e, n, i) {
              if (!1 === t.visible) return;
              if (t.layers.test(e.layers))
                if (t.isGroup) n = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight)
                  m.pushLight(t), t.castShadow && m.pushShadow(t);
                else if (t.isSprite) {
                  if (!t.frustumCulled || k.intersectsSprite(t)) {
                    i && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                    const e = it.update(t),
                      r = t.material;
                    r.visible && f.push(t, e, r, n, W.z, null);
                  }
                } else if (
                  (t.isMesh || t.isLine || t.isPoints) &&
                  (!t.frustumCulled || k.intersectsObject(t))
                ) {
                  const e = it.update(t),
                    r = t.material;
                  if (
                    (i &&
                      (void 0 !== t.boundingSphere
                        ? (null === t.boundingSphere &&
                            t.computeBoundingSphere(),
                          W.copy(t.boundingSphere.center))
                        : (null === e.boundingSphere &&
                            e.computeBoundingSphere(),
                          W.copy(e.boundingSphere.center)),
                      W.applyMatrix4(t.matrixWorld).applyMatrix4(V)),
                    Array.isArray(r))
                  ) {
                    const i = e.groups;
                    for (let s = 0, o = i.length; s < o; s++) {
                      const o = i[s],
                        a = r[o.materialIndex];
                      a && a.visible && f.push(t, e, a, n, W.z, o);
                    }
                  } else r.visible && f.push(t, e, r, n, W.z, null);
                }
              const r = t.children;
              for (let t = 0, s = r.length; t < s; t++) Ct(r[t], e, n, i);
            }
            function Lt(t, e, n, i) {
              const r = t.opaque,
                s = t.transmissive,
                o = t.transparent;
              m.setupLightsView(n),
                !0 === B && lt.setGlobalState(y.clippingPlanes, n),
                s.length > 0 &&
                  (function (t, e, n, i) {
                    const r = Y.isWebGL2;
                    null === H &&
                      (H = new Fp(1, 1, {
                        generateMipmaps: !0,
                        type: X.has("EXT_color_buffer_half_float") ? vd : dd,
                        minFilter: hd,
                        samples: r ? 4 : 0,
                      }));
                    y.getDrawingBufferSize(G),
                      r ? H.setSize(G.x, G.y) : H.setSize(cp(G.x), cp(G.y));
                    const s = y.getRenderTarget();
                    y.setRenderTarget(H),
                      y.getClearColor(R),
                      (C = y.getClearAlpha()),
                      C < 1 && y.setClearColor(16777215, 0.5);
                    y.clear();
                    const o = y.toneMapping;
                    (y.toneMapping = qh),
                      Pt(t, n, i),
                      J.updateMultisampleRenderTarget(H),
                      J.updateRenderTargetMipmap(H);
                    let a = !1;
                    for (let t = 0, r = e.length; t < r; t++) {
                      const r = e[t],
                        s = r.object,
                        o = r.geometry,
                        l = r.material,
                        c = r.group;
                      if (2 === l.side && s.layers.test(i.layers)) {
                        const t = l.side;
                        (l.side = Ah),
                          (l.needsUpdate = !0),
                          Ot(s, n, i, o, l, c),
                          (l.side = t),
                          (l.needsUpdate = !0),
                          (a = !0);
                      }
                    }
                    !0 === a &&
                      (J.updateMultisampleRenderTarget(H),
                      J.updateRenderTargetMipmap(H));
                    y.setRenderTarget(s),
                      y.setClearColor(R, C),
                      (y.toneMapping = o);
                  })(r, s, e, n),
                i && K.viewport(M.copy(i)),
                r.length > 0 && Pt(r, e, n),
                s.length > 0 && Pt(s, e, n),
                o.length > 0 && Pt(o, e, n),
                K.buffers.depth.setTest(!0),
                K.buffers.depth.setMask(!0),
                K.buffers.color.setMask(!0),
                K.setPolygonOffset(!1);
            }
            function Pt(t, e, n) {
              const i = !0 === e.isScene ? e.overrideMaterial : null;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  o = s.object,
                  a = s.geometry,
                  l = null === i ? s.material : i,
                  c = s.group;
                o.layers.test(n.layers) && Ot(o, e, n, a, l, c);
              }
            }
            function Ot(t, e, n, i, r, s) {
              t.onBeforeRender(y, e, n, i, r, s),
                t.modelViewMatrix.multiplyMatrices(
                  n.matrixWorldInverse,
                  t.matrixWorld
                ),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                r.onBeforeRender(y, e, n, i, t, s),
                !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
                  ? ((r.side = Ah),
                    (r.needsUpdate = !0),
                    y.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = Th),
                    (r.needsUpdate = !0),
                    y.renderBufferDirect(n, e, i, r, t, s),
                    (r.side = 2))
                  : y.renderBufferDirect(n, e, i, r, t, s),
                t.onAfterRender(y, e, n, i, r, s);
            }
            function It(t, e, n) {
              !0 !== e.isScene && (e = j);
              const i = Z.get(t),
                r = m.state.lights,
                s = m.state.shadowsArray,
                o = r.state.version,
                a = rt.getParameters(t, r.state, s, e, n),
                l = rt.getProgramCacheKey(a);
              let c = i.programs;
              (i.environment = t.isMeshStandardMaterial ? e.environment : null),
                (i.fog = e.fog),
                (i.envMap = (t.isMeshStandardMaterial ? tt : Q).get(
                  t.envMap || i.environment
                )),
                void 0 === c &&
                  (t.addEventListener("dispose", St),
                  (c = new Map()),
                  (i.programs = c));
              let u = c.get(l);
              if (void 0 !== u) {
                if (i.currentProgram === u && i.lightsStateVersion === o)
                  return Nt(t, a), u;
              } else
                (a.uniforms = rt.getUniforms(t)),
                  t.onBuild(n, a, y),
                  t.onBeforeCompile(a, y),
                  (u = rt.acquireProgram(a, l)),
                  c.set(l, u),
                  (i.uniforms = a.uniforms);
              const h = i.uniforms;
              ((t.isShaderMaterial || t.isRawShaderMaterial) &&
                !0 !== t.clipping) ||
                (h.clippingPlanes = lt.uniform),
                Nt(t, a),
                (i.needsLights = (function (t) {
                  return (
                    t.isMeshLambertMaterial ||
                    t.isMeshToonMaterial ||
                    t.isMeshPhongMaterial ||
                    t.isMeshStandardMaterial ||
                    t.isShadowMaterial ||
                    (t.isShaderMaterial && !0 === t.lights)
                  );
                })(t)),
                (i.lightsStateVersion = o),
                i.needsLights &&
                  ((h.ambientLightColor.value = r.state.ambient),
                  (h.lightProbe.value = r.state.probe),
                  (h.directionalLights.value = r.state.directional),
                  (h.directionalLightShadows.value = r.state.directionalShadow),
                  (h.spotLights.value = r.state.spot),
                  (h.spotLightShadows.value = r.state.spotShadow),
                  (h.rectAreaLights.value = r.state.rectArea),
                  (h.ltc_1.value = r.state.rectAreaLTC1),
                  (h.ltc_2.value = r.state.rectAreaLTC2),
                  (h.pointLights.value = r.state.point),
                  (h.pointLightShadows.value = r.state.pointShadow),
                  (h.hemisphereLights.value = r.state.hemi),
                  (h.directionalShadowMap.value = r.state.directionalShadowMap),
                  (h.directionalShadowMatrix.value =
                    r.state.directionalShadowMatrix),
                  (h.spotShadowMap.value = r.state.spotShadowMap),
                  (h.spotLightMatrix.value = r.state.spotLightMatrix),
                  (h.spotLightMap.value = r.state.spotLightMap),
                  (h.pointShadowMap.value = r.state.pointShadowMap),
                  (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
              const d = u.getUniforms(),
                p = ty.seqWithValue(d.seq, h);
              return (i.currentProgram = u), (i.uniformsList = p), u;
            }
            function Nt(t, e) {
              const n = Z.get(t);
              (n.outputColorSpace = e.outputColorSpace),
                (n.instancing = e.instancing),
                (n.instancingColor = e.instancingColor),
                (n.skinning = e.skinning),
                (n.morphTargets = e.morphTargets),
                (n.morphNormals = e.morphNormals),
                (n.morphColors = e.morphColors),
                (n.morphTargetsCount = e.morphTargetsCount),
                (n.numClippingPlanes = e.numClippingPlanes),
                (n.numIntersection = e.numClipIntersection),
                (n.vertexAlphas = e.vertexAlphas),
                (n.vertexTangents = e.vertexTangents),
                (n.toneMapping = e.toneMapping);
            }
            Rt.setAnimationLoop(function (t) {
              Mt && Mt(t);
            }),
              "undefined" != typeof self && Rt.setContext(self),
              (this.setAnimationLoop = function (t) {
                (Mt = t),
                  xt.setAnimationLoop(t),
                  null === t ? Rt.stop() : Rt.start();
              }),
              xt.addEventListener("sessionstart", Tt),
              xt.addEventListener("sessionend", At),
              (this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera)
                  return void console.error(
                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                  );
                if (!0 === _) return;
                !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                  null === e.parent &&
                    !0 === e.matrixWorldAutoUpdate &&
                    e.updateMatrixWorld(),
                  !0 === xt.enabled &&
                    !0 === xt.isPresenting &&
                    (!0 === xt.cameraAutoUpdate && xt.updateCamera(e),
                    (e = xt.getCamera())),
                  !0 === t.isScene && t.onBeforeRender(y, t, e, w),
                  (m = at.get(t, v.length)),
                  m.init(),
                  v.push(m),
                  V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                  k.setFromProjectionMatrix(V),
                  (z = this.localClippingEnabled),
                  (B = lt.init(this.clippingPlanes, z)),
                  (f = ot.get(t, g.length)),
                  f.init(),
                  g.push(f),
                  Ct(t, e, 0, y.sortObjects),
                  f.finish(),
                  !0 === y.sortObjects && f.sort(I, N),
                  this.info.render.frame++,
                  !0 === B && lt.beginShadows();
                const n = m.state.shadowsArray;
                if (
                  (ct.render(n, t, e),
                  !0 === B && lt.endShadows(),
                  !0 === this.info.autoReset && this.info.reset(),
                  ut.render(f, t),
                  m.setupLights(y._useLegacyLights),
                  e.isArrayCamera)
                ) {
                  const n = e.cameras;
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    Lt(f, t, i, i.viewport);
                  }
                } else Lt(f, t, e);
                null !== w &&
                  (J.updateMultisampleRenderTarget(w),
                  J.updateRenderTargetMipmap(w)),
                  !0 === t.isScene && t.onAfterRender(y, t, e),
                  mt.resetDefaultState(),
                  (E = -1),
                  (S = null),
                  v.pop(),
                  (m = v.length > 0 ? v[v.length - 1] : null),
                  g.pop(),
                  (f = g.length > 0 ? g[g.length - 1] : null);
              }),
              (this.getActiveCubeFace = function () {
                return x;
              }),
              (this.getActiveMipmapLevel = function () {
                return b;
              }),
              (this.getRenderTarget = function () {
                return w;
              }),
              (this.setRenderTargetTextures = function (t, e, n) {
                (Z.get(t.texture).__webglTexture = e),
                  (Z.get(t.depthTexture).__webglTexture = n);
                const i = Z.get(t);
                (i.__hasExternalTextures = !0),
                  i.__hasExternalTextures &&
                    ((i.__autoAllocateDepthBuffer = void 0 === n),
                    i.__autoAllocateDepthBuffer ||
                      (!0 === X.has("WEBGL_multisampled_render_to_texture") &&
                        (console.warn(
                          "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                        ),
                        (i.__useRenderToTexture = !1))));
              }),
              (this.setRenderTargetFramebuffer = function (t, e) {
                const n = Z.get(t);
                (n.__webglFramebuffer = e),
                  (n.__useDefaultFramebuffer = void 0 === e);
              }),
              (this.setRenderTarget = function (t, e = 0, n = 0) {
                (w = t), (x = e), (b = n);
                let i = !0,
                  r = null,
                  s = !1,
                  o = !1;
                if (t) {
                  const a = Z.get(t);
                  void 0 !== a.__useDefaultFramebuffer
                    ? (K.bindFramebuffer(vt.FRAMEBUFFER, null), (i = !1))
                    : void 0 === a.__webglFramebuffer
                    ? J.setupRenderTarget(t)
                    : a.__hasExternalTextures &&
                      J.rebindTextures(
                        t,
                        Z.get(t.texture).__webglTexture,
                        Z.get(t.depthTexture).__webglTexture
                      );
                  const l = t.texture;
                  (l.isData3DTexture ||
                    l.isDataArrayTexture ||
                    l.isCompressedArrayTexture) &&
                    (o = !0);
                  const c = Z.get(t).__webglFramebuffer;
                  t.isWebGLCubeRenderTarget
                    ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
                    : (r =
                        Y.isWebGL2 &&
                        t.samples > 0 &&
                        !1 === J.useMultisampledRTT(t)
                          ? Z.get(t).__webglMultisampledFramebuffer
                          : Array.isArray(c)
                          ? c[n]
                          : c),
                    M.copy(t.viewport),
                    T.copy(t.scissor),
                    (A = t.scissorTest);
                } else
                  M.copy(D).multiplyScalar(O).floor(),
                    T.copy(U).multiplyScalar(O).floor(),
                    (A = F);
                if (
                  (K.bindFramebuffer(vt.FRAMEBUFFER, r) &&
                    Y.drawBuffers &&
                    i &&
                    K.drawBuffers(t, r),
                  K.viewport(M),
                  K.scissor(T),
                  K.setScissorTest(A),
                  s)
                ) {
                  const i = Z.get(t.texture);
                  vt.framebufferTexture2D(
                    vt.FRAMEBUFFER,
                    vt.COLOR_ATTACHMENT0,
                    vt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                    i.__webglTexture,
                    n
                  );
                } else if (o) {
                  const i = Z.get(t.texture),
                    r = e || 0;
                  vt.framebufferTextureLayer(
                    vt.FRAMEBUFFER,
                    vt.COLOR_ATTACHMENT0,
                    i.__webglTexture,
                    n || 0,
                    r
                  );
                }
                E = -1;
              }),
              (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
                if (!t || !t.isWebGLRenderTarget)
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                  );
                let a = Z.get(t).__webglFramebuffer;
                if (
                  (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)
                ) {
                  K.bindFramebuffer(vt.FRAMEBUFFER, a);
                  try {
                    const o = t.texture,
                      a = o.format,
                      l = o.type;
                    if (
                      a !== _d &&
                      ft.convert(a) !==
                        vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_FORMAT)
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                      );
                    const c =
                      l === vd &&
                      (X.has("EXT_color_buffer_half_float") ||
                        (Y.isWebGL2 && X.has("EXT_color_buffer_float")));
                    if (
                      !(
                        l === dd ||
                        ft.convert(l) ===
                          vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                        (l === gd &&
                          (Y.isWebGL2 ||
                            X.has("OES_texture_float") ||
                            X.has("WEBGL_color_buffer_float"))) ||
                        c
                      )
                    )
                      return void console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                      );
                    e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      vt.readPixels(
                        e,
                        n,
                        i,
                        r,
                        ft.convert(a),
                        ft.convert(l),
                        s
                      );
                  } finally {
                    const t = null !== w ? Z.get(w).__webglFramebuffer : null;
                    K.bindFramebuffer(vt.FRAMEBUFFER, t);
                  }
                }
              }),
              (this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                  r = Math.floor(e.image.width * i),
                  s = Math.floor(e.image.height * i);
                J.setTexture2D(e, 0),
                  vt.copyTexSubImage2D(vt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
                  K.unbindTexture();
              }),
              (this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                  s = e.image.height,
                  o = ft.convert(n.format),
                  a = ft.convert(n.type);
                J.setTexture2D(n, 0),
                  vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, n.flipY),
                  vt.pixelStorei(
                    vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    n.premultiplyAlpha
                  ),
                  vt.pixelStorei(vt.UNPACK_ALIGNMENT, n.unpackAlignment),
                  e.isDataTexture
                    ? vt.texSubImage2D(
                        vt.TEXTURE_2D,
                        i,
                        t.x,
                        t.y,
                        r,
                        s,
                        o,
                        a,
                        e.image.data
                      )
                    : e.isCompressedTexture
                    ? vt.compressedTexSubImage2D(
                        vt.TEXTURE_2D,
                        i,
                        t.x,
                        t.y,
                        e.mipmaps[0].width,
                        e.mipmaps[0].height,
                        o,
                        e.mipmaps[0].data
                      )
                    : vt.texSubImage2D(
                        vt.TEXTURE_2D,
                        i,
                        t.x,
                        t.y,
                        o,
                        a,
                        e.image
                      ),
                  0 === i &&
                    n.generateMipmaps &&
                    vt.generateMipmap(vt.TEXTURE_2D),
                  K.unbindTexture();
              }),
              (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (y.isWebGL1Renderer)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                  );
                const s = t.max.x - t.min.x + 1,
                  o = t.max.y - t.min.y + 1,
                  a = t.max.z - t.min.z + 1,
                  l = ft.convert(i.format),
                  c = ft.convert(i.type);
                let u;
                if (i.isData3DTexture)
                  J.setTexture3D(i, 0), (u = vt.TEXTURE_3D);
                else {
                  if (!i.isDataArrayTexture)
                    return void console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                    );
                  J.setTexture2DArray(i, 0), (u = vt.TEXTURE_2D_ARRAY);
                }
                vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, i.flipY),
                  vt.pixelStorei(
                    vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    i.premultiplyAlpha
                  ),
                  vt.pixelStorei(vt.UNPACK_ALIGNMENT, i.unpackAlignment);
                const h = vt.getParameter(vt.UNPACK_ROW_LENGTH),
                  d = vt.getParameter(vt.UNPACK_IMAGE_HEIGHT),
                  p = vt.getParameter(vt.UNPACK_SKIP_PIXELS),
                  f = vt.getParameter(vt.UNPACK_SKIP_ROWS),
                  m = vt.getParameter(vt.UNPACK_SKIP_IMAGES),
                  g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                vt.pixelStorei(vt.UNPACK_ROW_LENGTH, g.width),
                  vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, g.height),
                  vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, t.min.x),
                  vt.pixelStorei(vt.UNPACK_SKIP_ROWS, t.min.y),
                  vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, t.min.z),
                  n.isDataTexture || n.isData3DTexture
                    ? vt.texSubImage3D(
                        u,
                        r,
                        e.x,
                        e.y,
                        e.z,
                        s,
                        o,
                        a,
                        l,
                        c,
                        g.data
                      )
                    : n.isCompressedArrayTexture
                    ? (console.warn(
                        "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                      ),
                      vt.compressedTexSubImage3D(
                        u,
                        r,
                        e.x,
                        e.y,
                        e.z,
                        s,
                        o,
                        a,
                        l,
                        g.data
                      ))
                    : vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g),
                  vt.pixelStorei(vt.UNPACK_ROW_LENGTH, h),
                  vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, d),
                  vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, p),
                  vt.pixelStorei(vt.UNPACK_SKIP_ROWS, f),
                  vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, m),
                  0 === r && i.generateMipmaps && vt.generateMipmap(u),
                  K.unbindTexture();
              }),
              (this.initTexture = function (t) {
                t.isCubeTexture
                  ? J.setTextureCube(t, 0)
                  : t.isData3DTexture
                  ? J.setTexture3D(t, 0)
                  : t.isDataArrayTexture || t.isCompressedArrayTexture
                  ? J.setTexture2DArray(t, 0)
                  : J.setTexture2D(t, 0),
                  K.unbindTexture();
              }),
              (this.resetState = function () {
                (x = 0), (b = 0), (w = null), K.reset(), mt.reset();
              }),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", {
                    detail: this,
                  })
                );
          }
          get coordinateSystem() {
            return $d;
          }
          get physicallyCorrectLights() {
            return (
              console.warn(
                "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
              ),
              !this.useLegacyLights
            );
          }
          set physicallyCorrectLights(t) {
            console.warn(
              "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
            ),
              (this.useLegacyLights = !t);
          }
          get outputEncoding() {
            return (
              console.warn(
                "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
              ),
              this.outputColorSpace === Dd ? Id : 3e3
            );
          }
          set outputEncoding(t) {
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
            ),
              (this.outputColorSpace = t === Id ? Dd : Ud);
          }
          get useLegacyLights() {
            return (
              console.warn(
                "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
              ),
              this._useLegacyLights
            );
          }
          set useLegacyLights(t) {
            console.warn(
              "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
            ),
              (this._useLegacyLights = t);
          }
        }
        (class extends Xy {}).prototype.isWebGL1Renderer = !0;
        class Yy extends Gf {
          constructor() {
            super(),
              (this.isScene = !0),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.backgroundBlurriness = 0),
              (this.backgroundIntensity = 1),
              (this.overrideMaterial = null),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", {
                    detail: this,
                  })
                );
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment &&
                (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              (this.backgroundBlurriness = t.backgroundBlurriness),
              (this.backgroundIntensity = t.backgroundIntensity),
              null !== t.overrideMaterial &&
                (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              this.backgroundBlurriness > 0 &&
                (e.object.backgroundBlurriness = this.backgroundBlurriness),
              1 !== this.backgroundIntensity &&
                (e.object.backgroundIntensity = this.backgroundIntensity),
              e
            );
          }
        }
        class Ky {
          constructor(t, e) {
            (this.isInterleavedBuffer = !0),
              (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = Xd),
              (this.updateRange = {
                offset: 0,
                count: -1,
              }),
              (this.version = 0),
              (this.uuid = ip());
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let i = 0, r = this.stride; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ip()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            const e = new this.array.constructor(
                t.arrayBuffers[this.array.buffer._uuid]
              ),
              n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ip()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        const $y = new Hp();
        class Zy {
          constructor(t, e, n, i = !1) {
            (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = i);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              $y.fromBufferAttribute(this, e),
                $y.applyMatrix4(t),
                this.setXYZ(e, $y.x, $y.y, $y.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              $y.fromBufferAttribute(this, e),
                $y.applyNormalMatrix(t),
                this.setXYZ(e, $y.x, $y.y, $y.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              $y.fromBufferAttribute(this, e),
                $y.transformDirection(t),
                this.setXYZ(e, $y.x, $y.y, $y.z);
            return this;
          }
          setX(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset] = e),
              this
            );
          }
          setY(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              this.normalized && (e = hp(e, this.array)),
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            let e = this.data.array[t * this.data.stride + this.offset];
            return this.normalized && (e = up(e, this.array)), e;
          }
          getY(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 1];
            return this.normalized && (e = up(e, this.array)), e;
          }
          getZ(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 2];
            return this.normalized && (e = up(e, this.array)), e;
          }
          getW(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 3];
            return this.normalized && (e = up(e, this.array)), e;
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = hp(e, this.array)), (n = hp(n, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = hp(e, this.array)),
                (n = hp(n, this.array)),
                (i = hp(i, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t = t * this.data.stride + this.offset),
              this.normalized &&
                ((e = hp(e, this.array)),
                (n = hp(n, this.array)),
                (i = hp(i, this.array)),
                (r = hp(r, this.array))),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              (this.data.array[t + 3] = r),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return new ym(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new Zy(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        const Jy = new Hp(),
          Qy = new Dp(),
          t_ = new Dp(),
          e_ = new Hp(),
          n_ = new yf(),
          i_ = new Hp(),
          r_ = new cf(),
          s_ = new yf(),
          o_ = new vf();
        class a_ extends Xm {
          constructor(t, e) {
            super(t, e),
              (this.isSkinnedMesh = !0),
              (this.type = "SkinnedMesh"),
              (this.bindMode = "attached"),
              (this.bindMatrix = new yf()),
              (this.bindMatrixInverse = new yf()),
              (this.boundingBox = null),
              (this.boundingSphere = null);
          }
          computeBoundingBox() {
            const t = this.geometry;
            null === this.boundingBox && (this.boundingBox = new Wp()),
              this.boundingBox.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              i_.fromBufferAttribute(e, t),
                this.applyBoneTransform(t, i_),
                this.boundingBox.expandByPoint(i_);
          }
          computeBoundingSphere() {
            const t = this.geometry;
            null === this.boundingSphere && (this.boundingSphere = new cf()),
              this.boundingSphere.makeEmpty();
            const e = t.getAttribute("position");
            for (let t = 0; t < e.count; t++)
              i_.fromBufferAttribute(e, t),
                this.applyBoneTransform(t, i_),
                this.boundingSphere.expandByPoint(i_);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              null !== t.boundingBox &&
                (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere &&
                (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          raycast(t, e) {
            const n = this.material,
              i = this.matrixWorld;
            void 0 !== n &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              r_.copy(this.boundingSphere),
              r_.applyMatrix4(i),
              !1 !== t.ray.intersectsSphere(r_) &&
                (s_.copy(i).invert(),
                o_.copy(t.ray).applyMatrix4(s_),
                (null !== this.boundingBox &&
                  !1 === o_.intersectsBox(this.boundingBox)) ||
                  this._computeIntersections(t, e, o_)));
          }
          getVertexPosition(t, e) {
            return (
              super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
            );
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new Dp(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
              t.fromBufferAttribute(e, n);
              const i = 1 / t.manhattanLength();
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          }
          applyBoneTransform(t, e) {
            const n = this.skeleton,
              i = this.geometry;
            Qy.fromBufferAttribute(i.attributes.skinIndex, t),
              t_.fromBufferAttribute(i.attributes.skinWeight, t),
              Jy.copy(e).applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const i = t_.getComponent(t);
              if (0 !== i) {
                const r = Qy.getComponent(t);
                n_.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(e_.copy(Jy).applyMatrix4(n_), i);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
          boneTransform(t, e) {
            return (
              console.warn(
                "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
              ),
              this.applyBoneTransform(t, e)
            );
          }
        }
        class l_ extends Gf {
          constructor() {
            super(), (this.isBone = !0), (this.type = "Bone");
          }
        }
        class c_ extends Np {
          constructor(
            t = null,
            e = 1,
            n = 1,
            i,
            r,
            s,
            o,
            a,
            l = 1003,
            c = 1003,
            u,
            h
          ) {
            super(null, s, o, a, l, c, i, r, u, h),
              (this.isDataTexture = !0),
              (this.image = {
                data: t,
                width: e,
                height: n,
              }),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        }
        const u_ = new yf(),
          h_ = new yf();
        class d_ {
          constructor(t = [], e = []) {
            (this.uuid = ip()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * t.length)),
              0 === e.length)
            )
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++)
                this.boneInverses.push(new yf());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new yf();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : h_;
              u_.multiplyMatrices(r, e[i]), u_.toArray(n, 16 * i);
            }
            null !== i && (i.needsUpdate = !0);
          }
          clone() {
            return new d_(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            (t = lp(t)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new c_(e, t, t, _d, gd);
            return (
              (n.needsUpdate = !0),
              (this.boneMatrices = e),
              (this.boneTexture = n),
              (this.boneTextureSize = t),
              this
            );
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n];
              let r = e[i];
              void 0 === r &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                (r = new l_())),
                this.bones.push(r),
                this.boneInverses.push(new yf().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON",
              },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              t.bones.push(r.uuid);
              const s = n[i];
              t.boneInverses.push(s.toArray());
            }
            return t;
          }
        }
        class p_ extends ym {
          constructor(t, e, n, i = 1) {
            super(t, e, n),
              (this.isInstancedBufferAttribute = !0),
              (this.meshPerAttribute = i);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute),
              (t.isInstancedBufferAttribute = !0),
              t
            );
          }
        }
        const f_ = new yf(),
          m_ = new yf(),
          g_ = [],
          v_ = new Wp(),
          y_ = new yf(),
          __ = new Xm(),
          x_ = new cf();
        class b_ extends Xm {
          constructor(t, e, n) {
            super(t, e),
              (this.isInstancedMesh = !0),
              (this.instanceMatrix = new p_(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            for (let t = 0; t < n; t++) this.setMatrixAt(t, y_);
          }
          computeBoundingBox() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingBox && (this.boundingBox = new Wp()),
              null === t.boundingBox && t.computeBoundingBox(),
              this.boundingBox.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, f_),
                v_.copy(t.boundingBox).applyMatrix4(f_),
                this.boundingBox.union(v_);
          }
          computeBoundingSphere() {
            const t = this.geometry,
              e = this.count;
            null === this.boundingSphere && (this.boundingSphere = new cf()),
              null === t.boundingSphere && t.computeBoundingSphere(),
              this.boundingSphere.makeEmpty();
            for (let n = 0; n < e; n++)
              this.getMatrixAt(n, f_),
                x_.copy(t.boundingSphere).applyMatrix4(f_),
                this.boundingSphere.union(x_);
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor &&
                (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              null !== t.boundingBox &&
                (this.boundingBox = t.boundingBox.clone()),
              null !== t.boundingSphere &&
                (this.boundingSphere = t.boundingSphere.clone()),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              i = this.count;
            if (
              ((__.geometry = this.geometry),
              (__.material = this.material),
              void 0 !== __.material &&
                (null === this.boundingSphere && this.computeBoundingSphere(),
                x_.copy(this.boundingSphere),
                x_.applyMatrix4(n),
                !1 !== t.ray.intersectsSphere(x_)))
            )
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, f_),
                  m_.multiplyMatrices(n, f_),
                  (__.matrixWorld = m_),
                  __.raycast(t, g_);
                for (let t = 0, n = g_.length; t < n; t++) {
                  const n = g_[t];
                  (n.instanceId = r), (n.object = this), e.push(n);
                }
                g_.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new p_(
                new Float32Array(3 * this.instanceMatrix.count),
                3
              )),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({
              type: "dispose",
            });
          }
        }
        class w_ extends im {
          constructor(t) {
            super(),
              (this.isLineBasicMaterial = !0),
              (this.type = "LineBasicMaterial"),
              (this.color = new lm(16777215)),
              (this.map = null),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.fog = t.fog),
              this
            );
          }
        }
        const E_ = new Hp(),
          S_ = new Hp(),
          M_ = new yf(),
          T_ = new vf(),
          A_ = new cf();
        class R_ extends Gf {
          constructor(t = new Cm(), e = new w_()) {
            super(),
              (this.isLine = !0),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material)
                ? t.material.slice()
                : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0];
              for (let t = 1, i = e.count; t < i; t++)
                E_.fromBufferAttribute(e, t - 1),
                  S_.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += E_.distanceTo(S_));
              t.setAttribute("lineDistance", new bm(n, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              A_.copy(n.boundingSphere),
              A_.applyMatrix4(i),
              (A_.radius += r),
              !1 === t.ray.intersectsSphere(A_))
            )
              return;
            M_.copy(i).invert(), T_.copy(t.ray).applyMatrix4(M_);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = new Hp(),
              c = new Hp(),
              u = new Hp(),
              h = new Hp(),
              d = this.isLineSegments ? 2 : 1,
              p = n.index,
              f = n.attributes.position;
            if (null !== p) {
              for (
                let n = Math.max(0, s.start),
                  i = Math.min(p.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                const i = p.getX(n),
                  r = p.getX(n + 1);
                l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r);
                if (T_.distanceSqToSegment(l, c, h, u) > a) continue;
                h.applyMatrix4(this.matrixWorld);
                const s = t.ray.origin.distanceTo(h);
                s < t.near ||
                  s > t.far ||
                  e.push({
                    distance: s,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              for (
                let n = Math.max(0, s.start),
                  i = Math.min(f.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1);
                if (T_.distanceSqToSegment(l, c, h, u) > a) continue;
                h.applyMatrix4(this.matrixWorld);
                const i = t.ray.origin.distanceTo(h);
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        const C_ = new Hp(),
          L_ = new Hp();
        class P_ extends R_ {
          constructor(t, e) {
            super(t, e),
              (this.isLineSegments = !0),
              (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
              const e = t.attributes.position,
                n = [];
              for (let t = 0, i = e.count; t < i; t += 2)
                C_.fromBufferAttribute(e, t),
                  L_.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + C_.distanceTo(L_));
              t.setAttribute("lineDistance", new bm(n, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
        }
        class O_ extends R_ {
          constructor(t, e) {
            super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
          }
        }
        class I_ extends im {
          constructor(t) {
            super(),
              (this.isPointsMaterial = !0),
              (this.type = "PointsMaterial"),
              (this.color = new lm(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.fog = t.fog),
              this
            );
          }
        }
        const N_ = new yf(),
          D_ = new vf(),
          U_ = new cf(),
          F_ = new Hp();
        class k_ extends Gf {
          constructor(t = new Cm(), e = new I_()) {
            super(),
              (this.isPoints = !0),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.material = Array.isArray(t.material)
                ? t.material.slice()
                : t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              U_.copy(n.boundingSphere),
              U_.applyMatrix4(i),
              (U_.radius += r),
              !1 === t.ray.intersectsSphere(U_))
            )
              return;
            N_.copy(i).invert(), D_.copy(t.ray).applyMatrix4(N_);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = n.index,
              c = n.attributes.position;
            if (null !== l) {
              for (
                let n = Math.max(0, s.start),
                  r = Math.min(l.count, s.start + s.count);
                n < r;
                n++
              ) {
                const r = l.getX(n);
                F_.fromBufferAttribute(c, r), B_(F_, r, a, i, t, e, this);
              }
            } else {
              for (
                let n = Math.max(0, s.start),
                  r = Math.min(c.count, s.start + s.count);
                n < r;
                n++
              )
                F_.fromBufferAttribute(c, n), B_(F_, n, a, i, t, e, this);
            }
          }
          updateMorphTargets() {
            const t = this.geometry.morphAttributes,
              e = Object.keys(t);
            if (e.length > 0) {
              const n = t[e[0]];
              if (void 0 !== n) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let t = 0, e = n.length; t < e; t++) {
                  const e = n[t].name || String(t);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[e] = t);
                }
              }
            }
          }
        }
        function B_(t, e, n, i, r, s, o) {
          const a = D_.distanceSqToPoint(t);
          if (a < n) {
            const n = new Hp();
            D_.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(a),
              point: n,
              index: e,
              face: null,
              object: o,
            });
          }
        }
        class z_ extends Np {
          constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l),
              (this.isVideoTexture = !0),
              (this.minFilter = void 0 !== s ? s : cd),
              (this.magFilter = void 0 !== r ? r : cd),
              (this.generateMipmaps = !1);
            const c = this;
            "requestVideoFrameCallback" in t &&
              t.requestVideoFrameCallback(function e() {
                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            const t = this.image;
            !1 === "requestVideoFrameCallback" in t &&
              t.readyState >= t.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        }
        class H_ extends Cm {
          constructor(
            t = 1,
            e = 32,
            n = 16,
            i = 0,
            r = 2 * Math.PI,
            s = 0,
            o = Math.PI
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: o,
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)));
            const a = Math.min(s + o, Math.PI);
            let l = 0;
            const c = [],
              u = new Hp(),
              h = new Hp(),
              d = [],
              p = [],
              f = [],
              m = [];
            for (let d = 0; d <= n; d++) {
              const g = [],
                v = d / n;
              let y = 0;
              0 === d && 0 === s
                ? (y = 0.5 / e)
                : d === n && a === Math.PI && (y = -0.5 / e);
              for (let n = 0; n <= e; n++) {
                const a = n / e;
                (u.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o)),
                  (u.y = t * Math.cos(s + v * o)),
                  (u.z = t * Math.sin(i + a * r) * Math.sin(s + v * o)),
                  p.push(u.x, u.y, u.z),
                  h.copy(u).normalize(),
                  f.push(h.x, h.y, h.z),
                  m.push(a + y, 1 - v),
                  g.push(l++);
              }
              c.push(g);
            }
            for (let t = 0; t < n; t++)
              for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                  r = c[t][i],
                  o = c[t + 1][i],
                  l = c[t + 1][i + 1];
                (0 !== t || s > 0) && d.push(e, r, l),
                  (t !== n - 1 || a < Math.PI) && d.push(r, o, l);
              }
            this.setIndex(d),
              this.setAttribute("position", new bm(p, 3)),
              this.setAttribute("normal", new bm(f, 3)),
              this.setAttribute("uv", new bm(m, 2));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.parameters = Object.assign({}, t.parameters)),
              this
            );
          }
          static fromJSON(t) {
            return new H_(
              t.radius,
              t.widthSegments,
              t.heightSegments,
              t.phiStart,
              t.phiLength,
              t.thetaStart,
              t.thetaLength
            );
          }
        }
        class V_ extends tg {
          constructor(t) {
            super(t),
              (this.isRawShaderMaterial = !0),
              (this.type = "RawShaderMaterial");
          }
        }
        class G_ extends im {
          constructor(t) {
            super(),
              (this.isMeshStandardMaterial = !0),
              (this.defines = {
                STANDARD: "",
              }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new lm(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new lm(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new pp(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              (this.fog = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = {
                STANDARD: "",
              }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              (this.fog = t.fog),
              this
            );
          }
        }
        class W_ extends G_ {
          constructor(t) {
            super(),
              (this.isMeshPhysicalMaterial = !0),
              (this.defines = {
                STANDARD: "",
                PHYSICAL: "",
              }),
              (this.type = "MeshPhysicalMaterial"),
              (this.anisotropyRotation = 0),
              (this.anisotropyMap = null),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new pp(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.ior = 1.5),
              Object.defineProperty(this, "reflectivity", {
                get: function () {
                  return rp((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                  this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
              }),
              (this.iridescenceMap = null),
              (this.iridescenceIOR = 1.3),
              (this.iridescenceThicknessRange = [100, 400]),
              (this.iridescenceThicknessMap = null),
              (this.sheenColor = new lm(0)),
              (this.sheenColorMap = null),
              (this.sheenRoughness = 1),
              (this.sheenRoughnessMap = null),
              (this.transmissionMap = null),
              (this.thickness = 0),
              (this.thicknessMap = null),
              (this.attenuationDistance = 1 / 0),
              (this.attenuationColor = new lm(1, 1, 1)),
              (this.specularIntensity = 1),
              (this.specularIntensityMap = null),
              (this.specularColor = new lm(1, 1, 1)),
              (this.specularColorMap = null),
              (this._anisotropy = 0),
              (this._clearcoat = 0),
              (this._iridescence = 0),
              (this._sheen = 0),
              (this._transmission = 0),
              this.setValues(t);
          }
          get anisotropy() {
            return this._anisotropy;
          }
          set anisotropy(t) {
            this._anisotropy > 0 != t > 0 && this.version++,
              (this._anisotropy = t);
          }
          get clearcoat() {
            return this._clearcoat;
          }
          set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++,
              (this._clearcoat = t);
          }
          get iridescence() {
            return this._iridescence;
          }
          set iridescence(t) {
            this._iridescence > 0 != t > 0 && this.version++,
              (this._iridescence = t);
          }
          get sheen() {
            return this._sheen;
          }
          set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
          }
          get transmission() {
            return this._transmission;
          }
          set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++,
              (this._transmission = t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = {
                STANDARD: "",
                PHYSICAL: "",
              }),
              (this.anisotropy = t.anisotropy),
              (this.anisotropyRotation = t.anisotropyRotation),
              (this.anisotropyMap = t.anisotropyMap),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.ior = t.ior),
              (this.iridescence = t.iridescence),
              (this.iridescenceMap = t.iridescenceMap),
              (this.iridescenceIOR = t.iridescenceIOR),
              (this.iridescenceThicknessRange = [
                ...t.iridescenceThicknessRange,
              ]),
              (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
              (this.sheen = t.sheen),
              this.sheenColor.copy(t.sheenColor),
              (this.sheenColorMap = t.sheenColorMap),
              (this.sheenRoughness = t.sheenRoughness),
              (this.sheenRoughnessMap = t.sheenRoughnessMap),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              (this.thickness = t.thickness),
              (this.thicknessMap = t.thicknessMap),
              (this.attenuationDistance = t.attenuationDistance),
              this.attenuationColor.copy(t.attenuationColor),
              (this.specularIntensity = t.specularIntensity),
              (this.specularIntensityMap = t.specularIntensityMap),
              this.specularColor.copy(t.specularColor),
              (this.specularColorMap = t.specularColorMap),
              this
            );
          }
        }
        function j_(t, e, n) {
          return X_(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        }
        function q_(t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        }
        function X_(t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        }
        function Y_(t) {
          const e = t.length,
            n = new Array(e);
          for (let t = 0; t !== e; ++t) n[t] = t;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        }
        function K_(t, e, n) {
          const i = t.length,
            r = new t.constructor(i);
          for (let s = 0, o = 0; o !== i; ++s) {
            const i = n[s] * e;
            for (let n = 0; n !== e; ++n) r[o++] = t[i + n];
          }
          return r;
        }
        function $_(t, e, n, i) {
          let r = 1,
            s = t[0];
          for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
          if (void 0 === s) return;
          let o = s[i];
          if (void 0 !== o)
            if (Array.isArray(o))
              do {
                (o = s[i]),
                  void 0 !== o && (e.push(s.time), n.push.apply(n, o)),
                  (s = t[r++]);
              } while (void 0 !== s);
            else if (void 0 !== o.toArray)
              do {
                (o = s[i]),
                  void 0 !== o && (e.push(s.time), o.toArray(n, n.length)),
                  (s = t[r++]);
              } while (void 0 !== s);
            else
              do {
                (o = s[i]),
                  void 0 !== o && (e.push(s.time), n.push(o)),
                  (s = t[r++]);
              } while (void 0 !== s);
        }
        class Z_ {
          constructor(t, e, n, i) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                let s;
                n: {
                  i: if (!(t < i)) {
                    for (let s = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.copySampleValue_(n - 1)
                        );
                      }
                      if (n === s) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    s = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  {
                    const o = e[1];
                    t < o && ((n = 2), (r = o));
                    for (let s = n - 2; ; ) {
                      if (void 0 === r)
                        return (
                          (this._cachedIndex = 0), this.copySampleValue_(0)
                        );
                      if (n === s) break;
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                    }
                    (s = n), (n = 0);
                  }
                }
                for (; n < s; ) {
                  const i = (n + s) >>> 1;
                  t < e[i] ? (s = i) : (n = i + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (void 0 === i)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.copySampleValue_(n - 1)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() {}
        }
        class J_ extends Z_ {
          constructor(t, e, n, i) {
            super(t, e, n, i),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = {
                endingStart: Ld,
                endingEnd: Ld,
              });
          }
          intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2,
              s = t + 1,
              o = i[r],
              a = i[s];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case Pd:
                  (r = t), (o = 2 * e - n);
                  break;
                case Od:
                  (r = i.length - 2), (o = e + i[r] - i[r + 1]);
                  break;
                default:
                  (r = t), (o = n);
              }
            if (void 0 === a)
              switch (this.getSettings_().endingEnd) {
                case Pd:
                  (s = t), (a = 2 * n - e);
                  break;
                case Od:
                  (s = 1), (a = n + i[1] - i[0]);
                  break;
                default:
                  (s = t - 1), (a = e);
              }
            const l = 0.5 * (n - e),
              c = this.valueSize;
            (this._weightPrev = l / (e - o)),
              (this._weightNext = l / (a - n)),
              (this._offsetPrev = r * c),
              (this._offsetNext = s * c);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              l = a - o,
              c = this._offsetPrev,
              u = this._offsetNext,
              h = this._weightPrev,
              d = this._weightNext,
              p = (n - e) / (i - e),
              f = p * p,
              m = f * p,
              g = -h * m + 2 * h * f - h * p,
              v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
              y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
              _ = d * m - d * f;
            for (let t = 0; t !== o; ++t)
              r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + _ * s[u + t];
            return r;
          }
        }
        class Q_ extends Z_ {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              l = a - o,
              c = (n - e) / (i - e),
              u = 1 - c;
            for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
            return r;
          }
        }
        class tx extends Z_ {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        class ex {
          constructor(t, e, n, i) {
            if (void 0 === t)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error(
                "THREE.KeyframeTrack: no keyframes in track named " + t
              );
            (this.name = t),
              (this.times = q_(e, this.TimeBufferType)),
              (this.values = q_(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = {
                name: t.name,
                times: q_(t.times, Array),
                values: q_(t.values, Array),
              };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new tx(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new Q_(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new J_(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case Ad:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case Rd:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case Cd:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Ad;
              case this.InterpolantFactoryMethodLinear:
                return Rd;
              case this.InterpolantFactoryMethodSmooth:
                return Cd;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              i = n.length;
            let r = 0,
              s = i - 1;
            for (; r !== i && n[r] < t; ) ++r;
            for (; -1 !== s && n[s] > e; ) --s;
            if ((++s, 0 !== r || s !== i)) {
              r >= s && ((s = Math.max(s, 1)), (r = s - 1));
              const t = this.getValueSize();
              (this.times = j_(n, r, s)),
                (this.values = j_(this.values, r * t, s * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (t = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (t = !1));
            let s = null;
            for (let e = 0; e !== r; e++) {
              const i = n[e];
              if ("number" == typeof i && isNaN(i)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  e,
                  i
                ),
                  (t = !1);
                break;
              }
              if (null !== s && s > i) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  e,
                  i,
                  s
                ),
                  (t = !1);
                break;
              }
              s = i;
            }
            if (void 0 !== i && X_(i))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    e,
                    n
                  ),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = j_(this.times),
              e = j_(this.values),
              n = this.getValueSize(),
              i = this.getInterpolation() === Cd,
              r = t.length - 1;
            let s = 1;
            for (let o = 1; o < r; ++o) {
              let r = !1;
              const a = t[o];
              if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (i) r = !0;
                else {
                  const t = o * n,
                    i = t - n,
                    s = t + n;
                  for (let o = 0; o !== n; ++o) {
                    const n = e[t + o];
                    if (n !== e[i + o] || n !== e[s + o]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (o !== s) {
                  t[s] = t[o];
                  const i = o * n,
                    r = s * n;
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                }
                ++s;
              }
            }
            if (r > 0) {
              t[s] = t[r];
              for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
                e[i + o] = e[t + o];
              ++s;
            }
            return (
              s !== t.length
                ? ((this.times = j_(t, 0, s)), (this.values = j_(e, 0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = j_(this.times, 0),
              e = j_(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (ex.prototype.TimeBufferType = Float32Array),
          (ex.prototype.ValueBufferType = Float32Array),
          (ex.prototype.DefaultInterpolation = Rd);
        class nx extends ex {}
        (nx.prototype.ValueTypeName = "bool"),
          (nx.prototype.ValueBufferType = Array),
          (nx.prototype.DefaultInterpolation = Ad),
          (nx.prototype.InterpolantFactoryMethodLinear = void 0),
          (nx.prototype.InterpolantFactoryMethodSmooth = void 0);
        class ix extends ex {}
        ix.prototype.ValueTypeName = "color";
        class rx extends ex {}
        rx.prototype.ValueTypeName = "number";
        class sx extends Z_ {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = (n - e) / (i - e);
            let l = t * o;
            for (let t = l + o; l !== t; l += 4)
              zp.slerpFlat(r, 0, s, l - o, s, l, a);
            return r;
          }
        }
        class ox extends ex {
          InterpolantFactoryMethodLinear(t) {
            return new sx(this.times, this.values, this.getValueSize(), t);
          }
        }
        (ox.prototype.ValueTypeName = "quaternion"),
          (ox.prototype.DefaultInterpolation = Rd),
          (ox.prototype.InterpolantFactoryMethodSmooth = void 0);
        class ax extends ex {}
        (ax.prototype.ValueTypeName = "string"),
          (ax.prototype.ValueBufferType = Array),
          (ax.prototype.DefaultInterpolation = Ad),
          (ax.prototype.InterpolantFactoryMethodLinear = void 0),
          (ax.prototype.InterpolantFactoryMethodSmooth = void 0);
        class lx extends ex {}
        lx.prototype.ValueTypeName = "vector";
        class cx {
          constructor(t, e = -1, n, i = 2500) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = ip()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t)
              e.push(ux(n[t]).scale(i));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return (r.uuid = t.uuid), r;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(ex.toJSON(n[t]));
            return i;
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              s = [];
            for (let t = 0; t < r; t++) {
              let o = [],
                a = [];
              o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
              const l = Y_(o);
              (o = K_(o, 1, l)),
                (a = K_(a, 1, l)),
                i || 0 !== o[0] || (o.push(r), a.push(a[0])),
                s.push(
                  new rx(
                    ".morphTargetInfluences[" + e[t].name + "]",
                    o,
                    a
                  ).scale(1 / n)
                );
            }
            return new this(t, -1, s);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                s = n.name.match(r);
              if (s && s.length > 1) {
                const t = s[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n);
              }
            }
            const s = [];
            for (const t in i)
              s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return s;
          }
          static parseAnimation(t, e) {
            if (!t)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const s = [],
                    o = [];
                  $_(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o));
                }
              },
              i = [],
              r = t.name || "default",
              s = t.fps || 30,
              o = t.blendMode;
            let a = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++)
                        t[r[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      s = [];
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e];
                      t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new rx(".morphTargetInfluence[" + n + "]", t, s));
                  }
                  a = t.length * s;
                } else {
                  const s = ".bones[" + e[t].name + "]";
                  n(lx, s + ".position", r, "pos", i),
                    n(ox, s + ".quaternion", r, "rot", i),
                    n(lx, s + ".scale", r, "scl", i);
                }
            }
            if (0 === i.length) return null;
            return new this(r, a, i, o);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
              t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
              t.push(this.tracks[e].clone());
            return new this.constructor(
              this.name,
              this.duration,
              t,
              this.blendMode
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function ux(t) {
          if (void 0 === t.type)
            throw new Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return rx;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return lx;
              case "color":
                return ix;
              case "quaternion":
                return ox;
              case "bool":
              case "boolean":
                return nx;
              case "string":
                return ax;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            $_(t.keys, e, n, "value"), (t.times = e), (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const hx = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        class dx {
          constructor(t, e, n) {
            const i = this;
            let r,
              s = !1,
              o = 0,
              a = 0;
            const l = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                a++,
                  !1 === s && void 0 !== i.onStart && i.onStart(t, o, a),
                  (s = !0);
              }),
              (this.itemEnd = function (t) {
                o++,
                  void 0 !== i.onProgress && i.onProgress(t, o, a),
                  o === a && ((s = !1), void 0 !== i.onLoad && i.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t);
              }),
              (this.resolveURL = function (t) {
                return r ? r(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (r = t), this;
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                  const n = l[e],
                    i = l[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
                }
                return null;
              });
          }
        }
        const px = new dx();
        class fx {
          constructor(t) {
            (this.manager = void 0 !== t ? t : px),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.load(t, i, e, r);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        fx.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const mx = {};
        class gx extends Error {
          constructor(t, e) {
            super(t), (this.response = e);
          }
        }
        class vx extends fx {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = hx.get(t);
            if (void 0 !== r)
              return (
                this.manager.itemStart(t),
                setTimeout(() => {
                  e && e(r), this.manager.itemEnd(t);
                }, 0),
                r
              );
            if (void 0 !== mx[t])
              return void mx[t].push({
                onLoad: e,
                onProgress: n,
                onError: i,
              });
            (mx[t] = []),
              mx[t].push({
                onLoad: e,
                onProgress: n,
                onError: i,
              });
            const s = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
              }),
              o = this.mimeType,
              a = this.responseType;
            fetch(s)
              .then((e) => {
                if (200 === e.status || 0 === e.status) {
                  if (
                    (0 === e.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    "undefined" == typeof ReadableStream ||
                      void 0 === e.body ||
                      void 0 === e.body.getReader)
                  )
                    return e;
                  const n = mx[t],
                    i = e.body.getReader(),
                    r =
                      e.headers.get("Content-Length") ||
                      e.headers.get("X-File-Size"),
                    s = r ? parseInt(r) : 0,
                    o = 0 !== s;
                  let a = 0;
                  const l = new ReadableStream({
                    start(t) {
                      !(function e() {
                        i.read().then(({ done: i, value: r }) => {
                          if (i) t.close();
                          else {
                            a += r.byteLength;
                            const i = new ProgressEvent("progress", {
                              lengthComputable: o,
                              loaded: a,
                              total: s,
                            });
                            for (let t = 0, e = n.length; t < e; t++) {
                              const e = n[t];
                              e.onProgress && e.onProgress(i);
                            }
                            t.enqueue(r), e();
                          }
                        });
                      })();
                    },
                  });
                  return new Response(l);
                }
                throw new gx(
                  `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
                  e
                );
              })
              .then((t) => {
                switch (a) {
                  case "arraybuffer":
                    return t.arrayBuffer();
                  case "blob":
                    return t.blob();
                  case "document":
                    return t
                      .text()
                      .then((t) => new DOMParser().parseFromString(t, o));
                  case "json":
                    return t.json();
                  default:
                    if (void 0 === o) return t.text();
                    {
                      const e = /charset="?([^;"\s]*)"?/i.exec(o),
                        n = e && e[1] ? e[1].toLowerCase() : void 0,
                        i = new TextDecoder(n);
                      return t.arrayBuffer().then((t) => i.decode(t));
                    }
                }
              })
              .then((e) => {
                hx.add(t, e);
                const n = mx[t];
                delete mx[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onLoad && i.onLoad(e);
                }
              })
              .catch((e) => {
                const n = mx[t];
                if (void 0 === n) throw (this.manager.itemError(t), e);
                delete mx[t];
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  i.onError && i.onError(e);
                }
                this.manager.itemError(t);
              })
              .finally(() => {
                this.manager.itemEnd(t);
              }),
              this.manager.itemStart(t);
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        class yx extends fx {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = hx.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const o = vp("img");
            function a() {
              c(), hx.add(t, this), e && e(this), r.manager.itemEnd(t);
            }
            function l(e) {
              c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }
            function c() {
              o.removeEventListener("load", a, !1),
                o.removeEventListener("error", l, !1);
            }
            return (
              o.addEventListener("load", a, !1),
              o.addEventListener("error", l, !1),
              "data:" !== t.slice(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (o.src = t),
              o
            );
          }
        }
        class _x extends fx {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              s = new c_(),
              o = new vx(this.manager);
            return (
              o.setResponseType("arraybuffer"),
              o.setRequestHeader(this.requestHeader),
              o.setPath(this.path),
              o.setWithCredentials(r.withCredentials),
              o.load(
                t,
                function (t) {
                  let n;
                  try {
                    n = r.parse(t);
                  } catch (t) {
                    if (void 0 === i) return void console.error(t);
                    i(t);
                  }
                  void 0 !== n.image
                    ? (s.image = n.image)
                    : void 0 !== n.data &&
                      ((s.image.width = n.width),
                      (s.image.height = n.height),
                      (s.image.data = n.data)),
                    (s.wrapS = void 0 !== n.wrapS ? n.wrapS : rd),
                    (s.wrapT = void 0 !== n.wrapT ? n.wrapT : rd),
                    (s.magFilter = void 0 !== n.magFilter ? n.magFilter : cd),
                    (s.minFilter = void 0 !== n.minFilter ? n.minFilter : cd),
                    (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.colorSpace
                      ? (s.colorSpace = n.colorSpace)
                      : void 0 !== n.encoding && (s.encoding = n.encoding),
                    void 0 !== n.flipY && (s.flipY = n.flipY),
                    void 0 !== n.format && (s.format = n.format),
                    void 0 !== n.type && (s.type = n.type),
                    void 0 !== n.mipmaps &&
                      ((s.mipmaps = n.mipmaps), (s.minFilter = hd)),
                    1 === n.mipmapCount && (s.minFilter = cd),
                    void 0 !== n.generateMipmaps &&
                      (s.generateMipmaps = n.generateMipmaps),
                    (s.needsUpdate = !0),
                    e && e(s, n);
                },
                n,
                i
              ),
              s
            );
          }
        }
        class xx extends fx {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = new Np(),
              s = new yx(this.manager);
            return (
              s.setCrossOrigin(this.crossOrigin),
              s.setPath(this.path),
              s.load(
                t,
                function (t) {
                  (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
                },
                n,
                i
              ),
              r
            );
          }
        }
        class bx extends Gf {
          constructor(t, e = 1) {
            super(),
              (this.isLight = !0),
              (this.type = "Light"),
              (this.color = new lm(t)),
              (this.intensity = e);
          }
          dispose() {}
          copy(t, e) {
            return (
              super.copy(t, e),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        const wx = new yf(),
          Ex = new Hp(),
          Sx = new Hp();
        class Mx {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new pp(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new yf()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new pg()),
              (this._frameExtents = new pp(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new Dp(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            Ex.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(Ex),
              Sx.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(Sx),
              e.updateMatrixWorld(),
              wx.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(wx),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(wx);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class Tx extends Mx {
          constructor() {
            super(new ng(50, 1, 0.5, 500)),
              (this.isSpotLightShadow = !0),
              (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * np * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n),
              (e.aspect = i),
              (e.far = r),
              e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        class Ax extends bx {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
            super(t, e),
              (this.isSpotLight = !0),
              (this.type = "SpotLight"),
              this.position.copy(Gf.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new Gf()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = s),
              (this.map = null),
              (this.shadow = new Tx());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        const Rx = new yf(),
          Cx = new Hp(),
          Lx = new Hp();
        class Px extends Mx {
          constructor() {
            super(new ng(90, 1, 0.5, 500)),
              (this.isPointLightShadow = !0),
              (this._frameExtents = new pp(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new Dp(2, 1, 1, 1),
                new Dp(0, 1, 1, 1),
                new Dp(3, 1, 1, 1),
                new Dp(1, 1, 1, 1),
                new Dp(3, 0, 1, 1),
                new Dp(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new Hp(1, 0, 0),
                new Hp(-1, 0, 0),
                new Hp(0, 0, 1),
                new Hp(0, 0, -1),
                new Hp(0, 1, 0),
                new Hp(0, -1, 0),
              ]),
              (this._cubeUps = [
                new Hp(0, 1, 0),
                new Hp(0, 1, 0),
                new Hp(0, 1, 0),
                new Hp(0, 1, 0),
                new Hp(0, 0, 1),
                new Hp(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far;
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              Cx.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(Cx),
              Lx.copy(n.position),
              Lx.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(Lx),
              n.updateMatrixWorld(),
              i.makeTranslation(-Cx.x, -Cx.y, -Cx.z),
              Rx.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Rx);
          }
        }
        class Ox extends bx {
          constructor(t, e, n = 0, i = 2) {
            super(t, e),
              (this.isPointLight = !0),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = i),
              (this.shadow = new Px());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Ix extends Mx {
          constructor() {
            super(new Ag(-5, 5, 5, -5, 0.5, 500)),
              (this.isDirectionalLightShadow = !0);
          }
        }
        class Nx extends bx {
          constructor(t, e) {
            super(t, e),
              (this.isDirectionalLight = !0),
              (this.type = "DirectionalLight"),
              this.position.copy(Gf.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new Gf()),
              (this.shadow = new Ix());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        class Dx {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
              return new TextDecoder().decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++)
              e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.slice(0, e + 1);
          }
          static resolveURL(t, e) {
            return "string" != typeof t || "" === t
              ? ""
              : (/^https?:\/\//i.test(e) &&
                  /^\//.test(t) &&
                  (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) ||
                /^data:.*,.*$/i.test(t) ||
                /^blob:.*$/i.test(t)
                  ? t
                  : e + t);
          }
        }
        class Ux extends fx {
          constructor(t) {
            super(t),
              (this.isImageBitmapLoader = !0),
              "undefined" == typeof createImageBitmap &&
                console.warn(
                  "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                ),
              "undefined" == typeof fetch &&
                console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (this.options = {
                premultiplyAlpha: "none",
              });
          }
          setOptions(t) {
            return (this.options = t), this;
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = hx.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const o = {};
            (o.credentials =
              "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              (o.headers = this.requestHeader),
              fetch(t, o)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(r.options, {
                      colorSpaceConversion: "none",
                    })
                  );
                })
                .then(function (n) {
                  hx.add(t, n), e && e(n), r.manager.itemEnd(t);
                })
                .catch(function (e) {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                }),
              r.manager.itemStart(t);
          }
        }
        class Fx {
          constructor(t = !0) {
            (this.autoStart = t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = kx()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              const e = kx();
              (t = (e - this.oldTime) / 1e3),
                (this.oldTime = e),
                (this.elapsedTime += t);
            }
            return t;
          }
        }
        function kx() {
          return ("undefined" == typeof performance ? Date : performance).now();
        }
        const Bx = "\\[\\]\\.:\\/",
          zx = new RegExp("[" + Bx + "]", "g"),
          Hx = "[^" + Bx + "]",
          Vx = "[^" + Bx.replace("\\.", "") + "]",
          Gx = new RegExp(
            "^" +
              /((?:WC+[\/:])*)/.source.replace("WC", Hx) +
              /(WCOD+)?/.source.replace("WCOD", Vx) +
              /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hx) +
              /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hx) +
              "$"
          ),
          Wx = ["material", "materials", "bones", "map"];
        class jx {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || jx.parseTrackName(e)),
              (this.node = jx.findNode(t, this.parsedPath.nodeName)),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup
              ? new jx.Composite(t, e, n)
              : new jx(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(zx, "");
          }
          static parseTrackName(t) {
            const e = Gx.exec(t);
            if (null === e)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6],
              },
              i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
              const t = n.nodeName.substring(i + 1);
              -1 !== Wx.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  t
              );
            return n;
          }
          static findNode(t, e) {
            if (
              void 0 === e ||
              "" === e ||
              "." === e ||
              -1 === e ||
              e === t.name ||
              e === t.uuid
            )
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r.name === e || r.uuid === e) return r;
                    const s = n(r.children);
                    if (s) return s;
                  }
                  return null;
                },
                i = n(t.children);
              if (i) return i;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              i = e.propertyName;
            let r = e.propertyIndex;
            if (
              (t ||
                ((t = jx.findNode(this.rootNode, e.nodeName)), (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.warn(
                "THREE.PropertyBinding: No target node found for track: " +
                  this.path +
                  "."
              );
            if (n) {
              let i = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === i) {
                      i = e;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in t) {
                    t = t.map;
                    break;
                  }
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.map)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this
                    );
                  t = t.material.map;
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== i) {
                if (void 0 === t[i])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[i];
              }
            }
            const s = t[i];
            if (void 0 === s) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
            let o = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (o = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (o = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === i) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[r] &&
                  (r = t.morphTargetDictionary[r]);
              }
              (a = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = r);
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray
                ? ((a = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = s))
                : Array.isArray(s)
                ? ((a = this.BindingType.EntireArray),
                  (this.resolvedProperty = s))
                : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[a]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (jx.Composite = class {
          constructor(t, e, n) {
            const i = n || jx.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n];
            void 0 !== i && i.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (
              let i = this._targetGroup.nCachedObjects_, r = n.length;
              i !== r;
              ++i
            )
              n[i].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].unbind();
          }
        }),
          (jx.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (jx.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2,
          }),
          (jx.prototype.GetterByBindingType = [
            jx.prototype._getValue_direct,
            jx.prototype._getValue_array,
            jx.prototype._getValue_arrayElement,
            jx.prototype._getValue_toArray,
          ]),
          (jx.prototype.SetterByBindingTypeAndVersioning = [
            [
              jx.prototype._setValue_direct,
              jx.prototype._setValue_direct_setNeedsUpdate,
              jx.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              jx.prototype._setValue_array,
              jx.prototype._setValue_array_setNeedsUpdate,
              jx.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              jx.prototype._setValue_arrayElement,
              jx.prototype._setValue_arrayElement_setNeedsUpdate,
              jx.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              jx.prototype._setValue_fromArray,
              jx.prototype._setValue_fromArray_setNeedsUpdate,
              jx.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        new Float32Array(1);
        class qx {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          }
          makeSafe() {
            const t = 1e-6;
            return (
              (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(rp(e / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class Xx extends P_ {
          constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
            (n = new lm(n)), (i = new lm(i));
            const r = e / 2,
              s = t / e,
              o = t / 2,
              a = [],
              l = [];
            for (let t = 0, c = 0, u = -o; t <= e; t++, u += s) {
              a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
              const e = t === r ? n : i;
              e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3);
            }
            const c = new Cm();
            c.setAttribute("position", new bm(a, 3)),
              c.setAttribute("color", new bm(l, 3));
            super(
              c,
              new w_({
                vertexColors: !0,
                toneMapped: !1,
              })
            ),
              (this.type = "GridHelper");
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }
        class Yx extends P_ {
          constructor(t = 1) {
            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              n = new Cm();
            n.setAttribute("position", new bm(e, 3)),
              n.setAttribute(
                "color",
                new bm(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3
                )
              );
            super(
              n,
              new w_({
                vertexColors: !0,
                toneMapped: !1,
              })
            ),
              (this.type = "AxesHelper");
          }
          setColors(t, e, n) {
            const i = new lm(),
              r = this.geometry.attributes.color.array;
            return (
              i.set(t),
              i.toArray(r, 0),
              i.toArray(r, 3),
              i.set(e),
              i.toArray(r, 6),
              i.toArray(r, 9),
              i.set(n),
              i.toArray(r, 12),
              i.toArray(r, 15),
              (this.geometry.attributes.color.needsUpdate = !0),
              this
            );
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", {
              detail: {
                revision: mh,
              },
            })
          ),
          "undefined" != typeof window &&
            (window.__THREE__
              ? console.warn(
                  "WARNING: Multiple instances of Three.js being imported."
                )
              : (window.__THREE__ = mh));
        const Kx = new (class {
          constructor() {
            switch (
              ((this.isDev = !1),
              (this.breakpoint = 768),
              (this.resizeAfterTime = 200),
              (this.isGui = !0),
              (this.isStats = !0),
              (this.isFog = !1),
              (this.isControls = !1),
              (this.isLightHelper = !1),
              (this.isSceneHelper = !1),
              (this.timezone = this.getTimeZone()),
              (this.colorPalette = this.getColorPalette()),
              (this.sunColor = null),
              (this.bgColor = null),
              (this.lightDiffuse = null),
              (this.lightStrength = null),
              this.timezone)
            ) {
              case 0:
                (this.sunColor = new lm("#b8e4ff").convertLinearToSRGB()),
                  (this.bgColor = new lm("#ecf0f3").convertLinearToSRGB()),
                  (this.lightDiffuse = 0.62),
                  (this.lightStrength = 0.35);
                break;
              case 1:
                (this.sunColor = new lm("#ff1414")),
                  (this.bgColor = new lm("#fff")),
                  (this.lightDiffuse = 0.45),
                  (this.lightStrength = 1);
                break;
              case 2:
                (this.sunColor = new lm("#fb7979").convertLinearToSRGB()),
                  (this.bgColor = new lm("#fafafa").convertLinearToSRGB()),
                  (this.lightDiffuse = 0.45),
                  (this.lightStrength = 0.3);
                break;
              case 3:
                (this.sunColor = new lm("#d699ae").convertLinearToSRGB()),
                  (this.bgColor = new lm("#f0f3ff").convertLinearToSRGB()),
                  (this.lightDiffuse = 0.62),
                  (this.lightStrength = 0.35);
                break;
              default:
                (this.sunColor = new lm("#fff")),
                  (this.bgColor = new lm("#fff")),
                  (this.lightDiffuse = 0.45),
                  (this.lightStrength = 1);
            }
            (this.isHelpers = !1),
              this.isHelpers ||
                ((this.isGui = !1),
                (this.isStats = !1),
                (this.isControls = !1),
                (this.isLightHelper = !1),
                (this.isSceneHelper = !1));
          }
          getTimeZone() {
            let t = null;
            const e = new Date().getHours();
            t =
              e < 4 ? 3 : e < 10 ? 0 : e < 16 ? 1 : e < 22 ? 2 : e < 24 ? 3 : 1;
            let n = this.getParameter("timezone");
            return null != n && ((n = Number(n)), isNaN(n) || (t = n)), t;
          }
          getColorPalette() {
            let t = null;
            switch (this.timezone) {
              case 0:
                t = [
                  new lm("#96B4D0").convertLinearToSRGB(),
                  new lm("#B2BED6").convertLinearToSRGB(),
                  new lm("#CDC4D8").convertLinearToSRGB(),
                  new lm("#EBC9D7").convertLinearToSRGB(),
                  new lm("#FCCCD2").convertLinearToSRGB(),
                  new lm("#FCCCD2").convertLinearToSRGB(),
                ];
                break;
              case 1:
              default:
                t = [
                  new lm("#FEA8E4").convertLinearToSRGB(),
                  new lm("#8AA3FE").convertLinearToSRGB(),
                  new lm("#85FEE2").convertLinearToSRGB(),
                  new lm("#A0FE99").convertLinearToSRGB(),
                  new lm("#FDFE8F").convertLinearToSRGB(),
                  new lm("#FEB380").convertLinearToSRGB(),
                ];
                break;
              case 2:
                t = [
                  new lm("#A1B2D9").convertLinearToSRGB(),
                  new lm("#F5DDBC").convertLinearToSRGB(),
                  new lm("#94C0F0").convertLinearToSRGB(),
                  new lm("#FDB87E").convertLinearToSRGB(),
                  new lm("#FFA365").convertLinearToSRGB(),
                  new lm("#F79161").convertLinearToSRGB(),
                ];
                break;
              case 3:
                t = [
                  new lm("#080C65").convertLinearToSRGB(),
                  new lm("#3B4BE7").convertLinearToSRGB(),
                  new lm("#4E244E").convertLinearToSRGB(),
                  new lm("#3B3FD4").convertLinearToSRGB(),
                  new lm("#8E57CF").convertLinearToSRGB(),
                  new lm("#D699AE").convertLinearToSRGB(),
                ];
            }
            return t;
          }
          getParameter(t) {
            t = t.replace(/[\[\]]/g, "\\$&");
            let e = new RegExp("[?&]" + t + "(=([^&#]*)|&|#|$)").exec(
              window.location.href
            );
            return e
              ? e[2]
                ? decodeURIComponent(e[2].replace(/\+/g, " "))
                : ""
              : null;
          }
        })();
        const $x = new (class {
          constructor() {
            (this.body = document.body),
              (this.ua = window.navigator.userAgent.toLowerCase()),
              (this.data = {
                browser: "",
                os: "",
                device: "",
                iphone: "",
              }),
              this.checkBrowser(),
              this.checkOs(),
              this.checkDevice(),
              this.checkiPhone(),
              "" != this.data.browser &&
                this.body.classList.add(this.data.browser),
              "" != this.data.os && this.body.classList.add(this.data.os),
              "" != this.data.device &&
                this.body.classList.add(this.data.device),
              "" != this.data.iphone &&
                this.body.classList.add(this.data.iphone);
          }
          checkBrowser() {
            let t = "";
            -1 !== this.ua.indexOf("edge") ||
            -1 !== this.ua.indexOf("edga") ||
            -1 !== this.ua.indexOf("edgios")
              ? (t = "edge")
              : -1 !== this.ua.indexOf("opera") || -1 !== this.ua.indexOf("opr")
              ? (t = "opera")
              : -1 !== this.ua.indexOf("samsungbrowser")
              ? (t = "samsung")
              : -1 !== this.ua.indexOf("ucbrowser")
              ? (t = "uc")
              : -1 !== this.ua.indexOf("chrome") ||
                -1 !== this.ua.indexOf("crios")
              ? (t = "chrome")
              : -1 !== this.ua.indexOf("firefox") ||
                -1 !== this.ua.indexOf("fxios")
              ? (t = "firefox")
              : -1 !== this.ua.indexOf("safari")
              ? (t = "safari")
              : (-1 === this.ua.indexOf("msie") &&
                  -1 === this.ua.indexOf("trident")) ||
                (t = "ie"),
              (this.data.browser = t);
          }
          checkOs() {
            let t = "";
            -1 !== this.ua.indexOf("windows nt")
              ? (t = "windows")
              : -1 !== this.ua.indexOf("android")
              ? (t = "android")
              : -1 !== this.ua.indexOf("iphone") ||
                -1 !== this.ua.indexOf("ipad")
              ? (t = "ios")
              : -1 !== this.ua.indexOf("mac os x") && (t = "macos"),
              (this.data.os = t);
          }
          checkDevice() {
            let t = "";
            (t =
              -1 !== this.ua.indexOf("iphone") ||
              (-1 !== this.ua.indexOf("android") &&
                this.ua.indexOf("Mobile") > 0)
                ? "mobile"
                : -1 !== this.ua.indexOf("ipad") ||
                  -1 !== this.ua.indexOf("android") ||
                  this.ua.indexOf("ipad") > -1 ||
                  (this.ua.indexOf("macintosh") > -1 &&
                    "ontouchend" in document)
                ? "tablet"
                : "pc"),
              (this.data.device = t);
          }
          checkiPhone() {
            -1 !== this.ua.indexOf("iphone")
              ? (this.data.iphone = "iphone")
              : (this.data.iphone = "");
          }
        })();
        class Zx {
          constructor() {
            (this.body = document.body),
              (this.ua = $x.data),
              (this.params = {
                w: window.innerWidth,
                h: window.innerHeight,
                beforeWidth: window.innerWidth,
              }),
              (this.isPlaying = !1),
              (this.isAbleToResize = !0),
              (this.isMatchMediaWidth = window.matchMedia(
                `(max-width: ${Kx.breakpoint}px)`
              ).matches),
              (this.isMatchMediaHover =
                window.matchMedia("(hover: hover)").matches),
              (this.clock = new Fx()),
              (this.time = {
                delta: 0,
                elapsed: 0,
              }),
              (this.timer = {
                resize: null,
              }),
              (this.update = this.update.bind(this)),
              (this.resize = this.resize.bind(this)),
              window.addEventListener(
                "visibilitychange",
                this.visibilitychange.bind(this)
              );
          }
          visibilitychange() {
            "visible" === document.visibilityState ? this.play() : this.pause();
          }
          play() {
            (this.isPlaying = !0), this.clock.start();
          }
          pause() {
            (this.isPlaying = !1), this.clock.stop();
          }
          resize() {
            "pc" === this.ua.device
              ? (this.isAbleToResize = !0)
              : (this.isAbleToResize = !(window.innerWidth === this.params.w)),
              this.isAbleToResize &&
                ((this.params.h = window.innerHeight),
                (this.isMatchMediaWidth = window.matchMedia(
                  `(max-width: ${Kx.breakpoint}px)`
                ).matches),
                (this.isMatchMediaHover =
                  window.matchMedia("(hover: hover)").matches),
                (this.params.w = window.innerWidth),
                clearTimeout(this.timer.resize),
                (this.timer.resize = setTimeout(() => {
                  const t = window.innerWidth;
                  t > Kx.breakpoint &&
                    this.params.beforeWidth < Kx.breakpoint + 1 &&
                    window.location.reload(),
                    t < Kx.breakpoint + 1 &&
                      this.params.beforeWidth > Kx.breakpoint + 1 &&
                      window.location.reload(),
                    (this.params.beforeWidth = t);
                }, Kx.resizeAfterTime)));
          }
          update() {
            (this.time.delta = this.clock.getDelta()),
              (this.time.elapsed = this.clock.getElapsedTime());
          }
        }
        class Jx {
          constructor(t) {
            void 0 === t && (t = [0, 0, 0, 0, 0, 0, 0, 0, 0]),
              (this.elements = t);
          }
          identity() {
            const t = this.elements;
            (t[0] = 1),
              (t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 1),
              (t[5] = 0),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 1);
          }
          setZero() {
            const t = this.elements;
            (t[0] = 0),
              (t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 0),
              (t[5] = 0),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 0);
          }
          setTrace(t) {
            const e = this.elements;
            (e[0] = t.x), (e[4] = t.y), (e[8] = t.z);
          }
          getTrace(t) {
            void 0 === t && (t = new tb());
            const e = this.elements;
            return (t.x = e[0]), (t.y = e[4]), (t.z = e[8]), t;
          }
          vmult(t, e) {
            void 0 === e && (e = new tb());
            const n = this.elements,
              i = t.x,
              r = t.y,
              s = t.z;
            return (
              (e.x = n[0] * i + n[1] * r + n[2] * s),
              (e.y = n[3] * i + n[4] * r + n[5] * s),
              (e.z = n[6] * i + n[7] * r + n[8] * s),
              e
            );
          }
          smult(t) {
            for (let e = 0; e < this.elements.length; e++)
              this.elements[e] *= t;
          }
          mmult(t, e) {
            void 0 === e && (e = new Jx());
            const n = this.elements,
              i = t.elements,
              r = e.elements,
              s = n[0],
              o = n[1],
              a = n[2],
              l = n[3],
              c = n[4],
              u = n[5],
              h = n[6],
              d = n[7],
              p = n[8],
              f = i[0],
              m = i[1],
              g = i[2],
              v = i[3],
              y = i[4],
              _ = i[5],
              x = i[6],
              b = i[7],
              w = i[8];
            return (
              (r[0] = s * f + o * v + a * x),
              (r[1] = s * m + o * y + a * b),
              (r[2] = s * g + o * _ + a * w),
              (r[3] = l * f + c * v + u * x),
              (r[4] = l * m + c * y + u * b),
              (r[5] = l * g + c * _ + u * w),
              (r[6] = h * f + d * v + p * x),
              (r[7] = h * m + d * y + p * b),
              (r[8] = h * g + d * _ + p * w),
              e
            );
          }
          scale(t, e) {
            void 0 === e && (e = new Jx());
            const n = this.elements,
              i = e.elements;
            for (let e = 0; 3 !== e; e++)
              (i[3 * e + 0] = t.x * n[3 * e + 0]),
                (i[3 * e + 1] = t.y * n[3 * e + 1]),
                (i[3 * e + 2] = t.z * n[3 * e + 2]);
            return e;
          }
          solve(t, e) {
            void 0 === e && (e = new tb());
            const n = [];
            let i, r;
            for (i = 0; i < 12; i++) n.push(0);
            for (i = 0; i < 3; i++)
              for (r = 0; r < 3; r++) n[i + 4 * r] = this.elements[i + 3 * r];
            (n[3] = t.x), (n[7] = t.y), (n[11] = t.z);
            let s = 3;
            const o = s;
            let a;
            let l;
            do {
              if (((i = o - s), 0 === n[i + 4 * i]))
                for (r = i + 1; r < o; r++)
                  if (0 !== n[i + 4 * r]) {
                    a = 4;
                    do {
                      (l = 4 - a), (n[l + 4 * i] += n[l + 4 * r]);
                    } while (--a);
                    break;
                  }
              if (0 !== n[i + 4 * i])
                for (r = i + 1; r < o; r++) {
                  const t = n[i + 4 * r] / n[i + 4 * i];
                  a = 4;
                  do {
                    (l = 4 - a),
                      (n[l + 4 * r] =
                        l <= i ? 0 : n[l + 4 * r] - n[l + 4 * i] * t);
                  } while (--a);
                }
            } while (--s);
            if (
              ((e.z = n[11] / n[10]),
              (e.y = (n[7] - n[6] * e.z) / n[5]),
              (e.x = (n[3] - n[2] * e.z - n[1] * e.y) / n[0]),
              isNaN(e.x) ||
                isNaN(e.y) ||
                isNaN(e.z) ||
                e.x === 1 / 0 ||
                e.y === 1 / 0 ||
                e.z === 1 / 0)
            )
              throw `Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;
            return e;
          }
          e(t, e, n) {
            if (void 0 === n) return this.elements[e + 3 * t];
            this.elements[e + 3 * t] = n;
          }
          copy(t) {
            for (let e = 0; e < t.elements.length; e++)
              this.elements[e] = t.elements[e];
            return this;
          }
          toString() {
            let t = "";
            for (let e = 0; e < 9; e++) t += this.elements[e] + ",";
            return t;
          }
          reverse(t) {
            void 0 === t && (t = new Jx());
            const e = Qx;
            let n, i;
            for (n = 0; n < 3; n++)
              for (i = 0; i < 3; i++) e[n + 6 * i] = this.elements[n + 3 * i];
            (e[3] = 1),
              (e[9] = 0),
              (e[15] = 0),
              (e[4] = 0),
              (e[10] = 1),
              (e[16] = 0),
              (e[5] = 0),
              (e[11] = 0),
              (e[17] = 1);
            let r = 3;
            const s = r;
            let o;
            let a;
            do {
              if (((n = s - r), 0 === e[n + 6 * n]))
                for (i = n + 1; i < s; i++)
                  if (0 !== e[n + 6 * i]) {
                    o = 6;
                    do {
                      (a = 6 - o), (e[a + 6 * n] += e[a + 6 * i]);
                    } while (--o);
                    break;
                  }
              if (0 !== e[n + 6 * n])
                for (i = n + 1; i < s; i++) {
                  const t = e[n + 6 * i] / e[n + 6 * n];
                  o = 6;
                  do {
                    (a = 6 - o),
                      (e[a + 6 * i] =
                        a <= n ? 0 : e[a + 6 * i] - e[a + 6 * n] * t);
                  } while (--o);
                }
            } while (--r);
            n = 2;
            do {
              i = n - 1;
              do {
                const t = e[n + 6 * i] / e[n + 6 * n];
                o = 6;
                do {
                  (a = 6 - o), (e[a + 6 * i] = e[a + 6 * i] - e[a + 6 * n] * t);
                } while (--o);
              } while (i--);
            } while (--n);
            n = 2;
            do {
              const t = 1 / e[n + 6 * n];
              o = 6;
              do {
                (a = 6 - o), (e[a + 6 * n] = e[a + 6 * n] * t);
              } while (--o);
            } while (n--);
            n = 2;
            do {
              i = 2;
              do {
                if (((a = e[3 + i + 6 * n]), isNaN(a) || a === 1 / 0))
                  throw `Could not reverse! A=[${this.toString()}]`;
                t.e(n, i, a);
              } while (i--);
            } while (n--);
            return t;
          }
          setRotationFromQuaternion(t) {
            const e = t.x,
              n = t.y,
              i = t.z,
              r = t.w,
              s = e + e,
              o = n + n,
              a = i + i,
              l = e * s,
              c = e * o,
              u = e * a,
              h = n * o,
              d = n * a,
              p = i * a,
              f = r * s,
              m = r * o,
              g = r * a,
              v = this.elements;
            return (
              (v[0] = 1 - (h + p)),
              (v[1] = c - g),
              (v[2] = u + m),
              (v[3] = c + g),
              (v[4] = 1 - (l + p)),
              (v[5] = d - f),
              (v[6] = u - m),
              (v[7] = d + f),
              (v[8] = 1 - (l + h)),
              this
            );
          }
          transpose(t) {
            void 0 === t && (t = new Jx());
            const e = this.elements,
              n = t.elements;
            let i;
            return (
              (n[0] = e[0]),
              (n[4] = e[4]),
              (n[8] = e[8]),
              (i = e[1]),
              (n[1] = e[3]),
              (n[3] = i),
              (i = e[2]),
              (n[2] = e[6]),
              (n[6] = i),
              (i = e[5]),
              (n[5] = e[7]),
              (n[7] = i),
              t
            );
          }
        }
        const Qx = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        class tb {
          constructor(t, e, n) {
            void 0 === t && (t = 0),
              void 0 === e && (e = 0),
              void 0 === n && (n = 0),
              (this.x = t),
              (this.y = e),
              (this.z = n);
          }
          cross(t, e) {
            void 0 === e && (e = new tb());
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.x,
              o = this.y,
              a = this.z;
            return (
              (e.x = o * r - a * i),
              (e.y = a * n - s * r),
              (e.z = s * i - o * n),
              e
            );
          }
          set(t, e, n) {
            return (this.x = t), (this.y = e), (this.z = n), this;
          }
          setZero() {
            this.x = this.y = this.z = 0;
          }
          vadd(t, e) {
            if (!e) return new tb(this.x + t.x, this.y + t.y, this.z + t.z);
            (e.x = t.x + this.x), (e.y = t.y + this.y), (e.z = t.z + this.z);
          }
          vsub(t, e) {
            if (!e) return new tb(this.x - t.x, this.y - t.y, this.z - t.z);
            (e.x = this.x - t.x), (e.y = this.y - t.y), (e.z = this.z - t.z);
          }
          crossmat() {
            return new Jx([
              0,
              -this.z,
              this.y,
              this.z,
              0,
              -this.x,
              -this.y,
              this.x,
              0,
            ]);
          }
          normalize() {
            const t = this.x,
              e = this.y,
              n = this.z,
              i = Math.sqrt(t * t + e * e + n * n);
            if (i > 0) {
              const t = 1 / i;
              (this.x *= t), (this.y *= t), (this.z *= t);
            } else (this.x = 0), (this.y = 0), (this.z = 0);
            return i;
          }
          unit(t) {
            void 0 === t && (t = new tb());
            const e = this.x,
              n = this.y,
              i = this.z;
            let r = Math.sqrt(e * e + n * n + i * i);
            return (
              r > 0
                ? ((r = 1 / r), (t.x = e * r), (t.y = n * r), (t.z = i * r))
                : ((t.x = 1), (t.y = 0), (t.z = 0)),
              t
            );
          }
          length() {
            const t = this.x,
              e = this.y,
              n = this.z;
            return Math.sqrt(t * t + e * e + n * n);
          }
          lengthSquared() {
            return this.dot(this);
          }
          distanceTo(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              o = t.z;
            return Math.sqrt(
              (r - e) * (r - e) + (s - n) * (s - n) + (o - i) * (o - i)
            );
          }
          distanceSquared(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              o = t.z;
            return (r - e) * (r - e) + (s - n) * (s - n) + (o - i) * (o - i);
          }
          scale(t, e) {
            void 0 === e && (e = new tb());
            const n = this.x,
              i = this.y,
              r = this.z;
            return (e.x = t * n), (e.y = t * i), (e.z = t * r), e;
          }
          vmul(t, e) {
            return (
              void 0 === e && (e = new tb()),
              (e.x = t.x * this.x),
              (e.y = t.y * this.y),
              (e.z = t.z * this.z),
              e
            );
          }
          addScaledVector(t, e, n) {
            return (
              void 0 === n && (n = new tb()),
              (n.x = this.x + t * e.x),
              (n.y = this.y + t * e.y),
              (n.z = this.z + t * e.z),
              n
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          isZero() {
            return 0 === this.x && 0 === this.y && 0 === this.z;
          }
          negate(t) {
            return (
              void 0 === t && (t = new tb()),
              (t.x = -this.x),
              (t.y = -this.y),
              (t.z = -this.z),
              t
            );
          }
          tangents(t, e) {
            const n = this.length();
            if (n > 0) {
              const i = eb,
                r = 1 / n;
              i.set(this.x * r, this.y * r, this.z * r);
              const s = nb;
              Math.abs(i.x) < 0.9
                ? (s.set(1, 0, 0), i.cross(s, t))
                : (s.set(0, 1, 0), i.cross(s, t)),
                i.cross(t, e);
            } else t.set(1, 0, 0), e.set(0, 1, 0);
          }
          toString() {
            return `${this.x},${this.y},${this.z}`;
          }
          toArray() {
            return [this.x, this.y, this.z];
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          lerp(t, e, n) {
            const i = this.x,
              r = this.y,
              s = this.z;
            (n.x = i + (t.x - i) * e),
              (n.y = r + (t.y - r) * e),
              (n.z = s + (t.z - s) * e);
          }
          almostEquals(t, e) {
            return (
              void 0 === e && (e = 1e-6),
              !(
                Math.abs(this.x - t.x) > e ||
                Math.abs(this.y - t.y) > e ||
                Math.abs(this.z - t.z) > e
              )
            );
          }
          almostZero(t) {
            return (
              void 0 === t && (t = 1e-6),
              !(
                Math.abs(this.x) > t ||
                Math.abs(this.y) > t ||
                Math.abs(this.z) > t
              )
            );
          }
          isAntiparallelTo(t, e) {
            return this.negate(ib), ib.almostEquals(t, e);
          }
          clone() {
            return new tb(this.x, this.y, this.z);
          }
        }
        (tb.ZERO = new tb(0, 0, 0)),
          (tb.UNIT_X = new tb(1, 0, 0)),
          (tb.UNIT_Y = new tb(0, 1, 0)),
          (tb.UNIT_Z = new tb(0, 0, 1));
        const eb = new tb(),
          nb = new tb(),
          ib = new tb();
        class rb {
          constructor(t) {
            void 0 === t && (t = {}),
              (this.lowerBound = new tb()),
              (this.upperBound = new tb()),
              t.lowerBound && this.lowerBound.copy(t.lowerBound),
              t.upperBound && this.upperBound.copy(t.upperBound);
          }
          setFromPoints(t, e, n, i) {
            const r = this.lowerBound,
              s = this.upperBound,
              o = n;
            r.copy(t[0]), o && o.vmult(r, r), s.copy(r);
            for (let e = 1; e < t.length; e++) {
              let n = t[e];
              o && (o.vmult(n, sb), (n = sb)),
                n.x > s.x && (s.x = n.x),
                n.x < r.x && (r.x = n.x),
                n.y > s.y && (s.y = n.y),
                n.y < r.y && (r.y = n.y),
                n.z > s.z && (s.z = n.z),
                n.z < r.z && (r.z = n.z);
            }
            return (
              e && (e.vadd(r, r), e.vadd(s, s)),
              i &&
                ((r.x -= i),
                (r.y -= i),
                (r.z -= i),
                (s.x += i),
                (s.y += i),
                (s.z += i)),
              this
            );
          }
          copy(t) {
            return (
              this.lowerBound.copy(t.lowerBound),
              this.upperBound.copy(t.upperBound),
              this
            );
          }
          clone() {
            return new rb().copy(this);
          }
          extend(t) {
            (this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x)),
              (this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x)),
              (this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y)),
              (this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y)),
              (this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z)),
              (this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z));
          }
          overlaps(t) {
            const e = this.lowerBound,
              n = this.upperBound,
              i = t.lowerBound,
              r = t.upperBound,
              s = (i.x <= n.x && n.x <= r.x) || (e.x <= r.x && r.x <= n.x),
              o = (i.y <= n.y && n.y <= r.y) || (e.y <= r.y && r.y <= n.y),
              a = (i.z <= n.z && n.z <= r.z) || (e.z <= r.z && r.z <= n.z);
            return s && o && a;
          }
          volume() {
            const t = this.lowerBound,
              e = this.upperBound;
            return (e.x - t.x) * (e.y - t.y) * (e.z - t.z);
          }
          contains(t) {
            const e = this.lowerBound,
              n = this.upperBound,
              i = t.lowerBound,
              r = t.upperBound;
            return (
              e.x <= i.x &&
              n.x >= r.x &&
              e.y <= i.y &&
              n.y >= r.y &&
              e.z <= i.z &&
              n.z >= r.z
            );
          }
          getCorners(t, e, n, i, r, s, o, a) {
            const l = this.lowerBound,
              c = this.upperBound;
            t.copy(l),
              e.set(c.x, l.y, l.z),
              n.set(c.x, c.y, l.z),
              i.set(l.x, c.y, c.z),
              r.set(c.x, l.y, c.z),
              s.set(l.x, c.y, l.z),
              o.set(l.x, l.y, c.z),
              a.copy(c);
          }
          toLocalFrame(t, e) {
            const n = ob,
              i = n[0],
              r = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = n[5],
              c = n[6],
              u = n[7];
            this.getCorners(i, r, s, o, a, l, c, u);
            for (let e = 0; 8 !== e; e++) {
              const i = n[e];
              t.pointToLocal(i, i);
            }
            return e.setFromPoints(n);
          }
          toWorldFrame(t, e) {
            const n = ob,
              i = n[0],
              r = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = n[5],
              c = n[6],
              u = n[7];
            this.getCorners(i, r, s, o, a, l, c, u);
            for (let e = 0; 8 !== e; e++) {
              const i = n[e];
              t.pointToWorld(i, i);
            }
            return e.setFromPoints(n);
          }
          overlapsRay(t) {
            const { direction: e, from: n } = t,
              i = 1 / e.x,
              r = 1 / e.y,
              s = 1 / e.z,
              o = (this.lowerBound.x - n.x) * i,
              a = (this.upperBound.x - n.x) * i,
              l = (this.lowerBound.y - n.y) * r,
              c = (this.upperBound.y - n.y) * r,
              u = (this.lowerBound.z - n.z) * s,
              h = (this.upperBound.z - n.z) * s,
              d = Math.max(
                Math.max(Math.min(o, a), Math.min(l, c)),
                Math.min(u, h)
              ),
              p = Math.min(
                Math.min(Math.max(o, a), Math.max(l, c)),
                Math.max(u, h)
              );
            return !(p < 0) && !(d > p);
          }
        }
        const sb = new tb(),
          ob = [
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
          ];
        class ab {
          constructor() {
            this.matrix = [];
          }
          get(t, e) {
            let { index: n } = t,
              { index: i } = e;
            if (i > n) {
              const t = i;
              (i = n), (n = t);
            }
            return this.matrix[((n * (n + 1)) >> 1) + i - 1];
          }
          set(t, e, n) {
            let { index: i } = t,
              { index: r } = e;
            if (r > i) {
              const t = r;
              (r = i), (i = t);
            }
            this.matrix[((i * (i + 1)) >> 1) + r - 1] = n ? 1 : 0;
          }
          reset() {
            for (let t = 0, e = this.matrix.length; t !== e; t++)
              this.matrix[t] = 0;
          }
          setNumObjects(t) {
            this.matrix.length = (t * (t - 1)) >> 1;
          }
        }
        class lb {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            return (
              void 0 === n[t] && (n[t] = []),
              n[t].includes(e) || n[t].push(e),
              this
            );
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return !(void 0 === n[t] || !n[t].includes(e));
          }
          hasAnyEventListener(t) {
            if (void 0 === this._listeners) return !1;
            return void 0 !== this._listeners[t];
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return this;
            const n = this._listeners;
            if (void 0 === n[t]) return this;
            const i = n[t].indexOf(e);
            return -1 !== i && n[t].splice(i, 1), this;
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return this;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              for (let n = 0, i = e.length; n < i; n++) e[n].call(this, t);
            }
            return this;
          }
        }
        class cb {
          constructor(t, e, n, i) {
            void 0 === t && (t = 0),
              void 0 === e && (e = 0),
              void 0 === n && (n = 0),
              void 0 === i && (i = 1),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              (this.w = i);
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          toString() {
            return `${this.x},${this.y},${this.z},${this.w}`;
          }
          toArray() {
            return [this.x, this.y, this.z, this.w];
          }
          setFromAxisAngle(t, e) {
            const n = Math.sin(0.5 * e);
            return (
              (this.x = t.x * n),
              (this.y = t.y * n),
              (this.z = t.z * n),
              (this.w = Math.cos(0.5 * e)),
              this
            );
          }
          toAxisAngle(t) {
            void 0 === t && (t = new tb()), this.normalize();
            const e = 2 * Math.acos(this.w),
              n = Math.sqrt(1 - this.w * this.w);
            return (
              n < 0.001
                ? ((t.x = this.x), (t.y = this.y), (t.z = this.z))
                : ((t.x = this.x / n), (t.y = this.y / n), (t.z = this.z / n)),
              [t, e]
            );
          }
          setFromVectors(t, e) {
            if (t.isAntiparallelTo(e)) {
              const e = ub,
                n = hb;
              t.tangents(e, n), this.setFromAxisAngle(e, Math.PI);
            } else {
              const n = t.cross(e);
              (this.x = n.x),
                (this.y = n.y),
                (this.z = n.z),
                (this.w =
                  Math.sqrt(t.length() ** 2 * e.length() ** 2) + t.dot(e)),
                this.normalize();
            }
            return this;
          }
          mult(t, e) {
            void 0 === e && (e = new cb());
            const n = this.x,
              i = this.y,
              r = this.z,
              s = this.w,
              o = t.x,
              a = t.y,
              l = t.z,
              c = t.w;
            return (
              (e.x = n * c + s * o + i * l - r * a),
              (e.y = i * c + s * a + r * o - n * l),
              (e.z = r * c + s * l + n * a - i * o),
              (e.w = s * c - n * o - i * a - r * l),
              e
            );
          }
          inverse(t) {
            void 0 === t && (t = new cb());
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w;
            this.conjugate(t);
            const s = 1 / (e * e + n * n + i * i + r * r);
            return (t.x *= s), (t.y *= s), (t.z *= s), (t.w *= s), t;
          }
          conjugate(t) {
            return (
              void 0 === t && (t = new cb()),
              (t.x = -this.x),
              (t.y = -this.y),
              (t.z = -this.z),
              (t.w = this.w),
              t
            );
          }
          normalize() {
            let t = Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
            return (
              0 === t
                ? ((this.x = 0), (this.y = 0), (this.z = 0), (this.w = 0))
                : ((t = 1 / t),
                  (this.x *= t),
                  (this.y *= t),
                  (this.z *= t),
                  (this.w *= t)),
              this
            );
          }
          normalizeFast() {
            const t =
              (3 -
                (this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w)) /
              2;
            return (
              0 === t
                ? ((this.x = 0), (this.y = 0), (this.z = 0), (this.w = 0))
                : ((this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t)),
              this
            );
          }
          vmult(t, e) {
            void 0 === e && (e = new tb());
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.x,
              o = this.y,
              a = this.z,
              l = this.w,
              c = l * n + o * r - a * i,
              u = l * i + a * n - s * r,
              h = l * r + s * i - o * n,
              d = -s * n - o * i - a * r;
            return (
              (e.x = c * l + d * -s + u * -a - h * -o),
              (e.y = u * l + d * -o + h * -s - c * -a),
              (e.z = h * l + d * -a + c * -o - u * -s),
              e
            );
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = t.w),
              this
            );
          }
          toEuler(t, e) {
            let n, i, r;
            void 0 === e && (e = "YZX");
            const s = this.x,
              o = this.y,
              a = this.z,
              l = this.w;
            if ("YZX" !== e)
              throw new Error(`Euler order ${e} not supported yet.`);
            {
              const t = s * o + a * l;
              if (
                (t > 0.499 &&
                  ((n = 2 * Math.atan2(s, l)), (i = Math.PI / 2), (r = 0)),
                t < -0.499 &&
                  ((n = -2 * Math.atan2(s, l)), (i = -Math.PI / 2), (r = 0)),
                void 0 === n)
              ) {
                const e = s * s,
                  c = o * o,
                  u = a * a;
                (n = Math.atan2(2 * o * l - 2 * s * a, 1 - 2 * c - 2 * u)),
                  (i = Math.asin(2 * t)),
                  (r = Math.atan2(2 * s * l - 2 * o * a, 1 - 2 * e - 2 * u));
              }
            }
            (t.y = n), (t.z = i), (t.x = r);
          }
          setFromEuler(t, e, n, i) {
            void 0 === i && (i = "XYZ");
            const r = Math.cos(t / 2),
              s = Math.cos(e / 2),
              o = Math.cos(n / 2),
              a = Math.sin(t / 2),
              l = Math.sin(e / 2),
              c = Math.sin(n / 2);
            return (
              "XYZ" === i
                ? ((this.x = a * s * o + r * l * c),
                  (this.y = r * l * o - a * s * c),
                  (this.z = r * s * c + a * l * o),
                  (this.w = r * s * o - a * l * c))
                : "YXZ" === i
                ? ((this.x = a * s * o + r * l * c),
                  (this.y = r * l * o - a * s * c),
                  (this.z = r * s * c - a * l * o),
                  (this.w = r * s * o + a * l * c))
                : "ZXY" === i
                ? ((this.x = a * s * o - r * l * c),
                  (this.y = r * l * o + a * s * c),
                  (this.z = r * s * c + a * l * o),
                  (this.w = r * s * o - a * l * c))
                : "ZYX" === i
                ? ((this.x = a * s * o - r * l * c),
                  (this.y = r * l * o + a * s * c),
                  (this.z = r * s * c - a * l * o),
                  (this.w = r * s * o + a * l * c))
                : "YZX" === i
                ? ((this.x = a * s * o + r * l * c),
                  (this.y = r * l * o + a * s * c),
                  (this.z = r * s * c - a * l * o),
                  (this.w = r * s * o - a * l * c))
                : "XZY" === i &&
                  ((this.x = a * s * o - r * l * c),
                  (this.y = r * l * o - a * s * c),
                  (this.z = r * s * c + a * l * o),
                  (this.w = r * s * o + a * l * c)),
              this
            );
          }
          clone() {
            return new cb(this.x, this.y, this.z, this.w);
          }
          slerp(t, e, n) {
            void 0 === n && (n = new cb());
            const i = this.x,
              r = this.y,
              s = this.z,
              o = this.w;
            let a,
              l,
              c,
              u,
              h,
              d = t.x,
              p = t.y,
              f = t.z,
              m = t.w;
            return (
              (l = i * d + r * p + s * f + o * m),
              l < 0 && ((l = -l), (d = -d), (p = -p), (f = -f), (m = -m)),
              1 - l > 1e-6
                ? ((a = Math.acos(l)),
                  (c = Math.sin(a)),
                  (u = Math.sin((1 - e) * a) / c),
                  (h = Math.sin(e * a) / c))
                : ((u = 1 - e), (h = e)),
              (n.x = u * i + h * d),
              (n.y = u * r + h * p),
              (n.z = u * s + h * f),
              (n.w = u * o + h * m),
              n
            );
          }
          integrate(t, e, n, i) {
            void 0 === i && (i = new cb());
            const r = t.x * n.x,
              s = t.y * n.y,
              o = t.z * n.z,
              a = this.x,
              l = this.y,
              c = this.z,
              u = this.w,
              h = 0.5 * e;
            return (
              (i.x += h * (r * u + s * c - o * l)),
              (i.y += h * (s * u + o * a - r * c)),
              (i.z += h * (o * u + r * l - s * a)),
              (i.w += h * (-r * a - s * l - o * c)),
              i
            );
          }
        }
        const ub = new tb(),
          hb = new tb();
        class db {
          constructor(t) {
            void 0 === t && (t = {}),
              (this.id = db.idCounter++),
              (this.type = t.type || 0),
              (this.boundingSphereRadius = 0),
              (this.collisionResponse =
                !t.collisionResponse || t.collisionResponse),
              (this.collisionFilterGroup =
                void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1),
              (this.collisionFilterMask =
                void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1),
              (this.material = t.material ? t.material : null),
              (this.body = null);
          }
          updateBoundingSphereRadius() {
            throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
          }
          volume() {
            throw `volume() not implemented for shape type ${this.type}`;
          }
          calculateLocalInertia(t, e) {
            throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
          }
          calculateWorldAABB(t, e, n, i) {
            throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
          }
        }
        (db.idCounter = 0),
          (db.types = {
            SPHERE: 1,
            PLANE: 2,
            BOX: 4,
            COMPOUND: 8,
            CONVEXPOLYHEDRON: 16,
            HEIGHTFIELD: 32,
            PARTICLE: 64,
            CYLINDER: 128,
            TRIMESH: 256,
          });
        class pb {
          constructor(t) {
            void 0 === t && (t = {}),
              (this.position = new tb()),
              (this.quaternion = new cb()),
              t.position && this.position.copy(t.position),
              t.quaternion && this.quaternion.copy(t.quaternion);
          }
          pointToLocal(t, e) {
            return pb.pointToLocalFrame(this.position, this.quaternion, t, e);
          }
          pointToWorld(t, e) {
            return pb.pointToWorldFrame(this.position, this.quaternion, t, e);
          }
          vectorToWorldFrame(t, e) {
            return (
              void 0 === e && (e = new tb()), this.quaternion.vmult(t, e), e
            );
          }
          static pointToLocalFrame(t, e, n, i) {
            return (
              void 0 === i && (i = new tb()),
              n.vsub(t, i),
              e.conjugate(fb),
              fb.vmult(i, i),
              i
            );
          }
          static pointToWorldFrame(t, e, n, i) {
            return (
              void 0 === i && (i = new tb()), e.vmult(n, i), i.vadd(t, i), i
            );
          }
          static vectorToWorldFrame(t, e, n) {
            return void 0 === n && (n = new tb()), t.vmult(e, n), n;
          }
          static vectorToLocalFrame(t, e, n, i) {
            return (
              void 0 === i && (i = new tb()),
              (e.w *= -1),
              e.vmult(n, i),
              (e.w *= -1),
              i
            );
          }
        }
        const fb = new cb();
        class mb extends db {
          constructor(t) {
            void 0 === t && (t = {});
            const {
              vertices: e = [],
              faces: n = [],
              normals: i = [],
              axes: r,
              boundingSphereRadius: s,
            } = t;
            super({
              type: db.types.CONVEXPOLYHEDRON,
            }),
              (this.vertices = e),
              (this.faces = n),
              (this.faceNormals = i),
              0 === this.faceNormals.length && this.computeNormals(),
              s
                ? (this.boundingSphereRadius = s)
                : this.updateBoundingSphereRadius(),
              (this.worldVertices = []),
              (this.worldVerticesNeedsUpdate = !0),
              (this.worldFaceNormals = []),
              (this.worldFaceNormalsNeedsUpdate = !0),
              (this.uniqueAxes = r ? r.slice() : null),
              (this.uniqueEdges = []),
              this.computeEdges();
          }
          computeEdges() {
            const t = this.faces,
              e = this.vertices,
              n = this.uniqueEdges;
            n.length = 0;
            const i = new tb();
            for (let r = 0; r !== t.length; r++) {
              const s = t[r],
                o = s.length;
              for (let t = 0; t !== o; t++) {
                const r = (t + 1) % o;
                e[s[t]].vsub(e[s[r]], i), i.normalize();
                let a = !1;
                for (let t = 0; t !== n.length; t++)
                  if (n[t].almostEquals(i) || n[t].almostEquals(i)) {
                    a = !0;
                    break;
                  }
                a || n.push(i.clone());
              }
            }
          }
          computeNormals() {
            this.faceNormals.length = this.faces.length;
            for (let t = 0; t < this.faces.length; t++) {
              for (let e = 0; e < this.faces[t].length; e++)
                if (!this.vertices[this.faces[t][e]])
                  throw new Error(`Vertex ${this.faces[t][e]} not found!`);
              const e = this.faceNormals[t] || new tb();
              this.getFaceNormal(t, e), e.negate(e), (this.faceNormals[t] = e);
              const n = this.vertices[this.faces[t][0]];
              if (e.dot(n) < 0) {
                console.error(
                  `.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`
                );
                for (let e = 0; e < this.faces[t].length; e++)
                  console.warn(
                    `.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[
                      this.faces[t][e]
                    ].toString()})`
                  );
              }
            }
          }
          getFaceNormal(t, e) {
            const n = this.faces[t],
              i = this.vertices[n[0]],
              r = this.vertices[n[1]],
              s = this.vertices[n[2]];
            mb.computeNormal(i, r, s, e);
          }
          static computeNormal(t, e, n, i) {
            const r = new tb(),
              s = new tb();
            e.vsub(t, s),
              n.vsub(e, r),
              r.cross(s, i),
              i.isZero() || i.normalize();
          }
          clipAgainstHull(t, e, n, i, r, s, o, a, l) {
            const c = new tb();
            let u = -1,
              h = -Number.MAX_VALUE;
            for (let t = 0; t < n.faces.length; t++) {
              c.copy(n.faceNormals[t]), r.vmult(c, c);
              const e = c.dot(s);
              e > h && ((h = e), (u = t));
            }
            const d = [];
            for (let t = 0; t < n.faces[u].length; t++) {
              const e = n.vertices[n.faces[u][t]],
                s = new tb();
              s.copy(e), r.vmult(s, s), i.vadd(s, s), d.push(s);
            }
            u >= 0 && this.clipFaceAgainstHull(s, t, e, d, o, a, l);
          }
          findSeparatingAxis(t, e, n, i, r, s, o, a) {
            const l = new tb(),
              c = new tb(),
              u = new tb(),
              h = new tb(),
              d = new tb(),
              p = new tb();
            let f = Number.MAX_VALUE;
            const m = this;
            if (m.uniqueAxes)
              for (let o = 0; o !== m.uniqueAxes.length; o++) {
                n.vmult(m.uniqueAxes[o], l);
                const a = m.testSepAxis(l, t, e, n, i, r);
                if (!1 === a) return !1;
                a < f && ((f = a), s.copy(l));
              }
            else {
              const a = o ? o.length : m.faces.length;
              for (let c = 0; c < a; c++) {
                const a = o ? o[c] : c;
                l.copy(m.faceNormals[a]), n.vmult(l, l);
                const u = m.testSepAxis(l, t, e, n, i, r);
                if (!1 === u) return !1;
                u < f && ((f = u), s.copy(l));
              }
            }
            if (t.uniqueAxes)
              for (let o = 0; o !== t.uniqueAxes.length; o++) {
                r.vmult(t.uniqueAxes[o], c);
                const a = m.testSepAxis(c, t, e, n, i, r);
                if (!1 === a) return !1;
                a < f && ((f = a), s.copy(c));
              }
            else {
              const o = a ? a.length : t.faces.length;
              for (let l = 0; l < o; l++) {
                const o = a ? a[l] : l;
                c.copy(t.faceNormals[o]), r.vmult(c, c);
                const u = m.testSepAxis(c, t, e, n, i, r);
                if (!1 === u) return !1;
                u < f && ((f = u), s.copy(c));
              }
            }
            for (let o = 0; o !== m.uniqueEdges.length; o++) {
              n.vmult(m.uniqueEdges[o], h);
              for (let o = 0; o !== t.uniqueEdges.length; o++)
                if (
                  (r.vmult(t.uniqueEdges[o], d), h.cross(d, p), !p.almostZero())
                ) {
                  p.normalize();
                  const o = m.testSepAxis(p, t, e, n, i, r);
                  if (!1 === o) return !1;
                  o < f && ((f = o), s.copy(p));
                }
            }
            return i.vsub(e, u), u.dot(s) > 0 && s.negate(s), !0;
          }
          testSepAxis(t, e, n, i, r, s) {
            mb.project(this, t, n, i, gb), mb.project(e, t, r, s, vb);
            const o = gb[0],
              a = gb[1],
              l = vb[0],
              c = vb[1];
            if (o < c || l < a) return !1;
            const u = o - c,
              h = l - a;
            return u < h ? u : h;
          }
          calculateLocalInertia(t, e) {
            const n = new tb(),
              i = new tb();
            this.computeLocalAABB(i, n);
            const r = n.x - i.x,
              s = n.y - i.y,
              o = n.z - i.z;
            (e.x = (1 / 12) * t * (2 * s * 2 * s + 2 * o * 2 * o)),
              (e.y = (1 / 12) * t * (2 * r * 2 * r + 2 * o * 2 * o)),
              (e.z = (1 / 12) * t * (2 * s * 2 * s + 2 * r * 2 * r));
          }
          getPlaneConstantOfFace(t) {
            const e = this.faces[t],
              n = this.faceNormals[t],
              i = this.vertices[e[0]];
            return -n.dot(i);
          }
          clipFaceAgainstHull(t, e, n, i, r, s, o) {
            const a = new tb(),
              l = new tb(),
              c = new tb(),
              u = new tb(),
              h = new tb(),
              d = new tb(),
              p = new tb(),
              f = new tb(),
              m = this,
              g = i,
              v = [];
            let y = -1,
              _ = Number.MAX_VALUE;
            for (let e = 0; e < m.faces.length; e++) {
              a.copy(m.faceNormals[e]), n.vmult(a, a);
              const i = a.dot(t);
              i < _ && ((_ = i), (y = e));
            }
            if (y < 0) return;
            const x = m.faces[y];
            x.connectedFaces = [];
            for (let t = 0; t < m.faces.length; t++)
              for (let e = 0; e < m.faces[t].length; e++)
                -1 !== x.indexOf(m.faces[t][e]) &&
                  t !== y &&
                  -1 === x.connectedFaces.indexOf(t) &&
                  x.connectedFaces.push(t);
            const b = x.length;
            for (let t = 0; t < b; t++) {
              const i = m.vertices[x[t]],
                r = m.vertices[x[(t + 1) % b]];
              i.vsub(r, l),
                c.copy(l),
                n.vmult(c, c),
                e.vadd(c, c),
                u.copy(this.faceNormals[y]),
                n.vmult(u, u),
                e.vadd(u, u),
                c.cross(u, h),
                h.negate(h),
                d.copy(i),
                n.vmult(d, d),
                e.vadd(d, d);
              const s = x.connectedFaces[t];
              p.copy(this.faceNormals[s]);
              const o = this.getPlaneConstantOfFace(s);
              f.copy(p), n.vmult(f, f);
              const a = o - f.dot(e);
              for (this.clipFaceAgainstPlane(g, v, f, a); g.length; ) g.shift();
              for (; v.length; ) g.push(v.shift());
            }
            p.copy(this.faceNormals[y]);
            const w = this.getPlaneConstantOfFace(y);
            f.copy(p), n.vmult(f, f);
            const E = w - f.dot(e);
            for (let t = 0; t < g.length; t++) {
              let e = f.dot(g[t]) + E;
              if (
                (e <= r &&
                  (console.log(`clamped: depth=${e} to minDist=${r}`), (e = r)),
                e <= s)
              ) {
                const n = g[t];
                if (e <= 1e-6) {
                  const t = {
                    point: n,
                    normal: f,
                    depth: e,
                  };
                  o.push(t);
                }
              }
            }
          }
          clipFaceAgainstPlane(t, e, n, i) {
            let r, s;
            const o = t.length;
            if (o < 2) return e;
            let a = t[t.length - 1],
              l = t[0];
            r = n.dot(a) + i;
            for (let c = 0; c < o; c++) {
              if (((l = t[c]), (s = n.dot(l) + i), r < 0))
                if (s < 0) {
                  const t = new tb();
                  t.copy(l), e.push(t);
                } else {
                  const t = new tb();
                  a.lerp(l, r / (r - s), t), e.push(t);
                }
              else if (s < 0) {
                const t = new tb();
                a.lerp(l, r / (r - s), t), e.push(t), e.push(l);
              }
              (a = l), (r = s);
            }
            return e;
          }
          computeWorldVertices(t, e) {
            for (; this.worldVertices.length < this.vertices.length; )
              this.worldVertices.push(new tb());
            const n = this.vertices,
              i = this.worldVertices;
            for (let r = 0; r !== this.vertices.length; r++)
              e.vmult(n[r], i[r]), t.vadd(i[r], i[r]);
            this.worldVerticesNeedsUpdate = !1;
          }
          computeLocalAABB(t, e) {
            const n = this.vertices;
            t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
              e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            for (let i = 0; i < this.vertices.length; i++) {
              const r = n[i];
              r.x < t.x ? (t.x = r.x) : r.x > e.x && (e.x = r.x),
                r.y < t.y ? (t.y = r.y) : r.y > e.y && (e.y = r.y),
                r.z < t.z ? (t.z = r.z) : r.z > e.z && (e.z = r.z);
            }
          }
          computeWorldFaceNormals(t) {
            const e = this.faceNormals.length;
            for (; this.worldFaceNormals.length < e; )
              this.worldFaceNormals.push(new tb());
            const n = this.faceNormals,
              i = this.worldFaceNormals;
            for (let r = 0; r !== e; r++) t.vmult(n[r], i[r]);
            this.worldFaceNormalsNeedsUpdate = !1;
          }
          updateBoundingSphereRadius() {
            let t = 0;
            const e = this.vertices;
            for (let n = 0; n !== e.length; n++) {
              const i = e[n].lengthSquared();
              i > t && (t = i);
            }
            this.boundingSphereRadius = Math.sqrt(t);
          }
          calculateWorldAABB(t, e, n, i) {
            const r = this.vertices;
            let s,
              o,
              a,
              l,
              c,
              u,
              h = new tb();
            for (let n = 0; n < r.length; n++) {
              h.copy(r[n]), e.vmult(h, h), t.vadd(h, h);
              const i = h;
              (void 0 === s || i.x < s) && (s = i.x),
                (void 0 === l || i.x > l) && (l = i.x),
                (void 0 === o || i.y < o) && (o = i.y),
                (void 0 === c || i.y > c) && (c = i.y),
                (void 0 === a || i.z < a) && (a = i.z),
                (void 0 === u || i.z > u) && (u = i.z);
            }
            n.set(s, o, a), i.set(l, c, u);
          }
          volume() {
            return (4 * Math.PI * this.boundingSphereRadius) / 3;
          }
          getAveragePointLocal(t) {
            void 0 === t && (t = new tb());
            const e = this.vertices;
            for (let n = 0; n < e.length; n++) t.vadd(e[n], t);
            return t.scale(1 / e.length, t), t;
          }
          transformAllPoints(t, e) {
            const n = this.vertices.length,
              i = this.vertices;
            if (e) {
              for (let t = 0; t < n; t++) {
                const n = i[t];
                e.vmult(n, n);
              }
              for (let t = 0; t < this.faceNormals.length; t++) {
                const n = this.faceNormals[t];
                e.vmult(n, n);
              }
            }
            if (t)
              for (let e = 0; e < n; e++) {
                const n = i[e];
                n.vadd(t, n);
              }
          }
          pointIsInside(t) {
            const e = this.vertices,
              n = this.faces,
              i = this.faceNormals,
              r = new tb();
            this.getAveragePointLocal(r);
            for (let s = 0; s < this.faces.length; s++) {
              let o = i[s];
              const a = e[n[s][0]],
                l = new tb();
              t.vsub(a, l);
              const c = o.dot(l),
                u = new tb();
              r.vsub(a, u);
              const h = o.dot(u);
              if ((c < 0 && h > 0) || (c > 0 && h < 0)) return !1;
            }
            return -1;
          }
          static project(t, e, n, i, r) {
            const s = t.vertices.length,
              o = yb;
            let a = 0,
              l = 0;
            const c = _b,
              u = t.vertices;
            c.setZero(),
              pb.vectorToLocalFrame(n, i, e, o),
              pb.pointToLocalFrame(n, i, c, c);
            const h = c.dot(o);
            l = a = u[0].dot(o);
            for (let t = 1; t < s; t++) {
              const e = u[t].dot(o);
              e > a && (a = e), e < l && (l = e);
            }
            if (((l -= h), (a -= h), l > a)) {
              const t = l;
              (l = a), (a = t);
            }
            (r[0] = a), (r[1] = l);
          }
        }
        const gb = [],
          vb = [],
          yb = (new tb(), new tb()),
          _b = new tb();
        class xb extends db {
          constructor(t) {
            super({
              type: db.types.BOX,
            }),
              (this.halfExtents = t),
              (this.convexPolyhedronRepresentation = null),
              this.updateConvexPolyhedronRepresentation(),
              this.updateBoundingSphereRadius();
          }
          updateConvexPolyhedronRepresentation() {
            const t = this.halfExtents.x,
              e = this.halfExtents.y,
              n = this.halfExtents.z,
              i = tb,
              r = [
                new i(-t, -e, -n),
                new i(t, -e, -n),
                new i(t, e, -n),
                new i(-t, e, -n),
                new i(-t, -e, n),
                new i(t, -e, n),
                new i(t, e, n),
                new i(-t, e, n),
              ],
              s = [new i(0, 0, 1), new i(0, 1, 0), new i(1, 0, 0)],
              o = new mb({
                vertices: r,
                faces: [
                  [3, 2, 1, 0],
                  [4, 5, 6, 7],
                  [5, 4, 0, 1],
                  [2, 3, 7, 6],
                  [0, 4, 7, 3],
                  [1, 2, 6, 5],
                ],
                axes: s,
              });
            (this.convexPolyhedronRepresentation = o),
              (o.material = this.material);
          }
          calculateLocalInertia(t, e) {
            return (
              void 0 === e && (e = new tb()),
              xb.calculateInertia(this.halfExtents, t, e),
              e
            );
          }
          static calculateInertia(t, e, n) {
            const i = t;
            (n.x = (1 / 12) * e * (2 * i.y * 2 * i.y + 2 * i.z * 2 * i.z)),
              (n.y = (1 / 12) * e * (2 * i.x * 2 * i.x + 2 * i.z * 2 * i.z)),
              (n.z = (1 / 12) * e * (2 * i.y * 2 * i.y + 2 * i.x * 2 * i.x));
          }
          getSideNormals(t, e) {
            const n = t,
              i = this.halfExtents;
            if (
              (n[0].set(i.x, 0, 0),
              n[1].set(0, i.y, 0),
              n[2].set(0, 0, i.z),
              n[3].set(-i.x, 0, 0),
              n[4].set(0, -i.y, 0),
              n[5].set(0, 0, -i.z),
              void 0 !== e)
            )
              for (let t = 0; t !== n.length; t++) e.vmult(n[t], n[t]);
            return n;
          }
          volume() {
            return (
              8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
            );
          }
          updateBoundingSphereRadius() {
            this.boundingSphereRadius = this.halfExtents.length();
          }
          forEachWorldCorner(t, e, n) {
            const i = this.halfExtents,
              r = [
                [i.x, i.y, i.z],
                [-i.x, i.y, i.z],
                [-i.x, -i.y, i.z],
                [-i.x, -i.y, -i.z],
                [i.x, -i.y, -i.z],
                [i.x, i.y, -i.z],
                [-i.x, i.y, -i.z],
                [i.x, -i.y, i.z],
              ];
            for (let i = 0; i < r.length; i++)
              bb.set(r[i][0], r[i][1], r[i][2]),
                e.vmult(bb, bb),
                t.vadd(bb, bb),
                n(bb.x, bb.y, bb.z);
          }
          calculateWorldAABB(t, e, n, i) {
            const r = this.halfExtents;
            wb[0].set(r.x, r.y, r.z),
              wb[1].set(-r.x, r.y, r.z),
              wb[2].set(-r.x, -r.y, r.z),
              wb[3].set(-r.x, -r.y, -r.z),
              wb[4].set(r.x, -r.y, -r.z),
              wb[5].set(r.x, r.y, -r.z),
              wb[6].set(-r.x, r.y, -r.z),
              wb[7].set(r.x, -r.y, r.z);
            const s = wb[0];
            e.vmult(s, s), t.vadd(s, s), i.copy(s), n.copy(s);
            for (let r = 1; r < 8; r++) {
              const s = wb[r];
              e.vmult(s, s), t.vadd(s, s);
              const o = s.x,
                a = s.y,
                l = s.z;
              o > i.x && (i.x = o),
                a > i.y && (i.y = a),
                l > i.z && (i.z = l),
                o < n.x && (n.x = o),
                a < n.y && (n.y = a),
                l < n.z && (n.z = l);
            }
          }
        }
        const bb = new tb(),
          wb = [
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
            new tb(),
          ],
          Eb = 1,
          Sb = 2,
          Mb = 4,
          Tb = 0,
          Ab = 1,
          Rb = 2;
        class Cb extends lb {
          constructor(t) {
            void 0 === t && (t = {}),
              super(),
              (this.id = Cb.idCounter++),
              (this.index = -1),
              (this.world = null),
              (this.vlambda = new tb()),
              (this.collisionFilterGroup =
                "number" == typeof t.collisionFilterGroup
                  ? t.collisionFilterGroup
                  : 1),
              (this.collisionFilterMask =
                "number" == typeof t.collisionFilterMask
                  ? t.collisionFilterMask
                  : -1),
              (this.collisionResponse =
                "boolean" != typeof t.collisionResponse || t.collisionResponse),
              (this.position = new tb()),
              (this.previousPosition = new tb()),
              (this.interpolatedPosition = new tb()),
              (this.initPosition = new tb()),
              t.position &&
                (this.position.copy(t.position),
                this.previousPosition.copy(t.position),
                this.interpolatedPosition.copy(t.position),
                this.initPosition.copy(t.position)),
              (this.velocity = new tb()),
              t.velocity && this.velocity.copy(t.velocity),
              (this.initVelocity = new tb()),
              (this.force = new tb());
            const e = "number" == typeof t.mass ? t.mass : 0;
            (this.mass = e),
              (this.invMass = e > 0 ? 1 / e : 0),
              (this.material = t.material || null),
              (this.linearDamping =
                "number" == typeof t.linearDamping ? t.linearDamping : 0.01),
              (this.type = e <= 0 ? Cb.STATIC : Cb.DYNAMIC),
              typeof t.type == typeof Cb.STATIC && (this.type = t.type),
              (this.allowSleep = void 0 === t.allowSleep || t.allowSleep),
              (this.sleepState = Cb.AWAKE),
              (this.sleepSpeedLimit =
                void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : 0.1),
              (this.sleepTimeLimit =
                void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1),
              (this.timeLastSleepy = 0),
              (this.wakeUpAfterNarrowphase = !1),
              (this.torque = new tb()),
              (this.quaternion = new cb()),
              (this.initQuaternion = new cb()),
              (this.previousQuaternion = new cb()),
              (this.interpolatedQuaternion = new cb()),
              t.quaternion &&
                (this.quaternion.copy(t.quaternion),
                this.initQuaternion.copy(t.quaternion),
                this.previousQuaternion.copy(t.quaternion),
                this.interpolatedQuaternion.copy(t.quaternion)),
              (this.angularVelocity = new tb()),
              t.angularVelocity && this.angularVelocity.copy(t.angularVelocity),
              (this.initAngularVelocity = new tb()),
              (this.shapes = []),
              (this.shapeOffsets = []),
              (this.shapeOrientations = []),
              (this.inertia = new tb()),
              (this.invInertia = new tb()),
              (this.invInertiaWorld = new Jx()),
              (this.invMassSolve = 0),
              (this.invInertiaSolve = new tb()),
              (this.invInertiaWorldSolve = new Jx()),
              (this.fixedRotation =
                void 0 !== t.fixedRotation && t.fixedRotation),
              (this.angularDamping =
                void 0 !== t.angularDamping ? t.angularDamping : 0.01),
              (this.linearFactor = new tb(1, 1, 1)),
              t.linearFactor && this.linearFactor.copy(t.linearFactor),
              (this.angularFactor = new tb(1, 1, 1)),
              t.angularFactor && this.angularFactor.copy(t.angularFactor),
              (this.aabb = new rb()),
              (this.aabbNeedsUpdate = !0),
              (this.boundingRadius = 0),
              (this.wlambda = new tb()),
              (this.isTrigger = Boolean(t.isTrigger)),
              t.shape && this.addShape(t.shape),
              this.updateMassProperties();
          }
          wakeUp() {
            const t = this.sleepState;
            (this.sleepState = Cb.AWAKE),
              (this.wakeUpAfterNarrowphase = !1),
              t === Cb.SLEEPING && this.dispatchEvent(Cb.wakeupEvent);
          }
          sleep() {
            (this.sleepState = Cb.SLEEPING),
              this.velocity.set(0, 0, 0),
              this.angularVelocity.set(0, 0, 0),
              (this.wakeUpAfterNarrowphase = !1);
          }
          sleepTick(t) {
            if (this.allowSleep) {
              const e = this.sleepState,
                n =
                  this.velocity.lengthSquared() +
                  this.angularVelocity.lengthSquared(),
                i = this.sleepSpeedLimit ** 2;
              e === Cb.AWAKE && n < i
                ? ((this.sleepState = Cb.SLEEPY),
                  (this.timeLastSleepy = t),
                  this.dispatchEvent(Cb.sleepyEvent))
                : e === Cb.SLEEPY && n > i
                ? this.wakeUp()
                : e === Cb.SLEEPY &&
                  t - this.timeLastSleepy > this.sleepTimeLimit &&
                  (this.sleep(), this.dispatchEvent(Cb.sleepEvent));
            }
          }
          updateSolveMassProperties() {
            this.sleepState === Cb.SLEEPING || this.type === Cb.KINEMATIC
              ? ((this.invMassSolve = 0),
                this.invInertiaSolve.setZero(),
                this.invInertiaWorldSolve.setZero())
              : ((this.invMassSolve = this.invMass),
                this.invInertiaSolve.copy(this.invInertia),
                this.invInertiaWorldSolve.copy(this.invInertiaWorld));
          }
          pointToLocalFrame(t, e) {
            return (
              void 0 === e && (e = new tb()),
              t.vsub(this.position, e),
              this.quaternion.conjugate().vmult(e, e),
              e
            );
          }
          vectorToLocalFrame(t, e) {
            return (
              void 0 === e && (e = new tb()),
              this.quaternion.conjugate().vmult(t, e),
              e
            );
          }
          pointToWorldFrame(t, e) {
            return (
              void 0 === e && (e = new tb()),
              this.quaternion.vmult(t, e),
              e.vadd(this.position, e),
              e
            );
          }
          vectorToWorldFrame(t, e) {
            return (
              void 0 === e && (e = new tb()), this.quaternion.vmult(t, e), e
            );
          }
          addShape(t, e, n) {
            const i = new tb(),
              r = new cb();
            return (
              e && i.copy(e),
              n && r.copy(n),
              this.shapes.push(t),
              this.shapeOffsets.push(i),
              this.shapeOrientations.push(r),
              this.updateMassProperties(),
              this.updateBoundingRadius(),
              (this.aabbNeedsUpdate = !0),
              (t.body = this),
              this
            );
          }
          removeShape(t) {
            const e = this.shapes.indexOf(t);
            return -1 === e
              ? (console.warn("Shape does not belong to the body"), this)
              : (this.shapes.splice(e, 1),
                this.shapeOffsets.splice(e, 1),
                this.shapeOrientations.splice(e, 1),
                this.updateMassProperties(),
                this.updateBoundingRadius(),
                (this.aabbNeedsUpdate = !0),
                (t.body = null),
                this);
          }
          updateBoundingRadius() {
            const t = this.shapes,
              e = this.shapeOffsets,
              n = t.length;
            let i = 0;
            for (let r = 0; r !== n; r++) {
              const n = t[r];
              n.updateBoundingSphereRadius();
              const s = e[r].length(),
                o = n.boundingSphereRadius;
              s + o > i && (i = s + o);
            }
            this.boundingRadius = i;
          }
          updateAABB() {
            const t = this.shapes,
              e = this.shapeOffsets,
              n = this.shapeOrientations,
              i = t.length,
              r = Lb,
              s = Pb,
              o = this.quaternion,
              a = this.aabb,
              l = Ob;
            for (let c = 0; c !== i; c++) {
              const i = t[c];
              o.vmult(e[c], r),
                r.vadd(this.position, r),
                o.mult(n[c], s),
                i.calculateWorldAABB(r, s, l.lowerBound, l.upperBound),
                0 === c ? a.copy(l) : a.extend(l);
            }
            this.aabbNeedsUpdate = !1;
          }
          updateInertiaWorld(t) {
            const e = this.invInertia;
            if (e.x !== e.y || e.y !== e.z || t) {
              const t = Ib,
                n = Nb;
              t.setRotationFromQuaternion(this.quaternion),
                t.transpose(n),
                t.scale(e, t),
                t.mmult(n, this.invInertiaWorld);
            } else;
          }
          applyForce(t, e) {
            if ((void 0 === e && (e = new tb()), this.type !== Cb.DYNAMIC))
              return;
            this.sleepState === Cb.SLEEPING && this.wakeUp();
            const n = Db;
            e.cross(t, n),
              this.force.vadd(t, this.force),
              this.torque.vadd(n, this.torque);
          }
          applyLocalForce(t, e) {
            if ((void 0 === e && (e = new tb()), this.type !== Cb.DYNAMIC))
              return;
            const n = Ub,
              i = Fb;
            this.vectorToWorldFrame(t, n),
              this.vectorToWorldFrame(e, i),
              this.applyForce(n, i);
          }
          applyTorque(t) {
            this.type === Cb.DYNAMIC &&
              (this.sleepState === Cb.SLEEPING && this.wakeUp(),
              this.torque.vadd(t, this.torque));
          }
          applyImpulse(t, e) {
            if ((void 0 === e && (e = new tb()), this.type !== Cb.DYNAMIC))
              return;
            this.sleepState === Cb.SLEEPING && this.wakeUp();
            const n = e,
              i = kb;
            i.copy(t),
              i.scale(this.invMass, i),
              this.velocity.vadd(i, this.velocity);
            const r = Bb;
            n.cross(t, r),
              this.invInertiaWorld.vmult(r, r),
              this.angularVelocity.vadd(r, this.angularVelocity);
          }
          applyLocalImpulse(t, e) {
            if ((void 0 === e && (e = new tb()), this.type !== Cb.DYNAMIC))
              return;
            const n = zb,
              i = Hb;
            this.vectorToWorldFrame(t, n),
              this.vectorToWorldFrame(e, i),
              this.applyImpulse(n, i);
          }
          updateMassProperties() {
            const t = Vb;
            this.invMass = this.mass > 0 ? 1 / this.mass : 0;
            const e = this.inertia,
              n = this.fixedRotation;
            this.updateAABB(),
              t.set(
                (this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2,
                (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2,
                (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2
              ),
              xb.calculateInertia(t, this.mass, e),
              this.invInertia.set(
                e.x > 0 && !n ? 1 / e.x : 0,
                e.y > 0 && !n ? 1 / e.y : 0,
                e.z > 0 && !n ? 1 / e.z : 0
              ),
              this.updateInertiaWorld(!0);
          }
          getVelocityAtWorldPoint(t, e) {
            const n = new tb();
            return (
              t.vsub(this.position, n),
              this.angularVelocity.cross(n, e),
              this.velocity.vadd(e, e),
              e
            );
          }
          integrate(t, e, n) {
            if (
              (this.previousPosition.copy(this.position),
              this.previousQuaternion.copy(this.quaternion),
              (this.type !== Cb.DYNAMIC && this.type !== Cb.KINEMATIC) ||
                this.sleepState === Cb.SLEEPING)
            )
              return;
            const i = this.velocity,
              r = this.angularVelocity,
              s = this.position,
              o = this.force,
              a = this.torque,
              l = this.quaternion,
              c = this.invMass,
              u = this.invInertiaWorld,
              h = this.linearFactor,
              d = c * t;
            (i.x += o.x * d * h.x),
              (i.y += o.y * d * h.y),
              (i.z += o.z * d * h.z);
            const p = u.elements,
              f = this.angularFactor,
              m = a.x * f.x,
              g = a.y * f.y,
              v = a.z * f.z;
            (r.x += t * (p[0] * m + p[1] * g + p[2] * v)),
              (r.y += t * (p[3] * m + p[4] * g + p[5] * v)),
              (r.z += t * (p[6] * m + p[7] * g + p[8] * v)),
              (s.x += i.x * t),
              (s.y += i.y * t),
              (s.z += i.z * t),
              l.integrate(this.angularVelocity, t, this.angularFactor, l),
              e && (n ? l.normalizeFast() : l.normalize()),
              (this.aabbNeedsUpdate = !0),
              this.updateInertiaWorld();
          }
        }
        (Cb.idCounter = 0),
          (Cb.COLLIDE_EVENT_NAME = "collide"),
          (Cb.DYNAMIC = Eb),
          (Cb.STATIC = Sb),
          (Cb.KINEMATIC = Mb),
          (Cb.AWAKE = Tb),
          (Cb.SLEEPY = Ab),
          (Cb.SLEEPING = Rb),
          (Cb.wakeupEvent = {
            type: "wakeup",
          }),
          (Cb.sleepyEvent = {
            type: "sleepy",
          }),
          (Cb.sleepEvent = {
            type: "sleep",
          });
        const Lb = new tb(),
          Pb = new cb(),
          Ob = new rb(),
          Ib = new Jx(),
          Nb = new Jx(),
          Db = (new Jx(), new tb()),
          Ub = new tb(),
          Fb = new tb(),
          kb = new tb(),
          Bb = new tb(),
          zb = new tb(),
          Hb = new tb(),
          Vb = new tb();
        class Gb {
          constructor() {
            (this.world = null),
              (this.useBoundingBoxes = !1),
              (this.dirty = !0);
          }
          collisionPairs(t, e, n) {
            throw new Error(
              "collisionPairs not implemented for this BroadPhase class!"
            );
          }
          needBroadphaseCollision(t, e) {
            return (
              !!(
                t.collisionFilterGroup & e.collisionFilterMask &&
                e.collisionFilterGroup & t.collisionFilterMask
              ) &&
              (!(t.type & Cb.STATIC || t.sleepState === Cb.SLEEPING) ||
                !(e.type & Cb.STATIC || e.sleepState === Cb.SLEEPING))
            );
          }
          intersectionTest(t, e, n, i) {
            this.useBoundingBoxes
              ? this.doBoundingBoxBroadphase(t, e, n, i)
              : this.doBoundingSphereBroadphase(t, e, n, i);
          }
          doBoundingSphereBroadphase(t, e, n, i) {
            const r = Wb;
            e.position.vsub(t.position, r);
            const s = (t.boundingRadius + e.boundingRadius) ** 2;
            r.lengthSquared() < s && (n.push(t), i.push(e));
          }
          doBoundingBoxBroadphase(t, e, n, i) {
            t.aabbNeedsUpdate && t.updateAABB(),
              e.aabbNeedsUpdate && e.updateAABB(),
              t.aabb.overlaps(e.aabb) && (n.push(t), i.push(e));
          }
          makePairsUnique(t, e) {
            const n = jb,
              i = qb,
              r = Xb,
              s = t.length;
            for (let n = 0; n !== s; n++) (i[n] = t[n]), (r[n] = e[n]);
            (t.length = 0), (e.length = 0);
            for (let t = 0; t !== s; t++) {
              const e = i[t].id,
                s = r[t].id,
                o = e < s ? `${e},${s}` : `${s},${e}`;
              (n[o] = t), n.keys.push(o);
            }
            for (let s = 0; s !== n.keys.length; s++) {
              const s = n.keys.pop(),
                o = n[s];
              t.push(i[o]), e.push(r[o]), delete n[s];
            }
          }
          setWorld(t) {}
          static boundingSphereCheck(t, e) {
            const n = new tb();
            t.position.vsub(e.position, n);
            const i = t.shapes[0],
              r = e.shapes[0];
            return (
              Math.pow(i.boundingSphereRadius + r.boundingSphereRadius, 2) >
              n.lengthSquared()
            );
          }
          aabbQuery(t, e, n) {
            return (
              console.warn(
                ".aabbQuery is not implemented in this Broadphase subclass."
              ),
              []
            );
          }
        }
        const Wb = new tb();
        new tb(), new cb(), new tb();
        const jb = {
            keys: [],
          },
          qb = [],
          Xb = [];
        new tb();
        new tb();
        new tb();
        class Yb extends Gb {
          constructor() {
            super();
          }
          collisionPairs(t, e, n) {
            const i = t.bodies,
              r = i.length;
            let s, o;
            for (let t = 0; t !== r; t++)
              for (let r = 0; r !== t; r++)
                (s = i[t]),
                  (o = i[r]),
                  this.needBroadphaseCollision(s, o) &&
                    this.intersectionTest(s, o, e, n);
          }
          aabbQuery(t, e, n) {
            void 0 === n && (n = []);
            for (let i = 0; i < t.bodies.length; i++) {
              const r = t.bodies[i];
              r.aabbNeedsUpdate && r.updateAABB(),
                r.aabb.overlaps(e) && n.push(r);
            }
            return n;
          }
        }
        class Kb {
          constructor() {
            (this.rayFromWorld = new tb()),
              (this.rayToWorld = new tb()),
              (this.hitNormalWorld = new tb()),
              (this.hitPointWorld = new tb()),
              (this.hasHit = !1),
              (this.shape = null),
              (this.body = null),
              (this.hitFaceIndex = -1),
              (this.distance = -1),
              (this.shouldStop = !1);
          }
          reset() {
            this.rayFromWorld.setZero(),
              this.rayToWorld.setZero(),
              this.hitNormalWorld.setZero(),
              this.hitPointWorld.setZero(),
              (this.hasHit = !1),
              (this.shape = null),
              (this.body = null),
              (this.hitFaceIndex = -1),
              (this.distance = -1),
              (this.shouldStop = !1);
          }
          abort() {
            this.shouldStop = !0;
          }
          set(t, e, n, i, r, s, o) {
            this.rayFromWorld.copy(t),
              this.rayToWorld.copy(e),
              this.hitNormalWorld.copy(n),
              this.hitPointWorld.copy(i),
              (this.shape = r),
              (this.body = s),
              (this.distance = o);
          }
        }
        let $b, Zb, Jb, Qb, tw, ew, nw;
        const iw = 1,
          rw = 2,
          sw = 4;
        ($b = db.types.SPHERE),
          (Zb = db.types.PLANE),
          (Jb = db.types.BOX),
          (Qb = db.types.CYLINDER),
          (tw = db.types.CONVEXPOLYHEDRON),
          (ew = db.types.HEIGHTFIELD),
          (nw = db.types.TRIMESH);
        class ow {
          get [$b]() {
            return this._intersectSphere;
          }
          get [Zb]() {
            return this._intersectPlane;
          }
          get [Jb]() {
            return this._intersectBox;
          }
          get [Qb]() {
            return this._intersectConvex;
          }
          get [tw]() {
            return this._intersectConvex;
          }
          get [ew]() {
            return this._intersectHeightfield;
          }
          get [nw]() {
            return this._intersectTrimesh;
          }
          constructor(t, e) {
            void 0 === t && (t = new tb()),
              void 0 === e && (e = new tb()),
              (this.from = t.clone()),
              (this.to = e.clone()),
              (this.direction = new tb()),
              (this.precision = 1e-4),
              (this.checkCollisionResponse = !0),
              (this.skipBackfaces = !1),
              (this.collisionFilterMask = -1),
              (this.collisionFilterGroup = -1),
              (this.mode = ow.ANY),
              (this.result = new Kb()),
              (this.hasHit = !1),
              (this.callback = (t) => {});
          }
          intersectWorld(t, e) {
            return (
              (this.mode = e.mode || ow.ANY),
              (this.result = e.result || new Kb()),
              (this.skipBackfaces = !!e.skipBackfaces),
              (this.collisionFilterMask =
                void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1),
              (this.collisionFilterGroup =
                void 0 !== e.collisionFilterGroup
                  ? e.collisionFilterGroup
                  : -1),
              (this.checkCollisionResponse =
                void 0 === e.checkCollisionResponse ||
                e.checkCollisionResponse),
              e.from && this.from.copy(e.from),
              e.to && this.to.copy(e.to),
              (this.callback = e.callback || (() => {})),
              (this.hasHit = !1),
              this.result.reset(),
              this.updateDirection(),
              this.getAABB(aw),
              (lw.length = 0),
              t.broadphase.aabbQuery(t, aw, lw),
              this.intersectBodies(lw),
              this.hasHit
            );
          }
          intersectBody(t, e) {
            e && ((this.result = e), this.updateDirection());
            const n = this.checkCollisionResponse;
            if (n && !t.collisionResponse) return;
            if (
              !(
                this.collisionFilterGroup & t.collisionFilterMask &&
                t.collisionFilterGroup & this.collisionFilterMask
              )
            )
              return;
            const i = hw,
              r = dw;
            for (let e = 0, s = t.shapes.length; e < s; e++) {
              const s = t.shapes[e];
              if (
                (!n || s.collisionResponse) &&
                (t.quaternion.mult(t.shapeOrientations[e], r),
                t.quaternion.vmult(t.shapeOffsets[e], i),
                i.vadd(t.position, i),
                this.intersectShape(s, r, i, t),
                this.result.shouldStop)
              )
                break;
            }
          }
          intersectBodies(t, e) {
            e && ((this.result = e), this.updateDirection());
            for (let e = 0, n = t.length; !this.result.shouldStop && e < n; e++)
              this.intersectBody(t[e]);
          }
          updateDirection() {
            this.to.vsub(this.from, this.direction), this.direction.normalize();
          }
          intersectShape(t, e, n, i) {
            const r = (function (t, e, n) {
              n.vsub(t, Iw);
              const i = Iw.dot(e);
              e.scale(i, Nw), Nw.vadd(t, Nw);
              const r = n.distanceTo(Nw);
              return r;
            })(this.from, this.direction, n);
            if (r > t.boundingSphereRadius) return;
            const s = this[t.type];
            s && s.call(this, t, e, n, i, t);
          }
          _intersectBox(t, e, n, i, r) {
            return this._intersectConvex(
              t.convexPolyhedronRepresentation,
              e,
              n,
              i,
              r
            );
          }
          _intersectPlane(t, e, n, i, r) {
            const s = this.from,
              o = this.to,
              a = this.direction,
              l = new tb(0, 0, 1);
            e.vmult(l, l);
            const c = new tb();
            s.vsub(n, c);
            const u = c.dot(l);
            o.vsub(n, c);
            if (u * c.dot(l) > 0) return;
            if (s.distanceTo(o) < u) return;
            const h = l.dot(a);
            if (Math.abs(h) < this.precision) return;
            const d = new tb(),
              p = new tb(),
              f = new tb();
            s.vsub(n, d);
            const m = -l.dot(d) / h;
            a.scale(m, p),
              s.vadd(p, f),
              this.reportIntersection(l, f, r, i, -1);
          }
          getAABB(t) {
            const { lowerBound: e, upperBound: n } = t,
              i = this.to,
              r = this.from;
            (e.x = Math.min(i.x, r.x)),
              (e.y = Math.min(i.y, r.y)),
              (e.z = Math.min(i.z, r.z)),
              (n.x = Math.max(i.x, r.x)),
              (n.y = Math.max(i.y, r.y)),
              (n.z = Math.max(i.z, r.z));
          }
          _intersectHeightfield(t, e, n, i, r) {
            t.data, t.elementSize;
            const s = _w;
            s.from.copy(this.from),
              s.to.copy(this.to),
              pb.pointToLocalFrame(n, e, s.from, s.from),
              pb.pointToLocalFrame(n, e, s.to, s.to),
              s.updateDirection();
            const o = xw;
            let a, l, c, u;
            (a = l = 0), (c = u = t.data.length - 1);
            const h = new rb();
            s.getAABB(h),
              t.getIndexOfPosition(h.lowerBound.x, h.lowerBound.y, o, !0),
              (a = Math.max(a, o[0])),
              (l = Math.max(l, o[1])),
              t.getIndexOfPosition(h.upperBound.x, h.upperBound.y, o, !0),
              (c = Math.min(c, o[0] + 1)),
              (u = Math.min(u, o[1] + 1));
            for (let o = a; o < c; o++)
              for (let a = l; a < u; a++) {
                if (this.result.shouldStop) return;
                if ((t.getAabbAtIndex(o, a, h), h.overlapsRay(s))) {
                  if (
                    (t.getConvexTrianglePillar(o, a, !1),
                    pb.pointToWorldFrame(n, e, t.pillarOffset, yw),
                    this._intersectConvex(t.pillarConvex, e, yw, i, r, vw),
                    this.result.shouldStop)
                  )
                    return;
                  t.getConvexTrianglePillar(o, a, !0),
                    pb.pointToWorldFrame(n, e, t.pillarOffset, yw),
                    this._intersectConvex(t.pillarConvex, e, yw, i, r, vw);
                }
              }
          }
          _intersectSphere(t, e, n, i, r) {
            const s = this.from,
              o = this.to,
              a = t.radius,
              l = (o.x - s.x) ** 2 + (o.y - s.y) ** 2 + (o.z - s.z) ** 2,
              c =
                2 *
                ((o.x - s.x) * (s.x - n.x) +
                  (o.y - s.y) * (s.y - n.y) +
                  (o.z - s.z) * (s.z - n.z)),
              u =
                c ** 2 -
                4 *
                  l *
                  ((s.x - n.x) ** 2 +
                    (s.y - n.y) ** 2 +
                    (s.z - n.z) ** 2 -
                    a ** 2),
              h = bw,
              d = ww;
            if (!(u < 0))
              if (0 === u)
                s.lerp(o, u, h),
                  h.vsub(n, d),
                  d.normalize(),
                  this.reportIntersection(d, h, r, i, -1);
              else {
                const t = (-c - Math.sqrt(u)) / (2 * l),
                  e = (-c + Math.sqrt(u)) / (2 * l);
                if (
                  (t >= 0 &&
                    t <= 1 &&
                    (s.lerp(o, t, h),
                    h.vsub(n, d),
                    d.normalize(),
                    this.reportIntersection(d, h, r, i, -1)),
                  this.result.shouldStop)
                )
                  return;
                e >= 0 &&
                  e <= 1 &&
                  (s.lerp(o, e, h),
                  h.vsub(n, d),
                  d.normalize(),
                  this.reportIntersection(d, h, r, i, -1));
              }
          }
          _intersectConvex(t, e, n, i, r, s) {
            const o = Ew,
              a = Sw,
              l = (s && s.faceList) || null,
              c = t.faces,
              u = t.vertices,
              h = t.faceNormals,
              d = this.direction,
              p = this.from,
              f = this.to,
              m = p.distanceTo(f),
              g = l ? l.length : c.length,
              v = this.result;
            for (let t = 0; !v.shouldStop && t < g; t++) {
              const s = l ? l[t] : t,
                f = c[s],
                g = h[s],
                y = e,
                _ = n;
              a.copy(u[f[0]]),
                y.vmult(a, a),
                a.vadd(_, a),
                a.vsub(p, a),
                y.vmult(g, o);
              const x = d.dot(o);
              if (Math.abs(x) < this.precision) continue;
              const b = o.dot(a) / x;
              if (!(b < 0)) {
                d.scale(b, pw),
                  pw.vadd(p, pw),
                  fw.copy(u[f[0]]),
                  y.vmult(fw, fw),
                  _.vadd(fw, fw);
                for (let t = 1; !v.shouldStop && t < f.length - 1; t++) {
                  mw.copy(u[f[t]]),
                    gw.copy(u[f[t + 1]]),
                    y.vmult(mw, mw),
                    y.vmult(gw, gw),
                    _.vadd(mw, mw),
                    _.vadd(gw, gw);
                  const e = pw.distanceTo(p);
                  (!ow.pointInTriangle(pw, fw, mw, gw) &&
                    !ow.pointInTriangle(pw, mw, fw, gw)) ||
                    e > m ||
                    this.reportIntersection(o, pw, r, i, s);
                }
              }
            }
          }
          _intersectTrimesh(t, e, n, i, r, s) {
            const o = Mw,
              a = Pw,
              l = Ow,
              c = Sw,
              u = Tw,
              h = Aw,
              d = Rw,
              p = Lw,
              f = Cw,
              m = t.indices;
            t.vertices;
            const g = this.from,
              v = this.to,
              y = this.direction;
            l.position.copy(n),
              l.quaternion.copy(e),
              pb.vectorToLocalFrame(n, e, y, u),
              pb.pointToLocalFrame(n, e, g, h),
              pb.pointToLocalFrame(n, e, v, d),
              (d.x *= t.scale.x),
              (d.y *= t.scale.y),
              (d.z *= t.scale.z),
              (h.x *= t.scale.x),
              (h.y *= t.scale.y),
              (h.z *= t.scale.z),
              d.vsub(h, u),
              u.normalize();
            const _ = h.distanceSquared(d);
            t.tree.rayQuery(this, l, a);
            for (
              let s = 0, l = a.length;
              !this.result.shouldStop && s !== l;
              s++
            ) {
              const l = a[s];
              t.getNormal(l, o), t.getVertex(m[3 * l], fw), fw.vsub(h, c);
              const d = u.dot(o),
                g = o.dot(c) / d;
              if (g < 0) continue;
              u.scale(g, pw),
                pw.vadd(h, pw),
                t.getVertex(m[3 * l + 1], mw),
                t.getVertex(m[3 * l + 2], gw);
              const v = pw.distanceSquared(h);
              (!ow.pointInTriangle(pw, mw, fw, gw) &&
                !ow.pointInTriangle(pw, fw, mw, gw)) ||
                v > _ ||
                (pb.vectorToWorldFrame(e, o, f),
                pb.pointToWorldFrame(n, e, pw, p),
                this.reportIntersection(f, p, r, i, l));
            }
            a.length = 0;
          }
          reportIntersection(t, e, n, i, r) {
            const s = this.from,
              o = this.to,
              a = s.distanceTo(e),
              l = this.result;
            if (!(this.skipBackfaces && t.dot(this.direction) > 0))
              switch (((l.hitFaceIndex = void 0 !== r ? r : -1), this.mode)) {
                case ow.ALL:
                  (this.hasHit = !0),
                    l.set(s, o, t, e, n, i, a),
                    (l.hasHit = !0),
                    this.callback(l);
                  break;
                case ow.CLOSEST:
                  (a < l.distance || !l.hasHit) &&
                    ((this.hasHit = !0),
                    (l.hasHit = !0),
                    l.set(s, o, t, e, n, i, a));
                  break;
                case ow.ANY:
                  (this.hasHit = !0),
                    (l.hasHit = !0),
                    l.set(s, o, t, e, n, i, a),
                    (l.shouldStop = !0);
              }
          }
          static pointInTriangle(t, e, n, i) {
            i.vsub(e, Iw), n.vsub(e, cw), t.vsub(e, uw);
            const r = Iw.dot(Iw),
              s = Iw.dot(cw),
              o = Iw.dot(uw),
              a = cw.dot(cw),
              l = cw.dot(uw);
            let c, u;
            return (
              (c = a * o - s * l) >= 0 &&
              (u = r * l - s * o) >= 0 &&
              c + u < r * a - s * s
            );
          }
        }
        (ow.CLOSEST = iw), (ow.ANY = rw), (ow.ALL = sw);
        const aw = new rb(),
          lw = [],
          cw = new tb(),
          uw = new tb(),
          hw = new tb(),
          dw = new cb(),
          pw = new tb(),
          fw = new tb(),
          mw = new tb(),
          gw = new tb();
        new tb(), new Kb();
        const vw = {
            faceList: [0],
          },
          yw = new tb(),
          _w = new ow(),
          xw = [],
          bw = new tb(),
          ww = new tb(),
          Ew = new tb(),
          Sw = (new tb(), new tb(), new tb()),
          Mw = new tb(),
          Tw = new tb(),
          Aw = new tb(),
          Rw = new tb(),
          Cw = new tb(),
          Lw = new tb();
        new rb();
        const Pw = [],
          Ow = new pb(),
          Iw = new tb(),
          Nw = new tb();
        class Dw {
          static defaults(t, e) {
            void 0 === t && (t = {});
            for (let n in e) n in t || (t[n] = e[n]);
            return t;
          }
        }
        class Uw {
          constructor(t, e, n) {
            void 0 === n && (n = {}),
              (n = Dw.defaults(n, {
                collideConnected: !0,
                wakeUpBodies: !0,
              })),
              (this.equations = []),
              (this.bodyA = t),
              (this.bodyB = e),
              (this.id = Uw.idCounter++),
              (this.collideConnected = n.collideConnected),
              n.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp());
          }
          update() {
            throw new Error(
              "method update() not implmemented in this Constraint subclass!"
            );
          }
          enable() {
            const t = this.equations;
            for (let e = 0; e < t.length; e++) t[e].enabled = !0;
          }
          disable() {
            const t = this.equations;
            for (let e = 0; e < t.length; e++) t[e].enabled = !1;
          }
        }
        Uw.idCounter = 0;
        class Fw {
          constructor() {
            (this.spatial = new tb()), (this.rotational = new tb());
          }
          multiplyElement(t) {
            return (
              t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational)
            );
          }
          multiplyVectors(t, e) {
            return t.dot(this.spatial) + e.dot(this.rotational);
          }
        }
        class kw {
          constructor(t, e, n, i) {
            void 0 === n && (n = -1e6),
              void 0 === i && (i = 1e6),
              (this.id = kw.idCounter++),
              (this.minForce = n),
              (this.maxForce = i),
              (this.bi = t),
              (this.bj = e),
              (this.a = 0),
              (this.b = 0),
              (this.eps = 0),
              (this.jacobianElementA = new Fw()),
              (this.jacobianElementB = new Fw()),
              (this.enabled = !0),
              (this.multiplier = 0),
              this.setSpookParams(1e7, 4, 1 / 60);
          }
          setSpookParams(t, e, n) {
            const i = e,
              r = t,
              s = n;
            (this.a = 4 / (s * (1 + 4 * i))),
              (this.b = (4 * i) / (1 + 4 * i)),
              (this.eps = 4 / (s * s * r * (1 + 4 * i)));
          }
          computeB(t, e, n) {
            const i = this.computeGW();
            return -this.computeGq() * t - i * e - this.computeGiMf() * n;
          }
          computeGq() {
            const t = this.jacobianElementA,
              e = this.jacobianElementB,
              n = this.bi,
              i = this.bj,
              r = n.position,
              s = i.position;
            return t.spatial.dot(r) + e.spatial.dot(s);
          }
          computeGW() {
            const t = this.jacobianElementA,
              e = this.jacobianElementB,
              n = this.bi,
              i = this.bj,
              r = n.velocity,
              s = i.velocity,
              o = n.angularVelocity,
              a = i.angularVelocity;
            return t.multiplyVectors(r, o) + e.multiplyVectors(s, a);
          }
          computeGWlambda() {
            const t = this.jacobianElementA,
              e = this.jacobianElementB,
              n = this.bi,
              i = this.bj,
              r = n.vlambda,
              s = i.vlambda,
              o = n.wlambda,
              a = i.wlambda;
            return t.multiplyVectors(r, o) + e.multiplyVectors(s, a);
          }
          computeGiMf() {
            const t = this.jacobianElementA,
              e = this.jacobianElementB,
              n = this.bi,
              i = this.bj,
              r = n.force,
              s = n.torque,
              o = i.force,
              a = i.torque,
              l = n.invMassSolve,
              c = i.invMassSolve;
            return (
              r.scale(l, Bw),
              o.scale(c, zw),
              n.invInertiaWorldSolve.vmult(s, Hw),
              i.invInertiaWorldSolve.vmult(a, Vw),
              t.multiplyVectors(Bw, Hw) + e.multiplyVectors(zw, Vw)
            );
          }
          computeGiMGt() {
            const t = this.jacobianElementA,
              e = this.jacobianElementB,
              n = this.bi,
              i = this.bj,
              r = n.invMassSolve,
              s = i.invMassSolve,
              o = n.invInertiaWorldSolve,
              a = i.invInertiaWorldSolve;
            let l = r + s;
            return (
              o.vmult(t.rotational, Gw),
              (l += Gw.dot(t.rotational)),
              a.vmult(e.rotational, Gw),
              (l += Gw.dot(e.rotational)),
              l
            );
          }
          addToWlambda(t) {
            const e = this.jacobianElementA,
              n = this.jacobianElementB,
              i = this.bi,
              r = this.bj,
              s = Ww;
            i.vlambda.addScaledVector(i.invMassSolve * t, e.spatial, i.vlambda),
              r.vlambda.addScaledVector(
                r.invMassSolve * t,
                n.spatial,
                r.vlambda
              ),
              i.invInertiaWorldSolve.vmult(e.rotational, s),
              i.wlambda.addScaledVector(t, s, i.wlambda),
              r.invInertiaWorldSolve.vmult(n.rotational, s),
              r.wlambda.addScaledVector(t, s, r.wlambda);
          }
          computeC() {
            return this.computeGiMGt() + this.eps;
          }
        }
        kw.idCounter = 0;
        const Bw = new tb(),
          zw = new tb(),
          Hw = new tb(),
          Vw = new tb(),
          Gw = new tb(),
          Ww = new tb();
        class jw extends kw {
          constructor(t, e, n) {
            void 0 === n && (n = 1e6),
              super(t, e, 0, n),
              (this.restitution = 0),
              (this.ri = new tb()),
              (this.rj = new tb()),
              (this.ni = new tb());
          }
          computeB(t) {
            const e = this.a,
              n = this.b,
              i = this.bi,
              r = this.bj,
              s = this.ri,
              o = this.rj,
              a = qw,
              l = Xw,
              c = i.velocity,
              u = i.angularVelocity;
            i.force, i.torque;
            const h = r.velocity,
              d = r.angularVelocity;
            r.force, r.torque;
            const p = Yw,
              f = this.jacobianElementA,
              m = this.jacobianElementB,
              g = this.ni;
            s.cross(g, a),
              o.cross(g, l),
              g.negate(f.spatial),
              a.negate(f.rotational),
              m.spatial.copy(g),
              m.rotational.copy(l),
              p.copy(r.position),
              p.vadd(o, p),
              p.vsub(i.position, p),
              p.vsub(s, p);
            const v = g.dot(p),
              y = this.restitution + 1;
            return (
              -v * e -
              (y * h.dot(g) - y * c.dot(g) + d.dot(l) - u.dot(a)) * n -
              t * this.computeGiMf()
            );
          }
          getImpactVelocityAlongNormal() {
            const t = Kw,
              e = $w,
              n = Zw,
              i = Jw,
              r = Qw;
            return (
              this.bi.position.vadd(this.ri, n),
              this.bj.position.vadd(this.rj, i),
              this.bi.getVelocityAtWorldPoint(n, t),
              this.bj.getVelocityAtWorldPoint(i, e),
              t.vsub(e, r),
              this.ni.dot(r)
            );
          }
        }
        const qw = new tb(),
          Xw = new tb(),
          Yw = new tb(),
          Kw = new tb(),
          $w = new tb(),
          Zw = new tb(),
          Jw = new tb(),
          Qw = new tb();
        new tb(), new tb();
        new tb(), new tb();
        new tb(), new tb();
        new tb(), new tb();
        new tb(), new tb();
        class tE extends kw {
          constructor(t, e, n) {
            super(t, e, -n, n),
              (this.ri = new tb()),
              (this.rj = new tb()),
              (this.t = new tb());
          }
          computeB(t) {
            this.a;
            const e = this.b;
            this.bi, this.bj;
            const n = this.ri,
              i = this.rj,
              r = eE,
              s = nE,
              o = this.t;
            n.cross(o, r), i.cross(o, s);
            const a = this.jacobianElementA,
              l = this.jacobianElementB;
            o.negate(a.spatial),
              r.negate(a.rotational),
              l.spatial.copy(o),
              l.rotational.copy(s);
            return -this.computeGW() * e - t * this.computeGiMf();
          }
        }
        const eE = new tb(),
          nE = new tb();
        class iE {
          constructor(t, e, n) {
            (n = Dw.defaults(n, {
              friction: 0.3,
              restitution: 0.3,
              contactEquationStiffness: 1e7,
              contactEquationRelaxation: 3,
              frictionEquationStiffness: 1e7,
              frictionEquationRelaxation: 3,
            })),
              (this.id = iE.idCounter++),
              (this.materials = [t, e]),
              (this.friction = n.friction),
              (this.restitution = n.restitution),
              (this.contactEquationStiffness = n.contactEquationStiffness),
              (this.contactEquationRelaxation = n.contactEquationRelaxation),
              (this.frictionEquationStiffness = n.frictionEquationStiffness),
              (this.frictionEquationRelaxation = n.frictionEquationRelaxation);
          }
        }
        iE.idCounter = 0;
        class rE {
          constructor(t) {
            void 0 === t && (t = {});
            let e = "";
            "string" == typeof t && ((e = t), (t = {})),
              (this.name = e),
              (this.id = rE.idCounter++),
              (this.friction = void 0 !== t.friction ? t.friction : -1),
              (this.restitution =
                void 0 !== t.restitution ? t.restitution : -1);
          }
        }
        rE.idCounter = 0;
        new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb();
        new tb(), new tb();
        new tb(), new tb(), new tb();
        new tb(), new tb(), new tb();
        new ow(), new tb();
        new tb(),
          new tb(),
          new tb(1, 0, 0),
          new tb(0, 1, 0),
          new tb(0, 0, 1),
          new tb(),
          new tb(),
          new tb(),
          new tb();
        new tb(), new tb(), new tb(), new tb();
        new tb(), new tb(), new tb();
        new tb(), new tb();
        new tb(), new tb(), new tb(), new tb(), new tb(), new tb(), new tb();
        new tb();
        new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb();
        new tb(), new rb();
        new tb(),
          new rb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new tb(),
          new rb(),
          new tb(),
          new pb(),
          new rb();
        class sE {
          constructor() {
            this.equations = [];
          }
          solve(t, e) {
            return 0;
          }
          addEquation(t) {
            !t.enabled ||
              t.bi.isTrigger ||
              t.bj.isTrigger ||
              this.equations.push(t);
          }
          removeEquation(t) {
            const e = this.equations,
              n = e.indexOf(t);
            -1 !== n && e.splice(n, 1);
          }
          removeAllEquations() {
            this.equations.length = 0;
          }
        }
        class oE extends sE {
          constructor() {
            super(), (this.iterations = 10), (this.tolerance = 1e-7);
          }
          solve(t, e) {
            let n = 0;
            const i = this.iterations,
              r = this.tolerance * this.tolerance,
              s = this.equations,
              o = s.length,
              a = e.bodies,
              l = a.length,
              c = t;
            let u, h, d, p, f, m;
            if (0 !== o)
              for (let t = 0; t !== l; t++) a[t].updateSolveMassProperties();
            const g = lE,
              v = cE,
              y = aE;
            (g.length = o), (v.length = o), (y.length = o);
            for (let t = 0; t !== o; t++) {
              const e = s[t];
              (y[t] = 0), (v[t] = e.computeB(c)), (g[t] = 1 / e.computeC());
            }
            if (0 !== o) {
              for (let t = 0; t !== l; t++) {
                const e = a[t],
                  n = e.vlambda,
                  i = e.wlambda;
                n.set(0, 0, 0), i.set(0, 0, 0);
              }
              for (n = 0; n !== i; n++) {
                p = 0;
                for (let t = 0; t !== o; t++) {
                  const e = s[t];
                  (u = v[t]),
                    (h = g[t]),
                    (m = y[t]),
                    (f = e.computeGWlambda()),
                    (d = h * (u - f - e.eps * m)),
                    m + d < e.minForce
                      ? (d = e.minForce - m)
                      : m + d > e.maxForce && (d = e.maxForce - m),
                    (y[t] += d),
                    (p += d > 0 ? d : -d),
                    e.addToWlambda(d);
                }
                if (p * p < r) break;
              }
              for (let t = 0; t !== l; t++) {
                const e = a[t],
                  n = e.velocity,
                  i = e.angularVelocity;
                e.vlambda.vmul(e.linearFactor, e.vlambda),
                  n.vadd(e.vlambda, n),
                  e.wlambda.vmul(e.angularFactor, e.wlambda),
                  i.vadd(e.wlambda, i);
              }
              let t = s.length;
              const e = 1 / c;
              for (; t--; ) s[t].multiplier = y[t] * e;
            }
            return n;
          }
        }
        const aE = [],
          lE = [],
          cE = [];
        Cb.STATIC;
        class uE {
          constructor() {
            (this.objects = []), (this.type = Object);
          }
          release() {
            const t = arguments.length;
            for (let e = 0; e !== t; e++)
              this.objects.push(
                e < 0 || arguments.length <= e ? void 0 : arguments[e]
              );
            return this;
          }
          get() {
            return 0 === this.objects.length
              ? this.constructObject()
              : this.objects.pop();
          }
          constructObject() {
            throw new Error(
              "constructObject() not implemented in this Pool subclass yet!"
            );
          }
          resize(t) {
            const e = this.objects;
            for (; e.length > t; ) e.pop();
            for (; e.length < t; ) e.push(this.constructObject());
            return this;
          }
        }
        class hE extends uE {
          constructor() {
            super(...arguments), (this.type = tb);
          }
          constructObject() {
            return new tb();
          }
        }
        const dE = db.types.SPHERE,
          pE = db.types.SPHERE | db.types.PLANE,
          fE = db.types.BOX | db.types.BOX,
          mE = db.types.SPHERE | db.types.BOX,
          gE = db.types.PLANE | db.types.BOX,
          vE = db.types.CONVEXPOLYHEDRON,
          yE = db.types.SPHERE | db.types.CONVEXPOLYHEDRON,
          _E = db.types.PLANE | db.types.CONVEXPOLYHEDRON,
          xE = db.types.BOX | db.types.CONVEXPOLYHEDRON,
          bE = db.types.SPHERE | db.types.HEIGHTFIELD,
          wE = db.types.BOX | db.types.HEIGHTFIELD,
          EE = db.types.CONVEXPOLYHEDRON | db.types.HEIGHTFIELD,
          SE = db.types.PARTICLE | db.types.SPHERE,
          ME = db.types.PLANE | db.types.PARTICLE,
          TE = db.types.BOX | db.types.PARTICLE,
          AE = db.types.PARTICLE | db.types.CONVEXPOLYHEDRON,
          RE = db.types.CYLINDER,
          CE = db.types.SPHERE | db.types.CYLINDER,
          LE = db.types.PLANE | db.types.CYLINDER,
          PE = db.types.BOX | db.types.CYLINDER,
          OE = db.types.CONVEXPOLYHEDRON | db.types.CYLINDER,
          IE = db.types.HEIGHTFIELD | db.types.CYLINDER,
          NE = db.types.PARTICLE | db.types.CYLINDER,
          DE = db.types.SPHERE | db.types.TRIMESH,
          UE = db.types.PLANE | db.types.TRIMESH;
        class FE {
          get [dE]() {
            return this.sphereSphere;
          }
          get [pE]() {
            return this.spherePlane;
          }
          get [fE]() {
            return this.boxBox;
          }
          get [mE]() {
            return this.sphereBox;
          }
          get [gE]() {
            return this.planeBox;
          }
          get [vE]() {
            return this.convexConvex;
          }
          get [yE]() {
            return this.sphereConvex;
          }
          get [_E]() {
            return this.planeConvex;
          }
          get [xE]() {
            return this.boxConvex;
          }
          get [bE]() {
            return this.sphereHeightfield;
          }
          get [wE]() {
            return this.boxHeightfield;
          }
          get [EE]() {
            return this.convexHeightfield;
          }
          get [SE]() {
            return this.sphereParticle;
          }
          get [ME]() {
            return this.planeParticle;
          }
          get [TE]() {
            return this.boxParticle;
          }
          get [AE]() {
            return this.convexParticle;
          }
          get [RE]() {
            return this.convexConvex;
          }
          get [CE]() {
            return this.sphereConvex;
          }
          get [LE]() {
            return this.planeConvex;
          }
          get [PE]() {
            return this.boxConvex;
          }
          get [OE]() {
            return this.convexConvex;
          }
          get [IE]() {
            return this.heightfieldCylinder;
          }
          get [NE]() {
            return this.particleCylinder;
          }
          get [DE]() {
            return this.sphereTrimesh;
          }
          get [UE]() {
            return this.planeTrimesh;
          }
          constructor(t) {
            (this.contactPointPool = []),
              (this.frictionEquationPool = []),
              (this.result = []),
              (this.frictionResult = []),
              (this.v3pool = new hE()),
              (this.world = t),
              (this.currentContactMaterial = t.defaultContactMaterial),
              (this.enableFrictionReduction = !1);
          }
          createContactEquation(t, e, n, i, r, s) {
            let o;
            this.contactPointPool.length
              ? ((o = this.contactPointPool.pop()), (o.bi = t), (o.bj = e))
              : (o = new jw(t, e)),
              (o.enabled =
                t.collisionResponse &&
                e.collisionResponse &&
                n.collisionResponse &&
                i.collisionResponse);
            const a = this.currentContactMaterial;
            (o.restitution = a.restitution),
              o.setSpookParams(
                a.contactEquationStiffness,
                a.contactEquationRelaxation,
                this.world.dt
              );
            const l = n.material || t.material,
              c = i.material || e.material;
            return (
              l &&
                c &&
                l.restitution >= 0 &&
                c.restitution >= 0 &&
                (o.restitution = l.restitution * c.restitution),
              (o.si = r || n),
              (o.sj = s || i),
              o
            );
          }
          createFrictionEquationsFromContact(t, e) {
            const n = t.bi,
              i = t.bj,
              r = t.si,
              s = t.sj,
              o = this.world,
              a = this.currentContactMaterial;
            let l = a.friction;
            const c = r.material || n.material,
              u = s.material || i.material;
            if (
              (c &&
                u &&
                c.friction >= 0 &&
                u.friction >= 0 &&
                (l = c.friction * u.friction),
              l > 0)
            ) {
              const r = l * (o.frictionGravity || o.gravity).length();
              let s = n.invMass + i.invMass;
              s > 0 && (s = 1 / s);
              const c = this.frictionEquationPool,
                u = c.length ? c.pop() : new tE(n, i, r * s),
                h = c.length ? c.pop() : new tE(n, i, r * s);
              return (
                (u.bi = h.bi = n),
                (u.bj = h.bj = i),
                (u.minForce = h.minForce = -r * s),
                (u.maxForce = h.maxForce = r * s),
                u.ri.copy(t.ri),
                u.rj.copy(t.rj),
                h.ri.copy(t.ri),
                h.rj.copy(t.rj),
                t.ni.tangents(u.t, h.t),
                u.setSpookParams(
                  a.frictionEquationStiffness,
                  a.frictionEquationRelaxation,
                  o.dt
                ),
                h.setSpookParams(
                  a.frictionEquationStiffness,
                  a.frictionEquationRelaxation,
                  o.dt
                ),
                (u.enabled = h.enabled = t.enabled),
                e.push(u, h),
                !0
              );
            }
            return !1;
          }
          createFrictionFromAverage(t) {
            let e = this.result[this.result.length - 1];
            if (
              !this.createFrictionEquationsFromContact(
                e,
                this.frictionResult
              ) ||
              1 === t
            )
              return;
            const n = this.frictionResult[this.frictionResult.length - 2],
              i = this.frictionResult[this.frictionResult.length - 1];
            kE.setZero(), BE.setZero(), zE.setZero();
            const r = e.bi;
            e.bj;
            for (let n = 0; n !== t; n++)
              (e = this.result[this.result.length - 1 - n]),
                e.bi !== r
                  ? (kE.vadd(e.ni, kE), BE.vadd(e.ri, BE), zE.vadd(e.rj, zE))
                  : (kE.vsub(e.ni, kE), BE.vadd(e.rj, BE), zE.vadd(e.ri, zE));
            const s = 1 / t;
            BE.scale(s, n.ri),
              zE.scale(s, n.rj),
              i.ri.copy(n.ri),
              i.rj.copy(n.rj),
              kE.normalize(),
              kE.tangents(n.t, i.t);
          }
          getContacts(t, e, n, i, r, s, o) {
            (this.contactPointPool = r),
              (this.frictionEquationPool = o),
              (this.result = i),
              (this.frictionResult = s);
            const a = GE,
              l = WE,
              c = HE,
              u = VE;
            for (let i = 0, r = t.length; i !== r; i++) {
              const r = t[i],
                s = e[i];
              let o = null;
              r.material &&
                s.material &&
                (o = n.getContactMaterial(r.material, s.material) || null);
              const h =
                (r.type & Cb.KINEMATIC && s.type & Cb.STATIC) ||
                (r.type & Cb.STATIC && s.type & Cb.KINEMATIC) ||
                (r.type & Cb.KINEMATIC && s.type & Cb.KINEMATIC);
              for (let t = 0; t < r.shapes.length; t++) {
                r.quaternion.mult(r.shapeOrientations[t], a),
                  r.quaternion.vmult(r.shapeOffsets[t], c),
                  c.vadd(r.position, c);
                const e = r.shapes[t];
                for (let t = 0; t < s.shapes.length; t++) {
                  s.quaternion.mult(s.shapeOrientations[t], l),
                    s.quaternion.vmult(s.shapeOffsets[t], u),
                    u.vadd(s.position, u);
                  const i = s.shapes[t];
                  if (
                    !(
                      e.collisionFilterMask & i.collisionFilterGroup &&
                      i.collisionFilterMask & e.collisionFilterGroup
                    )
                  )
                    continue;
                  if (
                    c.distanceTo(u) >
                    e.boundingSphereRadius + i.boundingSphereRadius
                  )
                    continue;
                  let d = null;
                  e.material &&
                    i.material &&
                    (d = n.getContactMaterial(e.material, i.material) || null),
                    (this.currentContactMaterial =
                      d || o || n.defaultContactMaterial);
                  const p = this[e.type | i.type];
                  if (p) {
                    let t = !1;
                    (t =
                      e.type < i.type
                        ? p.call(this, e, i, c, u, a, l, r, s, e, i, h)
                        : p.call(this, i, e, u, c, l, a, s, r, e, i, h)),
                      t &&
                        h &&
                        (n.shapeOverlapKeeper.set(e.id, i.id),
                        n.bodyOverlapKeeper.set(r.id, s.id));
                  }
                }
              }
            }
          }
          sphereSphere(t, e, n, i, r, s, o, a, l, c, u) {
            if (u) return n.distanceSquared(i) < (t.radius + e.radius) ** 2;
            const h = this.createContactEquation(o, a, t, e, l, c);
            i.vsub(n, h.ni),
              h.ni.normalize(),
              h.ri.copy(h.ni),
              h.rj.copy(h.ni),
              h.ri.scale(t.radius, h.ri),
              h.rj.scale(-e.radius, h.rj),
              h.ri.vadd(n, h.ri),
              h.ri.vsub(o.position, h.ri),
              h.rj.vadd(i, h.rj),
              h.rj.vsub(a.position, h.rj),
              this.result.push(h),
              this.createFrictionEquationsFromContact(h, this.frictionResult);
          }
          spherePlane(t, e, n, i, r, s, o, a, l, c, u) {
            const h = this.createContactEquation(o, a, t, e, l, c);
            if (
              (h.ni.set(0, 0, 1),
              s.vmult(h.ni, h.ni),
              h.ni.negate(h.ni),
              h.ni.normalize(),
              h.ni.scale(t.radius, h.ri),
              n.vsub(i, cS),
              h.ni.scale(h.ni.dot(cS), uS),
              cS.vsub(uS, h.rj),
              -cS.dot(h.ni) <= t.radius)
            ) {
              if (u) return !0;
              const t = h.ri,
                e = h.rj;
              t.vadd(n, t),
                t.vsub(o.position, t),
                e.vadd(i, e),
                e.vsub(a.position, e),
                this.result.push(h),
                this.createFrictionEquationsFromContact(h, this.frictionResult);
            }
          }
          boxBox(t, e, n, i, r, s, o, a, l, c, u) {
            return (
              (t.convexPolyhedronRepresentation.material = t.material),
              (e.convexPolyhedronRepresentation.material = e.material),
              (t.convexPolyhedronRepresentation.collisionResponse =
                t.collisionResponse),
              (e.convexPolyhedronRepresentation.collisionResponse =
                e.collisionResponse),
              this.convexConvex(
                t.convexPolyhedronRepresentation,
                e.convexPolyhedronRepresentation,
                n,
                i,
                r,
                s,
                o,
                a,
                t,
                e,
                u
              )
            );
          }
          sphereBox(t, e, n, i, r, s, o, a, l, c, u) {
            const h = this.v3pool,
              d = _S;
            n.vsub(i, mS), e.getSideNormals(d, s);
            const p = t.radius;
            let f = !1;
            const m = bS,
              g = wS,
              v = ES;
            let y = null,
              _ = 0,
              x = 0,
              b = 0,
              w = null;
            for (let t = 0, e = d.length; t !== e && !1 === f; t++) {
              const e = gS;
              e.copy(d[t]);
              const n = e.length();
              e.normalize();
              const i = mS.dot(e);
              if (i < n + p && i > 0) {
                const r = vS,
                  s = yS;
                r.copy(d[(t + 1) % 3]), s.copy(d[(t + 2) % 3]);
                const o = r.length(),
                  a = s.length();
                r.normalize(), s.normalize();
                const l = mS.dot(r),
                  c = mS.dot(s);
                if (l < o && l > -o && c < a && c > -a) {
                  const t = Math.abs(i - n - p);
                  if (
                    (null === w || t < w) &&
                    ((w = t),
                    (x = l),
                    (b = c),
                    (y = n),
                    m.copy(e),
                    g.copy(r),
                    v.copy(s),
                    _++,
                    u)
                  )
                    return !0;
                }
              }
            }
            if (_) {
              f = !0;
              const r = this.createContactEquation(o, a, t, e, l, c);
              m.scale(-p, r.ri),
                r.ni.copy(m),
                r.ni.negate(r.ni),
                m.scale(y, m),
                g.scale(x, g),
                m.vadd(g, m),
                v.scale(b, v),
                m.vadd(v, r.rj),
                r.ri.vadd(n, r.ri),
                r.ri.vsub(o.position, r.ri),
                r.rj.vadd(i, r.rj),
                r.rj.vsub(a.position, r.rj),
                this.result.push(r),
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
            let E = h.get();
            const S = xS;
            for (let r = 0; 2 !== r && !f; r++)
              for (let s = 0; 2 !== s && !f; s++)
                for (let h = 0; 2 !== h && !f; h++)
                  if (
                    (E.set(0, 0, 0),
                    r ? E.vadd(d[0], E) : E.vsub(d[0], E),
                    s ? E.vadd(d[1], E) : E.vsub(d[1], E),
                    h ? E.vadd(d[2], E) : E.vsub(d[2], E),
                    i.vadd(E, S),
                    S.vsub(n, S),
                    S.lengthSquared() < p * p)
                  ) {
                    if (u) return !0;
                    f = !0;
                    const r = this.createContactEquation(o, a, t, e, l, c);
                    r.ri.copy(S),
                      r.ri.normalize(),
                      r.ni.copy(r.ri),
                      r.ri.scale(p, r.ri),
                      r.rj.copy(E),
                      r.ri.vadd(n, r.ri),
                      r.ri.vsub(o.position, r.ri),
                      r.rj.vadd(i, r.rj),
                      r.rj.vsub(a.position, r.rj),
                      this.result.push(r),
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                  }
            h.release(E), (E = null);
            const M = h.get(),
              T = h.get(),
              A = h.get(),
              R = h.get(),
              C = h.get(),
              L = d.length;
            for (let r = 0; r !== L && !f; r++)
              for (let s = 0; s !== L && !f; s++)
                if (r % 3 != s % 3) {
                  d[s].cross(d[r], M),
                    M.normalize(),
                    d[r].vadd(d[s], T),
                    A.copy(n),
                    A.vsub(T, A),
                    A.vsub(i, A);
                  const h = A.dot(M);
                  M.scale(h, R);
                  let m = 0;
                  for (; m === r % 3 || m === s % 3; ) m++;
                  C.copy(n), C.vsub(R, C), C.vsub(T, C), C.vsub(i, C);
                  const g = Math.abs(h),
                    v = C.length();
                  if (g < d[m].length() && v < p) {
                    if (u) return !0;
                    f = !0;
                    const r = this.createContactEquation(o, a, t, e, l, c);
                    T.vadd(R, r.rj),
                      r.rj.copy(r.rj),
                      C.negate(r.ni),
                      r.ni.normalize(),
                      r.ri.copy(r.rj),
                      r.ri.vadd(i, r.ri),
                      r.ri.vsub(n, r.ri),
                      r.ri.normalize(),
                      r.ri.scale(p, r.ri),
                      r.ri.vadd(n, r.ri),
                      r.ri.vsub(o.position, r.ri),
                      r.rj.vadd(i, r.rj),
                      r.rj.vsub(a.position, r.rj),
                      this.result.push(r),
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                  }
                }
            h.release(M, T, A, R, C);
          }
          planeBox(t, e, n, i, r, s, o, a, l, c, u) {
            return (
              (e.convexPolyhedronRepresentation.material = e.material),
              (e.convexPolyhedronRepresentation.collisionResponse =
                e.collisionResponse),
              (e.convexPolyhedronRepresentation.id = e.id),
              this.planeConvex(
                t,
                e.convexPolyhedronRepresentation,
                n,
                i,
                r,
                s,
                o,
                a,
                t,
                e,
                u
              )
            );
          }
          convexConvex(t, e, n, i, r, s, o, a, l, c, u, h, d) {
            const p = kS;
            if (
              !(
                n.distanceTo(i) >
                t.boundingSphereRadius + e.boundingSphereRadius
              ) &&
              t.findSeparatingAxis(e, n, r, i, s, p, h, d)
            ) {
              const h = [],
                d = BS;
              t.clipAgainstHull(n, r, e, i, s, p, -100, 100, h);
              let f = 0;
              for (let r = 0; r !== h.length; r++) {
                if (u) return !0;
                const s = this.createContactEquation(o, a, t, e, l, c),
                  m = s.ri,
                  g = s.rj;
                p.negate(s.ni),
                  h[r].normal.negate(d),
                  d.scale(h[r].depth, d),
                  h[r].point.vadd(d, m),
                  g.copy(h[r].point),
                  m.vsub(n, m),
                  g.vsub(i, g),
                  m.vadd(n, m),
                  m.vsub(o.position, m),
                  g.vadd(i, g),
                  g.vsub(a.position, g),
                  this.result.push(s),
                  f++,
                  this.enableFrictionReduction ||
                    this.createFrictionEquationsFromContact(
                      s,
                      this.frictionResult
                    );
              }
              this.enableFrictionReduction &&
                f &&
                this.createFrictionFromAverage(f);
            }
          }
          sphereConvex(t, e, n, i, r, s, o, a, l, c, u) {
            const h = this.v3pool;
            n.vsub(i, SS);
            const d = e.faceNormals,
              p = e.faces,
              f = e.vertices,
              m = t.radius;
            let g = !1;
            for (let r = 0; r !== f.length; r++) {
              const h = f[r],
                d = RS;
              s.vmult(h, d), i.vadd(d, d);
              const p = AS;
              if ((d.vsub(n, p), p.lengthSquared() < m * m)) {
                if (u) return !0;
                g = !0;
                const r = this.createContactEquation(o, a, t, e, l, c);
                return (
                  r.ri.copy(p),
                  r.ri.normalize(),
                  r.ni.copy(r.ri),
                  r.ri.scale(m, r.ri),
                  d.vsub(i, r.rj),
                  r.ri.vadd(n, r.ri),
                  r.ri.vsub(o.position, r.ri),
                  r.rj.vadd(i, r.rj),
                  r.rj.vsub(a.position, r.rj),
                  this.result.push(r),
                  void this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  )
                );
              }
            }
            for (let r = 0, v = p.length; r !== v && !1 === g; r++) {
              const v = d[r],
                y = p[r],
                _ = CS;
              s.vmult(v, _);
              const x = LS;
              s.vmult(f[y[0]], x), x.vadd(i, x);
              const b = PS;
              _.scale(-m, b), n.vadd(b, b);
              const w = OS;
              b.vsub(x, w);
              const E = w.dot(_),
                S = IS;
              if ((n.vsub(x, S), E < 0 && S.dot(_) > 0)) {
                const r = [];
                for (let t = 0, e = y.length; t !== e; t++) {
                  const e = h.get();
                  s.vmult(f[y[t]], e), i.vadd(e, e), r.push(e);
                }
                if (fS(r, _, n)) {
                  if (u) return !0;
                  g = !0;
                  const s = this.createContactEquation(o, a, t, e, l, c);
                  _.scale(-m, s.ri), _.negate(s.ni);
                  const d = h.get();
                  _.scale(-E, d);
                  const p = h.get();
                  _.scale(-m, p),
                    n.vsub(i, s.rj),
                    s.rj.vadd(p, s.rj),
                    s.rj.vadd(d, s.rj),
                    s.rj.vadd(i, s.rj),
                    s.rj.vsub(a.position, s.rj),
                    s.ri.vadd(n, s.ri),
                    s.ri.vsub(o.position, s.ri),
                    h.release(d),
                    h.release(p),
                    this.result.push(s),
                    this.createFrictionEquationsFromContact(
                      s,
                      this.frictionResult
                    );
                  for (let t = 0, e = r.length; t !== e; t++) h.release(r[t]);
                  return;
                }
                for (let d = 0; d !== y.length; d++) {
                  const p = h.get(),
                    g = h.get();
                  s.vmult(f[y[(d + 1) % y.length]], p),
                    s.vmult(f[y[(d + 2) % y.length]], g),
                    i.vadd(p, p),
                    i.vadd(g, g);
                  const v = MS;
                  g.vsub(p, v);
                  const _ = TS;
                  v.unit(_);
                  const x = h.get(),
                    b = h.get();
                  n.vsub(p, b);
                  const w = b.dot(_);
                  _.scale(w, x), x.vadd(p, x);
                  const E = h.get();
                  if (
                    (x.vsub(n, E),
                    w > 0 &&
                      w * w < v.lengthSquared() &&
                      E.lengthSquared() < m * m)
                  ) {
                    if (u) return !0;
                    const s = this.createContactEquation(o, a, t, e, l, c);
                    x.vsub(i, s.rj),
                      x.vsub(n, s.ni),
                      s.ni.normalize(),
                      s.ni.scale(m, s.ri),
                      s.rj.vadd(i, s.rj),
                      s.rj.vsub(a.position, s.rj),
                      s.ri.vadd(n, s.ri),
                      s.ri.vsub(o.position, s.ri),
                      this.result.push(s),
                      this.createFrictionEquationsFromContact(
                        s,
                        this.frictionResult
                      );
                    for (let t = 0, e = r.length; t !== e; t++) h.release(r[t]);
                    return (
                      h.release(p),
                      h.release(g),
                      h.release(x),
                      h.release(E),
                      void h.release(b)
                    );
                  }
                  h.release(p),
                    h.release(g),
                    h.release(x),
                    h.release(E),
                    h.release(b);
                }
                for (let t = 0, e = r.length; t !== e; t++) h.release(r[t]);
              }
            }
          }
          planeConvex(t, e, n, i, r, s, o, a, l, c, u) {
            const h = NS,
              d = DS;
            d.set(0, 0, 1), r.vmult(d, d);
            let p = 0;
            const f = US;
            for (let r = 0; r !== e.vertices.length; r++) {
              h.copy(e.vertices[r]), s.vmult(h, h), i.vadd(h, h), h.vsub(n, f);
              if (d.dot(f) <= 0) {
                if (u) return !0;
                const r = this.createContactEquation(o, a, t, e, l, c),
                  s = FS;
                d.scale(d.dot(f), s),
                  h.vsub(s, s),
                  s.vsub(n, r.ri),
                  r.ni.copy(d),
                  h.vsub(i, r.rj),
                  r.ri.vadd(n, r.ri),
                  r.ri.vsub(o.position, r.ri),
                  r.rj.vadd(i, r.rj),
                  r.rj.vsub(a.position, r.rj),
                  this.result.push(r),
                  p++,
                  this.enableFrictionReduction ||
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
              }
            }
            this.enableFrictionReduction &&
              p &&
              this.createFrictionFromAverage(p);
          }
          boxConvex(t, e, n, i, r, s, o, a, l, c, u) {
            return (
              (t.convexPolyhedronRepresentation.material = t.material),
              (t.convexPolyhedronRepresentation.collisionResponse =
                t.collisionResponse),
              this.convexConvex(
                t.convexPolyhedronRepresentation,
                e,
                n,
                i,
                r,
                s,
                o,
                a,
                t,
                e,
                u
              )
            );
          }
          sphereHeightfield(t, e, n, i, r, s, o, a, l, c, u) {
            const h = e.data,
              d = t.radius,
              p = e.elementSize,
              f = QS,
              m = JS;
            pb.pointToLocalFrame(i, s, n, m);
            let g = Math.floor((m.x - d) / p) - 1,
              v = Math.ceil((m.x + d) / p) + 1,
              y = Math.floor((m.y - d) / p) - 1,
              _ = Math.ceil((m.y + d) / p) + 1;
            if (v < 0 || _ < 0 || g > h.length || y > h[0].length) return;
            g < 0 && (g = 0),
              v < 0 && (v = 0),
              y < 0 && (y = 0),
              _ < 0 && (_ = 0),
              g >= h.length && (g = h.length - 1),
              v >= h.length && (v = h.length - 1),
              _ >= h[0].length && (_ = h[0].length - 1),
              y >= h[0].length && (y = h[0].length - 1);
            const x = [];
            e.getRectMinMax(g, y, v, _, x);
            const b = x[0],
              w = x[1];
            if (m.z - d > w || m.z + d < b) return;
            const E = this.result;
            for (let l = g; l < v; l++)
              for (let c = y; c < _; c++) {
                const h = E.length;
                let d = !1;
                if (
                  (e.getConvexTrianglePillar(l, c, !1),
                  pb.pointToWorldFrame(i, s, e.pillarOffset, f),
                  n.distanceTo(f) <
                    e.pillarConvex.boundingSphereRadius +
                      t.boundingSphereRadius &&
                    (d = this.sphereConvex(
                      t,
                      e.pillarConvex,
                      n,
                      f,
                      r,
                      s,
                      o,
                      a,
                      t,
                      e,
                      u
                    )),
                  u && d)
                )
                  return !0;
                if (
                  (e.getConvexTrianglePillar(l, c, !0),
                  pb.pointToWorldFrame(i, s, e.pillarOffset, f),
                  n.distanceTo(f) <
                    e.pillarConvex.boundingSphereRadius +
                      t.boundingSphereRadius &&
                    (d = this.sphereConvex(
                      t,
                      e.pillarConvex,
                      n,
                      f,
                      r,
                      s,
                      o,
                      a,
                      t,
                      e,
                      u
                    )),
                  u && d)
                )
                  return !0;
                if (E.length - h > 2) return;
              }
          }
          boxHeightfield(t, e, n, i, r, s, o, a, l, c, u) {
            return (
              (t.convexPolyhedronRepresentation.material = t.material),
              (t.convexPolyhedronRepresentation.collisionResponse =
                t.collisionResponse),
              this.convexHeightfield(
                t.convexPolyhedronRepresentation,
                e,
                n,
                i,
                r,
                s,
                o,
                a,
                t,
                e,
                u
              )
            );
          }
          convexHeightfield(t, e, n, i, r, s, o, a, l, c, u) {
            const h = e.data,
              d = e.elementSize,
              p = t.boundingSphereRadius,
              f = $S,
              m = ZS,
              g = KS;
            pb.pointToLocalFrame(i, s, n, g);
            let v = Math.floor((g.x - p) / d) - 1,
              y = Math.ceil((g.x + p) / d) + 1,
              _ = Math.floor((g.y - p) / d) - 1,
              x = Math.ceil((g.y + p) / d) + 1;
            if (y < 0 || x < 0 || v > h.length || _ > h[0].length) return;
            v < 0 && (v = 0),
              y < 0 && (y = 0),
              _ < 0 && (_ = 0),
              x < 0 && (x = 0),
              v >= h.length && (v = h.length - 1),
              y >= h.length && (y = h.length - 1),
              x >= h[0].length && (x = h[0].length - 1),
              _ >= h[0].length && (_ = h[0].length - 1);
            const b = [];
            e.getRectMinMax(v, _, y, x, b);
            const w = b[0],
              E = b[1];
            if (!(g.z - p > E || g.z + p < w))
              for (let l = v; l < y; l++)
                for (let c = _; c < x; c++) {
                  let h = !1;
                  if (
                    (e.getConvexTrianglePillar(l, c, !1),
                    pb.pointToWorldFrame(i, s, e.pillarOffset, f),
                    n.distanceTo(f) <
                      e.pillarConvex.boundingSphereRadius +
                        t.boundingSphereRadius &&
                      (h = this.convexConvex(
                        t,
                        e.pillarConvex,
                        n,
                        f,
                        r,
                        s,
                        o,
                        a,
                        null,
                        null,
                        u,
                        m,
                        null
                      )),
                    u && h)
                  )
                    return !0;
                  if (
                    (e.getConvexTrianglePillar(l, c, !0),
                    pb.pointToWorldFrame(i, s, e.pillarOffset, f),
                    n.distanceTo(f) <
                      e.pillarConvex.boundingSphereRadius +
                        t.boundingSphereRadius &&
                      (h = this.convexConvex(
                        t,
                        e.pillarConvex,
                        n,
                        f,
                        r,
                        s,
                        o,
                        a,
                        null,
                        null,
                        u,
                        m,
                        null
                      )),
                    u && h)
                  )
                    return !0;
                }
          }
          sphereParticle(t, e, n, i, r, s, o, a, l, c, u) {
            const h = GS;
            h.set(0, 0, 1), i.vsub(n, h);
            if (h.lengthSquared() <= t.radius * t.radius) {
              if (u) return !0;
              const n = this.createContactEquation(a, o, e, t, l, c);
              h.normalize(),
                n.rj.copy(h),
                n.rj.scale(t.radius, n.rj),
                n.ni.copy(h),
                n.ni.negate(n.ni),
                n.ri.set(0, 0, 0),
                this.result.push(n),
                this.createFrictionEquationsFromContact(n, this.frictionResult);
            }
          }
          planeParticle(t, e, n, i, r, s, o, a, l, c, u) {
            const h = zS;
            h.set(0, 0, 1), o.quaternion.vmult(h, h);
            const d = HS;
            i.vsub(o.position, d);
            if (h.dot(d) <= 0) {
              if (u) return !0;
              const n = this.createContactEquation(a, o, e, t, l, c);
              n.ni.copy(h), n.ni.negate(n.ni), n.ri.set(0, 0, 0);
              const r = VS;
              h.scale(h.dot(i), r),
                i.vsub(r, r),
                n.rj.copy(r),
                this.result.push(n),
                this.createFrictionEquationsFromContact(n, this.frictionResult);
            }
          }
          boxParticle(t, e, n, i, r, s, o, a, l, c, u) {
            return (
              (t.convexPolyhedronRepresentation.material = t.material),
              (t.convexPolyhedronRepresentation.collisionResponse =
                t.collisionResponse),
              this.convexParticle(
                t.convexPolyhedronRepresentation,
                e,
                n,
                i,
                r,
                s,
                o,
                a,
                t,
                e,
                u
              )
            );
          }
          convexParticle(t, e, n, i, r, s, o, a, l, c, u) {
            let h = -1;
            const d = qS,
              p = YS;
            let f = null;
            const m = jS;
            if (
              (m.copy(i),
              m.vsub(n, m),
              r.conjugate(WS),
              WS.vmult(m, m),
              t.pointIsInside(m))
            ) {
              t.worldVerticesNeedsUpdate && t.computeWorldVertices(n, r),
                t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(r);
              for (let e = 0, n = t.faces.length; e !== n; e++) {
                const n = [t.worldVertices[t.faces[e][0]]],
                  r = t.worldFaceNormals[e];
                i.vsub(n[0], XS);
                const s = -r.dot(XS);
                if (null === f || Math.abs(s) < Math.abs(f)) {
                  if (u) return !0;
                  (f = s), (h = e), d.copy(r);
                }
              }
              if (-1 !== h) {
                const r = this.createContactEquation(a, o, e, t, l, c);
                d.scale(f, p),
                  p.vadd(i, p),
                  p.vsub(n, p),
                  r.rj.copy(p),
                  d.negate(r.ni),
                  r.ri.set(0, 0, 0);
                const s = r.ri,
                  u = r.rj;
                s.vadd(i, s),
                  s.vsub(a.position, s),
                  u.vadd(n, u),
                  u.vsub(o.position, u),
                  this.result.push(r),
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
              } else
                console.warn(
                  "Point found inside convex, but did not find penetrating face!"
                );
            }
          }
          heightfieldCylinder(t, e, n, i, r, s, o, a, l, c, u) {
            return this.convexHeightfield(e, t, i, n, s, r, a, o, l, c, u);
          }
          particleCylinder(t, e, n, i, r, s, o, a, l, c, u) {
            return this.convexParticle(e, t, i, n, s, r, a, o, l, c, u);
          }
          sphereTrimesh(t, e, n, i, r, s, o, a, l, c, u) {
            const h = JE,
              d = QE,
              p = tS,
              f = eS,
              m = nS,
              g = iS,
              v = aS,
              y = ZE,
              _ = KE,
              x = lS;
            pb.pointToLocalFrame(i, s, n, m);
            const b = t.radius;
            v.lowerBound.set(m.x - b, m.y - b, m.z - b),
              v.upperBound.set(m.x + b, m.y + b, m.z + b),
              e.getTrianglesInAABB(v, x);
            const w = $E,
              E = t.radius * t.radius;
            for (let r = 0; r < x.length; r++)
              for (let h = 0; h < 3; h++)
                if (
                  (e.getVertex(e.indices[3 * x[r] + h], w),
                  w.vsub(m, _),
                  _.lengthSquared() <= E)
                ) {
                  if (
                    (y.copy(w),
                    pb.pointToWorldFrame(i, s, y, w),
                    w.vsub(n, _),
                    u)
                  )
                    return !0;
                  let r = this.createContactEquation(o, a, t, e, l, c);
                  r.ni.copy(_),
                    r.ni.normalize(),
                    r.ri.copy(r.ni),
                    r.ri.scale(t.radius, r.ri),
                    r.ri.vadd(n, r.ri),
                    r.ri.vsub(o.position, r.ri),
                    r.rj.copy(w),
                    r.rj.vsub(a.position, r.rj),
                    this.result.push(r),
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
                }
            for (let r = 0; r < x.length; r++)
              for (let v = 0; v < 3; v++) {
                e.getVertex(e.indices[3 * x[r] + v], h),
                  e.getVertex(e.indices[3 * x[r] + ((v + 1) % 3)], d),
                  d.vsub(h, p),
                  m.vsub(d, g);
                const y = g.dot(p);
                m.vsub(h, g);
                let _ = g.dot(p);
                if (_ > 0 && y < 0) {
                  m.vsub(h, g),
                    f.copy(p),
                    f.normalize(),
                    (_ = g.dot(f)),
                    f.scale(_, g),
                    g.vadd(h, g);
                  if (g.distanceTo(m) < t.radius) {
                    if (u) return !0;
                    const r = this.createContactEquation(o, a, t, e, l, c);
                    g.vsub(m, r.ni),
                      r.ni.normalize(),
                      r.ni.scale(t.radius, r.ri),
                      r.ri.vadd(n, r.ri),
                      r.ri.vsub(o.position, r.ri),
                      pb.pointToWorldFrame(i, s, g, g),
                      g.vsub(a.position, r.rj),
                      pb.vectorToWorldFrame(s, r.ni, r.ni),
                      pb.vectorToWorldFrame(s, r.ri, r.ri),
                      this.result.push(r),
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                  }
                }
              }
            const S = rS,
              M = sS,
              T = oS,
              A = YE;
            for (let r = 0, h = x.length; r !== h; r++) {
              e.getTriangleVertices(x[r], S, M, T),
                e.getNormal(x[r], A),
                m.vsub(S, g);
              let h = g.dot(A);
              if (
                (A.scale(h, g),
                m.vsub(g, g),
                (h = g.distanceTo(m)),
                ow.pointInTriangle(g, S, M, T) && h < t.radius)
              ) {
                if (u) return !0;
                let r = this.createContactEquation(o, a, t, e, l, c);
                g.vsub(m, r.ni),
                  r.ni.normalize(),
                  r.ni.scale(t.radius, r.ri),
                  r.ri.vadd(n, r.ri),
                  r.ri.vsub(o.position, r.ri),
                  pb.pointToWorldFrame(i, s, g, g),
                  g.vsub(a.position, r.rj),
                  pb.vectorToWorldFrame(s, r.ni, r.ni),
                  pb.vectorToWorldFrame(s, r.ri, r.ri),
                  this.result.push(r),
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
              }
            }
            x.length = 0;
          }
          planeTrimesh(t, e, n, i, r, s, o, a, l, c, u) {
            const h = new tb(),
              d = jE;
            d.set(0, 0, 1), r.vmult(d, d);
            for (let r = 0; r < e.vertices.length / 3; r++) {
              e.getVertex(r, h);
              const p = new tb();
              p.copy(h), pb.pointToWorldFrame(i, s, p, h);
              const f = qE;
              h.vsub(n, f);
              if (d.dot(f) <= 0) {
                if (u) return !0;
                const n = this.createContactEquation(o, a, t, e, l, c);
                n.ni.copy(d);
                const i = XE;
                d.scale(f.dot(d), i),
                  h.vsub(i, i),
                  n.ri.copy(i),
                  n.ri.vsub(o.position, n.ri),
                  n.rj.copy(h),
                  n.rj.vsub(a.position, n.rj),
                  this.result.push(n),
                  this.createFrictionEquationsFromContact(
                    n,
                    this.frictionResult
                  );
              }
            }
          }
        }
        const kE = new tb(),
          BE = new tb(),
          zE = new tb(),
          HE = new tb(),
          VE = new tb(),
          GE = new cb(),
          WE = new cb(),
          jE = new tb(),
          qE = new tb(),
          XE = new tb(),
          YE = new tb(),
          KE = new tb();
        new tb();
        const $E = new tb(),
          ZE = new tb(),
          JE = new tb(),
          QE = new tb(),
          tS = new tb(),
          eS = new tb(),
          nS = new tb(),
          iS = new tb(),
          rS = new tb(),
          sS = new tb(),
          oS = new tb(),
          aS = new rb(),
          lS = [],
          cS = new tb(),
          uS = new tb(),
          hS = new tb(),
          dS = new tb(),
          pS = new tb();
        function fS(t, e, n) {
          let i = null;
          const r = t.length;
          for (let s = 0; s !== r; s++) {
            const o = t[s],
              a = hS;
            t[(s + 1) % r].vsub(o, a);
            const l = dS;
            a.cross(e, l);
            const c = pS;
            n.vsub(o, c);
            const u = l.dot(c);
            if (!(null === i || (u > 0 && !0 === i) || (u <= 0 && !1 === i)))
              return !1;
            null === i && (i = u > 0);
          }
          return !0;
        }
        const mS = new tb(),
          gS = new tb(),
          vS = new tb(),
          yS = new tb(),
          _S = [new tb(), new tb(), new tb(), new tb(), new tb(), new tb()],
          xS = new tb(),
          bS = new tb(),
          wS = new tb(),
          ES = new tb(),
          SS = new tb(),
          MS = new tb(),
          TS = new tb(),
          AS = new tb(),
          RS = new tb(),
          CS = new tb(),
          LS = new tb(),
          PS = new tb(),
          OS = new tb(),
          IS = new tb();
        new tb(), new tb();
        const NS = new tb(),
          DS = new tb(),
          US = new tb(),
          FS = new tb(),
          kS = new tb(),
          BS = new tb(),
          zS = new tb(),
          HS = new tb(),
          VS = new tb(),
          GS = new tb(),
          WS = new cb(),
          jS = new tb();
        new tb();
        const qS = new tb(),
          XS = new tb(),
          YS = new tb(),
          KS = new tb(),
          $S = new tb(),
          ZS = [0],
          JS = new tb(),
          QS = new tb();
        class tM {
          constructor() {
            (this.current = []), (this.previous = []);
          }
          getKey(t, e) {
            if (e < t) {
              const n = e;
              (e = t), (t = n);
            }
            return (t << 16) | e;
          }
          set(t, e) {
            const n = this.getKey(t, e),
              i = this.current;
            let r = 0;
            for (; n > i[r]; ) r++;
            if (n !== i[r]) {
              for (let t = i.length - 1; t >= r; t--) i[t + 1] = i[t];
              i[r] = n;
            }
          }
          tick() {
            const t = this.current;
            (this.current = this.previous),
              (this.previous = t),
              (this.current.length = 0);
          }
          getDiff(t, e) {
            const n = this.current,
              i = this.previous,
              r = n.length,
              s = i.length;
            let o = 0;
            for (let e = 0; e < r; e++) {
              let r = !1;
              const s = n[e];
              for (; s > i[o]; ) o++;
              (r = s === i[o]), r || eM(t, s);
            }
            o = 0;
            for (let t = 0; t < s; t++) {
              let r = !1;
              const s = i[t];
              for (; s > n[o]; ) o++;
              (r = n[o] === s), r || eM(e, s);
            }
          }
        }
        function eM(t, e) {
          t.push((4294901760 & e) >> 16, 65535 & e);
        }
        const nM = (t, e) => (t < e ? `${t}-${e}` : `${e}-${t}`);
        class iM {
          constructor() {
            this.data = {
              keys: [],
            };
          }
          get(t, e) {
            const n = nM(t, e);
            return this.data[n];
          }
          set(t, e, n) {
            const i = nM(t, e);
            this.get(t, e) || this.data.keys.push(i), (this.data[i] = n);
          }
          delete(t, e) {
            const n = nM(t, e),
              i = this.data.keys.indexOf(n);
            -1 !== i && this.data.keys.splice(i, 1), delete this.data[n];
          }
          reset() {
            const t = this.data,
              e = t.keys;
            for (; e.length > 0; ) {
              delete t[e.pop()];
            }
          }
        }
        class rM extends lb {
          constructor(t) {
            void 0 === t && (t = {}),
              super(),
              (this.dt = -1),
              (this.allowSleep = !!t.allowSleep),
              (this.contacts = []),
              (this.frictionEquations = []),
              (this.quatNormalizeSkip =
                void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0),
              (this.quatNormalizeFast =
                void 0 !== t.quatNormalizeFast && t.quatNormalizeFast),
              (this.time = 0),
              (this.stepnumber = 0),
              (this.default_dt = 1 / 60),
              (this.nextId = 0),
              (this.gravity = new tb()),
              t.gravity && this.gravity.copy(t.gravity),
              t.frictionGravity &&
                ((this.frictionGravity = new tb()),
                this.frictionGravity.copy(t.frictionGravity)),
              (this.broadphase =
                void 0 !== t.broadphase ? t.broadphase : new Yb()),
              (this.bodies = []),
              (this.hasActiveBodies = !1),
              (this.solver = void 0 !== t.solver ? t.solver : new oE()),
              (this.constraints = []),
              (this.narrowphase = new FE(this)),
              (this.collisionMatrix = new ab()),
              (this.collisionMatrixPrevious = new ab()),
              (this.bodyOverlapKeeper = new tM()),
              (this.shapeOverlapKeeper = new tM()),
              (this.contactmaterials = []),
              (this.contactMaterialTable = new iM()),
              (this.defaultMaterial = new rE("default")),
              (this.defaultContactMaterial = new iE(
                this.defaultMaterial,
                this.defaultMaterial,
                {
                  friction: 0.3,
                  restitution: 0,
                }
              )),
              (this.doProfiling = !1),
              (this.profile = {
                solve: 0,
                makeContactConstraints: 0,
                broadphase: 0,
                integrate: 0,
                narrowphase: 0,
              }),
              (this.accumulator = 0),
              (this.subsystems = []),
              (this.addBodyEvent = {
                type: "addBody",
                body: null,
              }),
              (this.removeBodyEvent = {
                type: "removeBody",
                body: null,
              }),
              (this.idToBodyMap = {}),
              this.broadphase.setWorld(this);
          }
          getContactMaterial(t, e) {
            return this.contactMaterialTable.get(t.id, e.id);
          }
          collisionMatrixTick() {
            const t = this.collisionMatrixPrevious;
            (this.collisionMatrixPrevious = this.collisionMatrix),
              (this.collisionMatrix = t),
              this.collisionMatrix.reset(),
              this.bodyOverlapKeeper.tick(),
              this.shapeOverlapKeeper.tick();
          }
          addConstraint(t) {
            this.constraints.push(t);
          }
          removeConstraint(t) {
            const e = this.constraints.indexOf(t);
            -1 !== e && this.constraints.splice(e, 1);
          }
          rayTest(t, e, n) {
            n instanceof Kb
              ? this.raycastClosest(
                  t,
                  e,
                  {
                    skipBackfaces: !0,
                  },
                  n
                )
              : this.raycastAll(
                  t,
                  e,
                  {
                    skipBackfaces: !0,
                  },
                  n
                );
          }
          raycastAll(t, e, n, i) {
            return (
              void 0 === n && (n = {}),
              (n.mode = ow.ALL),
              (n.from = t),
              (n.to = e),
              (n.callback = i),
              sM.intersectWorld(this, n)
            );
          }
          raycastAny(t, e, n, i) {
            return (
              void 0 === n && (n = {}),
              (n.mode = ow.ANY),
              (n.from = t),
              (n.to = e),
              (n.result = i),
              sM.intersectWorld(this, n)
            );
          }
          raycastClosest(t, e, n, i) {
            return (
              void 0 === n && (n = {}),
              (n.mode = ow.CLOSEST),
              (n.from = t),
              (n.to = e),
              (n.result = i),
              sM.intersectWorld(this, n)
            );
          }
          addBody(t) {
            this.bodies.includes(t) ||
              ((t.index = this.bodies.length),
              this.bodies.push(t),
              (t.world = this),
              t.initPosition.copy(t.position),
              t.initVelocity.copy(t.velocity),
              (t.timeLastSleepy = this.time),
              t instanceof Cb &&
                (t.initAngularVelocity.copy(t.angularVelocity),
                t.initQuaternion.copy(t.quaternion)),
              this.collisionMatrix.setNumObjects(this.bodies.length),
              (this.addBodyEvent.body = t),
              (this.idToBodyMap[t.id] = t),
              this.dispatchEvent(this.addBodyEvent));
          }
          removeBody(t) {
            t.world = null;
            const e = this.bodies.length - 1,
              n = this.bodies,
              i = n.indexOf(t);
            if (-1 !== i) {
              n.splice(i, 1);
              for (let t = 0; t !== n.length; t++) n[t].index = t;
              this.collisionMatrix.setNumObjects(e),
                (this.removeBodyEvent.body = t),
                delete this.idToBodyMap[t.id],
                this.dispatchEvent(this.removeBodyEvent);
            }
          }
          getBodyById(t) {
            return this.idToBodyMap[t];
          }
          getShapeById(t) {
            const e = this.bodies;
            for (let n = 0; n < e.length; n++) {
              const i = e[n].shapes;
              for (let e = 0; e < i.length; e++) {
                const n = i[e];
                if (n.id === t) return n;
              }
            }
            return null;
          }
          addContactMaterial(t) {
            this.contactmaterials.push(t),
              this.contactMaterialTable.set(
                t.materials[0].id,
                t.materials[1].id,
                t
              );
          }
          removeContactMaterial(t) {
            const e = this.contactmaterials.indexOf(t);
            -1 !== e &&
              (this.contactmaterials.splice(e, 1),
              this.contactMaterialTable.delete(
                t.materials[0].id,
                t.materials[1].id
              ));
          }
          fixedStep(t, e) {
            void 0 === t && (t = 1 / 60), void 0 === e && (e = 10);
            const n = oM.now() / 1e3;
            if (this.lastCallTime) {
              const i = n - this.lastCallTime;
              this.step(t, i, e);
            } else this.step(t, void 0, e);
            this.lastCallTime = n;
          }
          step(t, e, n) {
            if ((void 0 === n && (n = 10), void 0 === e))
              this.internalStep(t), (this.time += t);
            else {
              this.accumulator += e;
              const i = oM.now();
              let r = 0;
              for (
                ;
                this.accumulator >= t &&
                r < n &&
                (this.internalStep(t),
                (this.accumulator -= t),
                r++,
                !(oM.now() - i > 1e3 * t));

              );
              this.accumulator = this.accumulator % t;
              const s = this.accumulator / t;
              for (let t = 0; t !== this.bodies.length; t++) {
                const e = this.bodies[t];
                e.previousPosition.lerp(e.position, s, e.interpolatedPosition),
                  e.previousQuaternion.slerp(
                    e.quaternion,
                    s,
                    e.interpolatedQuaternion
                  ),
                  e.previousQuaternion.normalize();
              }
              this.time += e;
            }
          }
          internalStep(t) {
            this.dt = t;
            const e = this.contacts,
              n = dM,
              i = pM,
              r = this.bodies.length,
              s = this.bodies,
              o = this.solver,
              a = this.gravity,
              l = this.doProfiling,
              c = this.profile,
              u = Cb.DYNAMIC;
            let h = -1 / 0;
            const d = this.constraints,
              p = hM;
            a.length();
            const f = a.x,
              m = a.y,
              g = a.z;
            let v = 0;
            for (l && (h = oM.now()), v = 0; v !== r; v++) {
              const t = s[v];
              if (t.type === u) {
                const e = t.force,
                  n = t.mass;
                (e.x += n * f), (e.y += n * m), (e.z += n * g);
              }
            }
            for (let t = 0, e = this.subsystems.length; t !== e; t++)
              this.subsystems[t].update();
            l && (h = oM.now()),
              (n.length = 0),
              (i.length = 0),
              this.broadphase.collisionPairs(this, n, i),
              l && (c.broadphase = oM.now() - h);
            let y = d.length;
            for (v = 0; v !== y; v++) {
              const t = d[v];
              if (!t.collideConnected)
                for (let e = n.length - 1; e >= 0; e -= 1)
                  ((t.bodyA === n[e] && t.bodyB === i[e]) ||
                    (t.bodyB === n[e] && t.bodyA === i[e])) &&
                    (n.splice(e, 1), i.splice(e, 1));
            }
            this.collisionMatrixTick(), l && (h = oM.now());
            const _ = uM,
              x = e.length;
            for (v = 0; v !== x; v++) _.push(e[v]);
            e.length = 0;
            const b = this.frictionEquations.length;
            for (v = 0; v !== b; v++) p.push(this.frictionEquations[v]);
            for (
              this.frictionEquations.length = 0,
                this.narrowphase.getContacts(
                  n,
                  i,
                  this,
                  e,
                  _,
                  this.frictionEquations,
                  p
                ),
                l && (c.narrowphase = oM.now() - h),
                l && (h = oM.now()),
                v = 0;
              v < this.frictionEquations.length;
              v++
            )
              o.addEquation(this.frictionEquations[v]);
            const w = e.length;
            for (let t = 0; t !== w; t++) {
              const n = e[t],
                i = n.bi,
                r = n.bj,
                s = n.si,
                a = n.sj;
              let l;
              if (
                ((l =
                  (i.material &&
                    r.material &&
                    this.getContactMaterial(i.material, r.material)) ||
                  this.defaultContactMaterial),
                l.friction,
                i.material &&
                  r.material &&
                  (i.material.friction >= 0 &&
                    r.material.friction >= 0 &&
                    (i.material.friction, r.material.friction),
                  i.material.restitution >= 0 &&
                    r.material.restitution >= 0 &&
                    (n.restitution =
                      i.material.restitution * r.material.restitution)),
                o.addEquation(n),
                i.allowSleep &&
                  i.type === Cb.DYNAMIC &&
                  i.sleepState === Cb.SLEEPING &&
                  r.sleepState === Cb.AWAKE &&
                  r.type !== Cb.STATIC)
              ) {
                r.velocity.lengthSquared() +
                  r.angularVelocity.lengthSquared() >=
                  2 * r.sleepSpeedLimit ** 2 && (i.wakeUpAfterNarrowphase = !0);
              }
              if (
                r.allowSleep &&
                r.type === Cb.DYNAMIC &&
                r.sleepState === Cb.SLEEPING &&
                i.sleepState === Cb.AWAKE &&
                i.type !== Cb.STATIC
              ) {
                i.velocity.lengthSquared() +
                  i.angularVelocity.lengthSquared() >=
                  2 * i.sleepSpeedLimit ** 2 && (r.wakeUpAfterNarrowphase = !0);
              }
              this.collisionMatrix.set(i, r, !0),
                this.collisionMatrixPrevious.get(i, r) ||
                  ((cM.body = r),
                  (cM.contact = n),
                  i.dispatchEvent(cM),
                  (cM.body = i),
                  r.dispatchEvent(cM)),
                this.bodyOverlapKeeper.set(i.id, r.id),
                this.shapeOverlapKeeper.set(s.id, a.id);
            }
            for (
              this.emitContactEvents(),
                l &&
                  ((c.makeContactConstraints = oM.now() - h), (h = oM.now())),
                v = 0;
              v !== r;
              v++
            ) {
              const t = s[v];
              t.wakeUpAfterNarrowphase &&
                (t.wakeUp(), (t.wakeUpAfterNarrowphase = !1));
            }
            for (y = d.length, v = 0; v !== y; v++) {
              const t = d[v];
              t.update();
              for (let e = 0, n = t.equations.length; e !== n; e++) {
                const n = t.equations[e];
                o.addEquation(n);
              }
            }
            o.solve(t, this),
              l && (c.solve = oM.now() - h),
              o.removeAllEquations();
            const E = Math.pow;
            for (v = 0; v !== r; v++) {
              const e = s[v];
              if (e.type & u) {
                const n = E(1 - e.linearDamping, t),
                  i = e.velocity;
                i.scale(n, i);
                const r = e.angularVelocity;
                if (r) {
                  const n = E(1 - e.angularDamping, t);
                  r.scale(n, r);
                }
              }
            }
            this.dispatchEvent(lM), l && (h = oM.now());
            const S = this.stepnumber % (this.quatNormalizeSkip + 1) == 0,
              M = this.quatNormalizeFast;
            for (v = 0; v !== r; v++) s[v].integrate(t, S, M);
            this.clearForces(),
              (this.broadphase.dirty = !0),
              l && (c.integrate = oM.now() - h),
              (this.stepnumber += 1),
              this.dispatchEvent(aM);
            let T = !0;
            if (this.allowSleep)
              for (T = !1, v = 0; v !== r; v++) {
                const t = s[v];
                t.sleepTick(this.time),
                  t.sleepState !== Cb.SLEEPING && (T = !0);
              }
            this.hasActiveBodies = T;
          }
          emitContactEvents() {
            const t = this.hasAnyEventListener("beginContact"),
              e = this.hasAnyEventListener("endContact");
            if (((t || e) && this.bodyOverlapKeeper.getDiff(fM, mM), t)) {
              for (let t = 0, e = fM.length; t < e; t += 2)
                (gM.bodyA = this.getBodyById(fM[t])),
                  (gM.bodyB = this.getBodyById(fM[t + 1])),
                  this.dispatchEvent(gM);
              gM.bodyA = gM.bodyB = null;
            }
            if (e) {
              for (let t = 0, e = mM.length; t < e; t += 2)
                (vM.bodyA = this.getBodyById(mM[t])),
                  (vM.bodyB = this.getBodyById(mM[t + 1])),
                  this.dispatchEvent(vM);
              vM.bodyA = vM.bodyB = null;
            }
            fM.length = mM.length = 0;
            const n = this.hasAnyEventListener("beginShapeContact"),
              i = this.hasAnyEventListener("endShapeContact");
            if (((n || i) && this.shapeOverlapKeeper.getDiff(fM, mM), n)) {
              for (let t = 0, e = fM.length; t < e; t += 2) {
                const e = this.getShapeById(fM[t]),
                  n = this.getShapeById(fM[t + 1]);
                (yM.shapeA = e),
                  (yM.shapeB = n),
                  e && (yM.bodyA = e.body),
                  n && (yM.bodyB = n.body),
                  this.dispatchEvent(yM);
              }
              yM.bodyA = yM.bodyB = yM.shapeA = yM.shapeB = null;
            }
            if (i) {
              for (let t = 0, e = mM.length; t < e; t += 2) {
                const e = this.getShapeById(mM[t]),
                  n = this.getShapeById(mM[t + 1]);
                (_M.shapeA = e),
                  (_M.shapeB = n),
                  e && (_M.bodyA = e.body),
                  n && (_M.bodyB = n.body),
                  this.dispatchEvent(_M);
              }
              _M.bodyA = _M.bodyB = _M.shapeA = _M.shapeB = null;
            }
          }
          clearForces() {
            const t = this.bodies,
              e = t.length;
            for (let n = 0; n !== e; n++) {
              const e = t[n];
              e.force, e.torque, e.force.set(0, 0, 0), e.torque.set(0, 0, 0);
            }
          }
        }
        new rb();
        const sM = new ow(),
          oM = globalThis.performance || {};
        if (!oM.now) {
          let t = Date.now();
          oM.timing &&
            oM.timing.navigationStart &&
            (t = oM.timing.navigationStart),
            (oM.now = () => Date.now() - t);
        }
        new tb();
        const aM = {
            type: "postStep",
          },
          lM = {
            type: "preStep",
          },
          cM = {
            type: Cb.COLLIDE_EVENT_NAME,
            body: null,
            contact: null,
          },
          uM = [],
          hM = [],
          dM = [],
          pM = [],
          fM = [],
          mM = [],
          gM = {
            type: "beginContact",
            bodyA: null,
            bodyB: null,
          },
          vM = {
            type: "endContact",
            bodyA: null,
            bodyB: null,
          },
          yM = {
            type: "beginShapeContact",
            bodyA: null,
            bodyB: null,
            shapeA: null,
            shapeB: null,
          },
          _M = {
            type: "endShapeContact",
            bodyA: null,
            bodyB: null,
            shapeA: null,
            shapeB: null,
          };
        class xM {
          static getDistance(t, e, n, i) {
            return Math.sqrt(Math.pow(t - n, 2) + Math.pow(e - i, 2));
          }
          static lerp(t, e, n) {
            return t * (1 - n) + e * n;
          }
          static clamp(t, e, n) {
            return e > t ? e : n < t ? n : t;
          }
          static fract(t, e, n) {
            const i = n - e + 1;
            let r = (t - e) % i;
            return 0 > r && (r = i + r), r + e;
          }
          static clampRandom(t, e) {
            return Math.random() * (e - t) + t;
          }
          static remap(t, e, n, i, r) {
            return ((t - e) / (n - e)) * (r - i) + i;
          }
          static degreeToRadian(t) {
            return (t * Math.PI) / 180;
          }
          static radianToDegree(t) {
            return (180 * t) / Math.PI;
          }
        }
        class bM {
          constructor(t = document.body, e = !1) {
            this.element = t;
            const n = this.element.getBoundingClientRect();
            (this.w = n.width),
              (this.h = n.height),
              (this.x = n.x),
              (this.y = n.y),
              (this.isMatchMediaHover =
                window.matchMedia("(hover: hover)").matches),
              (this.isAbleToDown = e),
              (this.isDown = !1),
              (this.timer = null),
              (this.coords = {
                normalize: {
                  x: 1,
                  y: 1,
                  lerp: {
                    x: 1,
                    y: 1,
                  },
                },
                interpolation: 0.1,
              }),
              this.setEvent();
          }
          setEvent() {
            this.isMatchMediaHover
              ? ((this.isDown = !0),
                window.addEventListener("mousemove", this.move.bind(this), {
                  passive: !0,
                }),
                this.isAbleToDown
                  ? ((this.isDown = !1),
                    window.addEventListener("mousedown", this.down.bind(this), {
                      passive: !0,
                    }),
                    window.addEventListener("mouseup", this.up.bind(this), {
                      passive: !0,
                    }))
                  : (window.addEventListener(
                      "mouseenter",
                      this.down.bind(this),
                      {
                        passive: !0,
                      }
                    ),
                    window.addEventListener("mouseleave", this.up.bind(this), {
                      passive: !0,
                    })))
              : ((this.isDown = !1),
                window.addEventListener("touchstart", this.down.bind(this), {
                  passive: !0,
                }),
                window.addEventListener("touchmove", this.move.bind(this), {
                  passive: !0,
                }),
                window.addEventListener("touchend", this.up.bind(this), {
                  passive: !0,
                }));
          }
          resetEvent() {
            this.isMatchMediaHover
              ? (this.element.removeEventListener("mousemove", this.move),
                this.isAbleToDown &&
                  (this.element.removeEventListener("mousedown", this.down),
                  this.element.removeEventListener("mouseup", this.up)))
              : (this.element.removeEventListener("touchstart", this.down),
                this.element.removeEventListener("touchmove", this.move),
                this.element.removeEventListener("touchend", this.up));
          }
          reset() {
            this.resetEvent(), clearTimeout(this.timer), (this.timer = null);
          }
          updateResolution() {
            const t = this.element.getBoundingClientRect(),
              e = t.width,
              n = t.height,
              i = t.x,
              r = t.y;
            this.w != e && (this.w = e),
              this.h != n && (this.h = n),
              this.x != i && (this.x = i),
              this.y != r && (this.y = r);
          }
          normalize(t, e, n, i) {
            return {
              x: (t / n) * 2 - 1,
              y: (-e / i) * 2 + 1,
            };
          }
          lerp(t, e, n) {
            return t * (1 - n) + e * n;
          }
          down(t) {
            if (this.isDown) return;
            (this.isDown = !0), this.updateResolution();
            const e = t.touches ? t.touches[0].clientX : t.clientX,
              n = t.touches ? t.touches[0].clientY : t.clientY,
              i = this.normalize(e, n, this.w, this.h);
            (this.coords.normalize.x = i.x), (this.coords.normalize.y = i.y);
          }
          move(t) {
            if (!this.isDown) return;
            this.updateResolution();
            const e = t.touches ? t.touches[0].clientX : t.clientX,
              n = t.touches ? t.touches[0].clientY : t.clientY,
              i = this.normalize(e, n, this.w, this.h);
            (this.coords.normalize.x = i.x),
              (this.coords.normalize.y = i.y),
              clearTimeout(this.timer),
              (this.timer = setTimeout(() => {
                (this.coords.normalize.x = i.x),
                  (this.coords.normalize.y = i.y),
                  clearTimeout(this.timer);
              }, 100));
          }
          up() {
            this.isDown && (this.isDown = !1);
          }
          update() {
            (this.coords.normalize.lerp.x = this.lerp(
              this.coords.normalize.lerp.x,
              this.coords.normalize.x,
              this.coords.interpolation
            )),
              (this.coords.normalize.lerp.y = this.lerp(
                this.coords.normalize.lerp.y,
                this.coords.normalize.y,
                this.coords.interpolation
              ));
          }
        }
        /**
         * lil-gui
         * https://lil-gui.georgealways.com
         * @version 0.17.0
         * @author George Michael Brower
         * @license MIT
         */
        class wM {
          constructor(t, e, n, i, r = "div") {
            (this.parent = t),
              (this.object = e),
              (this.property = n),
              (this._disabled = !1),
              (this._hidden = !1),
              (this.initialValue = this.getValue()),
              (this.domElement = document.createElement("div")),
              this.domElement.classList.add("controller"),
              this.domElement.classList.add(i),
              (this.$name = document.createElement("div")),
              this.$name.classList.add("name"),
              (wM.nextNameID = wM.nextNameID || 0),
              (this.$name.id = "lil-gui-name-" + ++wM.nextNameID),
              (this.$widget = document.createElement(r)),
              this.$widget.classList.add("widget"),
              (this.$disable = this.$widget),
              this.domElement.appendChild(this.$name),
              this.domElement.appendChild(this.$widget),
              this.parent.children.push(this),
              this.parent.controllers.push(this),
              this.parent.$children.appendChild(this.domElement),
              (this._listenCallback = this._listenCallback.bind(this)),
              this.name(n);
          }
          name(t) {
            return (this._name = t), (this.$name.innerHTML = t), this;
          }
          onChange(t) {
            return (this._onChange = t), this;
          }
          _callOnChange() {
            this.parent._callOnChange(this),
              void 0 !== this._onChange &&
                this._onChange.call(this, this.getValue()),
              (this._changed = !0);
          }
          onFinishChange(t) {
            return (this._onFinishChange = t), this;
          }
          _callOnFinishChange() {
            this._changed &&
              (this.parent._callOnFinishChange(this),
              void 0 !== this._onFinishChange &&
                this._onFinishChange.call(this, this.getValue())),
              (this._changed = !1);
          }
          reset() {
            return (
              this.setValue(this.initialValue), this._callOnFinishChange(), this
            );
          }
          enable(t = !0) {
            return this.disable(!t);
          }
          disable(t = !0) {
            return (
              t === this._disabled ||
                ((this._disabled = t),
                this.domElement.classList.toggle("disabled", t),
                this.$disable.toggleAttribute("disabled", t)),
              this
            );
          }
          show(t = !0) {
            return (
              (this._hidden = !t),
              (this.domElement.style.display = this._hidden ? "none" : ""),
              this
            );
          }
          hide() {
            return this.show(!1);
          }
          options(t) {
            const e = this.parent.add(this.object, this.property, t);
            return e.name(this._name), this.destroy(), e;
          }
          min(t) {
            return this;
          }
          max(t) {
            return this;
          }
          step(t) {
            return this;
          }
          decimals(t) {
            return this;
          }
          listen(t = !0) {
            return (
              (this._listening = t),
              void 0 !== this._listenCallbackID &&
                (cancelAnimationFrame(this._listenCallbackID),
                (this._listenCallbackID = void 0)),
              this._listening && this._listenCallback(),
              this
            );
          }
          _listenCallback() {
            this._listenCallbackID = requestAnimationFrame(
              this._listenCallback
            );
            const t = this.save();
            t !== this._listenPrevValue && this.updateDisplay(),
              (this._listenPrevValue = t);
          }
          getValue() {
            return this.object[this.property];
          }
          setValue(t) {
            return (
              (this.object[this.property] = t),
              this._callOnChange(),
              this.updateDisplay(),
              this
            );
          }
          updateDisplay() {
            return this;
          }
          load(t) {
            return this.setValue(t), this._callOnFinishChange(), this;
          }
          save() {
            return this.getValue();
          }
          destroy() {
            this.listen(!1),
              this.parent.children.splice(
                this.parent.children.indexOf(this),
                1
              ),
              this.parent.controllers.splice(
                this.parent.controllers.indexOf(this),
                1
              ),
              this.parent.$children.removeChild(this.domElement);
          }
        }
        class EM extends wM {
          constructor(t, e, n) {
            super(t, e, n, "boolean", "label"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "checkbox"),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              this.$widget.appendChild(this.$input),
              this.$input.addEventListener("change", () => {
                this.setValue(this.$input.checked), this._callOnFinishChange();
              }),
              (this.$disable = this.$input),
              this.updateDisplay();
          }
          updateDisplay() {
            return (this.$input.checked = this.getValue()), this;
          }
        }
        function SM(t) {
          let e, n;
          return (
            (e = t.match(/(#|0x)?([a-f0-9]{6})/i))
              ? (n = e[2])
              : (e = t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
              ? (n =
                  parseInt(e[1]).toString(16).padStart(2, 0) +
                  parseInt(e[2]).toString(16).padStart(2, 0) +
                  parseInt(e[3]).toString(16).padStart(2, 0))
              : (e = t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
                (n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
            !!n && "#" + n
          );
        }
        const MM = {
            isPrimitive: !0,
            match: (t) => "string" == typeof t,
            fromHexString: SM,
            toHexString: SM,
          },
          TM = {
            isPrimitive: !0,
            match: (t) => "number" == typeof t,
            fromHexString: (t) => parseInt(t.substring(1), 16),
            toHexString: (t) => "#" + t.toString(16).padStart(6, 0),
          },
          AM = {
            isPrimitive: !1,
            match: Array.isArray,
            fromHexString(t, e, n = 1) {
              const i = TM.fromHexString(t);
              (e[0] = (((i >> 16) & 255) / 255) * n),
                (e[1] = (((i >> 8) & 255) / 255) * n),
                (e[2] = ((255 & i) / 255) * n);
            },
            toHexString: ([t, e, n], i = 1) =>
              TM.toHexString(
                ((t * (i = 255 / i)) << 16) ^ ((e * i) << 8) ^ (n * i)
              ),
          },
          RM = {
            isPrimitive: !1,
            match: (t) => Object(t) === t,
            fromHexString(t, e, n = 1) {
              const i = TM.fromHexString(t);
              (e.r = (((i >> 16) & 255) / 255) * n),
                (e.g = (((i >> 8) & 255) / 255) * n),
                (e.b = ((255 & i) / 255) * n);
            },
            toHexString: ({ r: t, g: e, b: n }, i = 1) =>
              TM.toHexString(
                ((t * (i = 255 / i)) << 16) ^ ((e * i) << 8) ^ (n * i)
              ),
          },
          CM = [MM, TM, AM, RM];
        class LM extends wM {
          constructor(t, e, n, i) {
            var r;
            super(t, e, n, "color"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "color"),
              this.$input.setAttribute("tabindex", -1),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              (this.$text = document.createElement("input")),
              this.$text.setAttribute("type", "text"),
              this.$text.setAttribute("spellcheck", "false"),
              this.$text.setAttribute("aria-labelledby", this.$name.id),
              (this.$display = document.createElement("div")),
              this.$display.classList.add("display"),
              this.$display.appendChild(this.$input),
              this.$widget.appendChild(this.$display),
              this.$widget.appendChild(this.$text),
              (this._format =
                ((r = this.initialValue), CM.find((t) => t.match(r)))),
              (this._rgbScale = i),
              (this._initialValueHexString = this.save()),
              (this._textFocused = !1),
              this.$input.addEventListener("input", () => {
                this._setValueFromHexString(this.$input.value);
              }),
              this.$input.addEventListener("blur", () => {
                this._callOnFinishChange();
              }),
              this.$text.addEventListener("input", () => {
                const t = SM(this.$text.value);
                t && this._setValueFromHexString(t);
              }),
              this.$text.addEventListener("focus", () => {
                (this._textFocused = !0), this.$text.select();
              }),
              this.$text.addEventListener("blur", () => {
                (this._textFocused = !1),
                  this.updateDisplay(),
                  this._callOnFinishChange();
              }),
              (this.$disable = this.$text),
              this.updateDisplay();
          }
          reset() {
            return (
              this._setValueFromHexString(this._initialValueHexString), this
            );
          }
          _setValueFromHexString(t) {
            if (this._format.isPrimitive) {
              const e = this._format.fromHexString(t);
              this.setValue(e);
            } else
              this._format.fromHexString(t, this.getValue(), this._rgbScale),
                this._callOnChange(),
                this.updateDisplay();
          }
          save() {
            return this._format.toHexString(this.getValue(), this._rgbScale);
          }
          load(t) {
            return (
              this._setValueFromHexString(t), this._callOnFinishChange(), this
            );
          }
          updateDisplay() {
            return (
              (this.$input.value = this._format.toHexString(
                this.getValue(),
                this._rgbScale
              )),
              this._textFocused ||
                (this.$text.value = this.$input.value.substring(1)),
              (this.$display.style.backgroundColor = this.$input.value),
              this
            );
          }
        }
        class PM extends wM {
          constructor(t, e, n) {
            super(t, e, n, "function"),
              (this.$button = document.createElement("button")),
              this.$button.appendChild(this.$name),
              this.$widget.appendChild(this.$button),
              this.$button.addEventListener("click", (t) => {
                t.preventDefault(), this.getValue().call(this.object);
              }),
              this.$button.addEventListener("touchstart", () => {}, {
                passive: !0,
              }),
              (this.$disable = this.$button);
          }
        }
        class OM extends wM {
          constructor(t, e, n, i, r, s) {
            super(t, e, n, "number"),
              this._initInput(),
              this.min(i),
              this.max(r);
            const o = void 0 !== s;
            this.step(o ? s : this._getImplicitStep(), o), this.updateDisplay();
          }
          decimals(t) {
            return (this._decimals = t), this.updateDisplay(), this;
          }
          min(t) {
            return (this._min = t), this._onUpdateMinMax(), this;
          }
          max(t) {
            return (this._max = t), this._onUpdateMinMax(), this;
          }
          step(t, e = !0) {
            return (this._step = t), (this._stepExplicit = e), this;
          }
          updateDisplay() {
            const t = this.getValue();
            if (this._hasSlider) {
              let e = (t - this._min) / (this._max - this._min);
              (e = Math.max(0, Math.min(e, 1))),
                (this.$fill.style.width = 100 * e + "%");
            }
            return (
              this._inputFocused ||
                (this.$input.value =
                  void 0 === this._decimals ? t : t.toFixed(this._decimals)),
              this
            );
          }
          _initInput() {
            (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "number"),
              this.$input.setAttribute("step", "any"),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              this.$widget.appendChild(this.$input),
              (this.$disable = this.$input);
            const t = (t) => {
              const e = parseFloat(this.$input.value);
              isNaN(e) ||
                (this._snapClampSetValue(e + t),
                (this.$input.value = this.getValue()));
            };
            let e,
              n,
              i,
              r,
              s,
              o = !1;
            const a = (t) => {
                if (o) {
                  const i = t.clientX - e,
                    r = t.clientY - n;
                  Math.abs(r) > 5
                    ? (t.preventDefault(),
                      this.$input.blur(),
                      (o = !1),
                      this._setDraggingStyle(!0, "vertical"))
                    : Math.abs(i) > 5 && l();
                }
                if (!o) {
                  const e = t.clientY - i;
                  (s -= e * this._step * this._arrowKeyMultiplier(t)),
                    r + s > this._max
                      ? (s = this._max - r)
                      : r + s < this._min && (s = this._min - r),
                    this._snapClampSetValue(r + s);
                }
                i = t.clientY;
              },
              l = () => {
                this._setDraggingStyle(!1, "vertical"),
                  this._callOnFinishChange(),
                  window.removeEventListener("mousemove", a),
                  window.removeEventListener("mouseup", l);
              };
            this.$input.addEventListener("input", () => {
              let t = parseFloat(this.$input.value);
              isNaN(t) ||
                (this._stepExplicit && (t = this._snap(t)),
                this.setValue(this._clamp(t)));
            }),
              this.$input.addEventListener("keydown", (e) => {
                "Enter" === e.code && this.$input.blur(),
                  "ArrowUp" === e.code &&
                    (e.preventDefault(),
                    t(this._step * this._arrowKeyMultiplier(e))),
                  "ArrowDown" === e.code &&
                    (e.preventDefault(),
                    t(this._step * this._arrowKeyMultiplier(e) * -1));
              }),
              this.$input.addEventListener(
                "wheel",
                (e) => {
                  this._inputFocused &&
                    (e.preventDefault(),
                    t(this._step * this._normalizeMouseWheel(e)));
                },
                {
                  passive: !1,
                }
              ),
              this.$input.addEventListener("mousedown", (t) => {
                (e = t.clientX),
                  (n = i = t.clientY),
                  (o = !0),
                  (r = this.getValue()),
                  (s = 0),
                  window.addEventListener("mousemove", a),
                  window.addEventListener("mouseup", l);
              }),
              this.$input.addEventListener("focus", () => {
                this._inputFocused = !0;
              }),
              this.$input.addEventListener("blur", () => {
                (this._inputFocused = !1),
                  this.updateDisplay(),
                  this._callOnFinishChange();
              });
          }
          _initSlider() {
            (this._hasSlider = !0),
              (this.$slider = document.createElement("div")),
              this.$slider.classList.add("slider"),
              (this.$fill = document.createElement("div")),
              this.$fill.classList.add("fill"),
              this.$slider.appendChild(this.$fill),
              this.$widget.insertBefore(this.$slider, this.$input),
              this.domElement.classList.add("hasSlider");
            const t = (t) => {
                const e = this.$slider.getBoundingClientRect();
                let n =
                  ((i = t),
                  (r = e.left),
                  (s = e.right),
                  (o = this._min),
                  ((i - r) / (s - r)) * (this._max - o) + o);
                var i, r, s, o;
                this._snapClampSetValue(n);
              },
              e = (e) => {
                t(e.clientX);
              },
              n = () => {
                this._callOnFinishChange(),
                  this._setDraggingStyle(!1),
                  window.removeEventListener("mousemove", e),
                  window.removeEventListener("mouseup", n);
              };
            let i,
              r,
              s = !1;
            const o = (e) => {
                e.preventDefault(),
                  this._setDraggingStyle(!0),
                  t(e.touches[0].clientX),
                  (s = !1);
              },
              a = (e) => {
                if (s) {
                  const t = e.touches[0].clientX - i,
                    n = e.touches[0].clientY - r;
                  Math.abs(t) > Math.abs(n)
                    ? o(e)
                    : (window.removeEventListener("touchmove", a),
                      window.removeEventListener("touchend", l));
                } else e.preventDefault(), t(e.touches[0].clientX);
              },
              l = () => {
                this._callOnFinishChange(),
                  this._setDraggingStyle(!1),
                  window.removeEventListener("touchmove", a),
                  window.removeEventListener("touchend", l);
              },
              c = this._callOnFinishChange.bind(this);
            let u;
            this.$slider.addEventListener("mousedown", (i) => {
              this._setDraggingStyle(!0),
                t(i.clientX),
                window.addEventListener("mousemove", e),
                window.addEventListener("mouseup", n);
            }),
              this.$slider.addEventListener(
                "touchstart",
                (t) => {
                  t.touches.length > 1 ||
                    (this._hasScrollBar
                      ? ((i = t.touches[0].clientX),
                        (r = t.touches[0].clientY),
                        (s = !0))
                      : o(t),
                    window.addEventListener("touchmove", a, {
                      passive: !1,
                    }),
                    window.addEventListener("touchend", l));
                },
                {
                  passive: !1,
                }
              ),
              this.$slider.addEventListener(
                "wheel",
                (t) => {
                  if (
                    Math.abs(t.deltaX) < Math.abs(t.deltaY) &&
                    this._hasScrollBar
                  )
                    return;
                  t.preventDefault();
                  const e = this._normalizeMouseWheel(t) * this._step;
                  this._snapClampSetValue(this.getValue() + e),
                    (this.$input.value = this.getValue()),
                    clearTimeout(u),
                    (u = setTimeout(c, 400));
                },
                {
                  passive: !1,
                }
              );
          }
          _setDraggingStyle(t, e = "horizontal") {
            this.$slider && this.$slider.classList.toggle("active", t),
              document.body.classList.toggle("lil-gui-dragging", t),
              document.body.classList.toggle("lil-gui-" + e, t);
          }
          _getImplicitStep() {
            return this._hasMin && this._hasMax
              ? (this._max - this._min) / 1e3
              : 0.1;
          }
          _onUpdateMinMax() {
            !this._hasSlider &&
              this._hasMin &&
              this._hasMax &&
              (this._stepExplicit || this.step(this._getImplicitStep(), !1),
              this._initSlider(),
              this.updateDisplay());
          }
          _normalizeMouseWheel(t) {
            let { deltaX: e, deltaY: n } = t;
            return (
              Math.floor(t.deltaY) !== t.deltaY &&
                t.wheelDelta &&
                ((e = 0),
                (n = -t.wheelDelta / 120),
                (n *= this._stepExplicit ? 1 : 10)),
              e + -n
            );
          }
          _arrowKeyMultiplier(t) {
            let e = this._stepExplicit ? 1 : 10;
            return t.shiftKey ? (e *= 10) : t.altKey && (e /= 10), e;
          }
          _snap(t) {
            const e = Math.round(t / this._step) * this._step;
            return parseFloat(e.toPrecision(15));
          }
          _clamp(t) {
            return (
              t < this._min && (t = this._min),
              t > this._max && (t = this._max),
              t
            );
          }
          _snapClampSetValue(t) {
            this.setValue(this._clamp(this._snap(t)));
          }
          get _hasScrollBar() {
            const t = this.parent.root.$children;
            return t.scrollHeight > t.clientHeight;
          }
          get _hasMin() {
            return void 0 !== this._min;
          }
          get _hasMax() {
            return void 0 !== this._max;
          }
        }
        class IM extends wM {
          constructor(t, e, n, i) {
            super(t, e, n, "option"),
              (this.$select = document.createElement("select")),
              this.$select.setAttribute("aria-labelledby", this.$name.id),
              (this.$display = document.createElement("div")),
              this.$display.classList.add("display"),
              (this._values = Array.isArray(i) ? i : Object.values(i)),
              (this._names = Array.isArray(i) ? i : Object.keys(i)),
              this._names.forEach((t) => {
                const e = document.createElement("option");
                (e.innerHTML = t), this.$select.appendChild(e);
              }),
              this.$select.addEventListener("change", () => {
                this.setValue(this._values[this.$select.selectedIndex]),
                  this._callOnFinishChange();
              }),
              this.$select.addEventListener("focus", () => {
                this.$display.classList.add("focus");
              }),
              this.$select.addEventListener("blur", () => {
                this.$display.classList.remove("focus");
              }),
              this.$widget.appendChild(this.$select),
              this.$widget.appendChild(this.$display),
              (this.$disable = this.$select),
              this.updateDisplay();
          }
          updateDisplay() {
            const t = this.getValue(),
              e = this._values.indexOf(t);
            return (
              (this.$select.selectedIndex = e),
              (this.$display.innerHTML = -1 === e ? t : this._names[e]),
              this
            );
          }
        }
        class NM extends wM {
          constructor(t, e, n) {
            super(t, e, n, "string"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "text"),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              this.$input.addEventListener("input", () => {
                this.setValue(this.$input.value);
              }),
              this.$input.addEventListener("keydown", (t) => {
                "Enter" === t.code && this.$input.blur();
              }),
              this.$input.addEventListener("blur", () => {
                this._callOnFinishChange();
              }),
              this.$widget.appendChild(this.$input),
              (this.$disable = this.$input),
              this.updateDisplay();
          }
          updateDisplay() {
            return (this.$input.value = this.getValue()), this;
          }
        }
        let DM = !1;
        class UM {
          constructor({
            parent: t,
            autoPlace: e = void 0 === t,
            container: n,
            width: i,
            title: r = "Controls",
            injectStyles: s = !0,
            touchStyles: o = !0,
          } = {}) {
            if (
              ((this.parent = t),
              (this.root = t ? t.root : this),
              (this.children = []),
              (this.controllers = []),
              (this.folders = []),
              (this._closed = !1),
              (this._hidden = !1),
              (this.domElement = document.createElement("div")),
              this.domElement.classList.add("lil-gui"),
              (this.$title = document.createElement("div")),
              this.$title.classList.add("title"),
              this.$title.setAttribute("role", "button"),
              this.$title.setAttribute("aria-expanded", !0),
              this.$title.setAttribute("tabindex", 0),
              this.$title.addEventListener("click", () =>
                this.openAnimated(this._closed)
              ),
              this.$title.addEventListener("keydown", (t) => {
                ("Enter" !== t.code && "Space" !== t.code) ||
                  (t.preventDefault(), this.$title.click());
              }),
              this.$title.addEventListener("touchstart", () => {}, {
                passive: !0,
              }),
              (this.$children = document.createElement("div")),
              this.$children.classList.add("children"),
              this.domElement.appendChild(this.$title),
              this.domElement.appendChild(this.$children),
              this.title(r),
              o && this.domElement.classList.add("allow-touch-styles"),
              this.parent)
            )
              return (
                this.parent.children.push(this),
                this.parent.folders.push(this),
                void this.parent.$children.appendChild(this.domElement)
              );
            this.domElement.classList.add("root"),
              !DM &&
                s &&
                ((function (t) {
                  const e = document.createElement("style");
                  e.innerHTML =
                    '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}';
                  const n = document.querySelector(
                    "head link[rel=stylesheet], head style"
                  );
                  n
                    ? document.head.insertBefore(e, n)
                    : document.head.appendChild(e);
                })(),
                (DM = !0)),
              n
                ? n.appendChild(this.domElement)
                : e &&
                  (this.domElement.classList.add("autoPlace"),
                  document.body.appendChild(this.domElement)),
              i && this.domElement.style.setProperty("--width", i + "px"),
              this.domElement.addEventListener("keydown", (t) =>
                t.stopPropagation()
              ),
              this.domElement.addEventListener("keyup", (t) =>
                t.stopPropagation()
              );
          }
          add(t, e, n, i, r) {
            if (Object(n) === n) return new IM(this, t, e, n);
            const s = t[e];
            switch (typeof s) {
              case "number":
                return new OM(this, t, e, n, i, r);
              case "boolean":
                return new EM(this, t, e);
              case "string":
                return new NM(this, t, e);
              case "function":
                return new PM(this, t, e);
            }
            console.error(
              "gui.add failed\n\tproperty:",
              e,
              "\n\tobject:",
              t,
              "\n\tvalue:",
              s
            );
          }
          addColor(t, e, n = 1) {
            return new LM(this, t, e, n);
          }
          addFolder(t) {
            return new UM({
              parent: this,
              title: t,
            });
          }
          load(t, e = !0) {
            return (
              t.controllers &&
                this.controllers.forEach((e) => {
                  e instanceof PM ||
                    (e._name in t.controllers &&
                      e.load(t.controllers[e._name]));
                }),
              e &&
                t.folders &&
                this.folders.forEach((e) => {
                  e._title in t.folders && e.load(t.folders[e._title]);
                }),
              this
            );
          }
          save(t = !0) {
            const e = {
              controllers: {},
              folders: {},
            };
            return (
              this.controllers.forEach((t) => {
                if (!(t instanceof PM)) {
                  if (t._name in e.controllers)
                    throw new Error(
                      `Cannot save GUI with duplicate property "${t._name}"`
                    );
                  e.controllers[t._name] = t.save();
                }
              }),
              t &&
                this.folders.forEach((t) => {
                  if (t._title in e.folders)
                    throw new Error(
                      `Cannot save GUI with duplicate folder "${t._title}"`
                    );
                  e.folders[t._title] = t.save();
                }),
              e
            );
          }
          open(t = !0) {
            return (
              (this._closed = !t),
              this.$title.setAttribute("aria-expanded", !this._closed),
              this.domElement.classList.toggle("closed", this._closed),
              this
            );
          }
          close() {
            return this.open(!1);
          }
          show(t = !0) {
            return (
              (this._hidden = !t),
              (this.domElement.style.display = this._hidden ? "none" : ""),
              this
            );
          }
          hide() {
            return this.show(!1);
          }
          openAnimated(t = !0) {
            return (
              (this._closed = !t),
              this.$title.setAttribute("aria-expanded", !this._closed),
              requestAnimationFrame(() => {
                const e = this.$children.clientHeight;
                (this.$children.style.height = e + "px"),
                  this.domElement.classList.add("transition");
                const n = (t) => {
                  t.target === this.$children &&
                    ((this.$children.style.height = ""),
                    this.domElement.classList.remove("transition"),
                    this.$children.removeEventListener("transitionend", n));
                };
                this.$children.addEventListener("transitionend", n);
                const i = t ? this.$children.scrollHeight : 0;
                this.domElement.classList.toggle("closed", !t),
                  requestAnimationFrame(() => {
                    this.$children.style.height = i + "px";
                  });
              }),
              this
            );
          }
          title(t) {
            return (this._title = t), (this.$title.innerHTML = t), this;
          }
          reset(t = !0) {
            return (
              (t ? this.controllersRecursive() : this.controllers).forEach(
                (t) => t.reset()
              ),
              this
            );
          }
          onChange(t) {
            return (this._onChange = t), this;
          }
          _callOnChange(t) {
            this.parent && this.parent._callOnChange(t),
              void 0 !== this._onChange &&
                this._onChange.call(this, {
                  object: t.object,
                  property: t.property,
                  value: t.getValue(),
                  controller: t,
                });
          }
          onFinishChange(t) {
            return (this._onFinishChange = t), this;
          }
          _callOnFinishChange(t) {
            this.parent && this.parent._callOnFinishChange(t),
              void 0 !== this._onFinishChange &&
                this._onFinishChange.call(this, {
                  object: t.object,
                  property: t.property,
                  value: t.getValue(),
                  controller: t,
                });
          }
          destroy() {
            this.parent &&
              (this.parent.children.splice(
                this.parent.children.indexOf(this),
                1
              ),
              this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
              this.domElement.parentElement &&
                this.domElement.parentElement.removeChild(this.domElement),
              Array.from(this.children).forEach((t) => t.destroy());
          }
          controllersRecursive() {
            let t = Array.from(this.controllers);
            return (
              this.folders.forEach((e) => {
                t = t.concat(e.controllersRecursive());
              }),
              t
            );
          }
          foldersRecursive() {
            let t = Array.from(this.folders);
            return (
              this.folders.forEach((e) => {
                t = t.concat(e.foldersRecursive());
              }),
              t
            );
          }
        }
        const FM = UM;
        var kM = function () {
          var t = 0,
            e = document.createElement("div");
          function n(t) {
            return e.appendChild(t.dom), t;
          }
          function i(n) {
            for (var i = 0; i < e.children.length; i++)
              e.children[i].style.display = i === n ? "block" : "none";
            t = n;
          }
          (e.style.cssText =
            "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
            e.addEventListener(
              "click",
              function (n) {
                n.preventDefault(), i(++t % e.children.length);
              },
              !1
            );
          var r = (performance || Date).now(),
            s = r,
            o = 0,
            a = n(new kM.Panel("FPS", "#0ff", "#002")),
            l = n(new kM.Panel("MS", "#0f0", "#020"));
          if (self.performance && self.performance.memory)
            var c = n(new kM.Panel("MB", "#f08", "#201"));
          return (
            i(0),
            {
              REVISION: 16,
              dom: e,
              addPanel: n,
              showPanel: i,
              begin: function () {
                r = (performance || Date).now();
              },
              end: function () {
                o++;
                var t = (performance || Date).now();
                if (
                  (l.update(t - r, 200),
                  t >= s + 1e3 &&
                    (a.update((1e3 * o) / (t - s), 100), (s = t), (o = 0), c))
                ) {
                  var e = performance.memory;
                  c.update(
                    e.usedJSHeapSize / 1048576,
                    e.jsHeapSizeLimit / 1048576
                  );
                }
                return t;
              },
              update: function () {
                r = this.end();
              },
              domElement: e,
              setMode: i,
            }
          );
        };
        kM.Panel = function (t, e, n) {
          var i = 1 / 0,
            r = 0,
            s = Math.round,
            o = s(window.devicePixelRatio || 1),
            a = 80 * o,
            l = 48 * o,
            c = 3 * o,
            u = 2 * o,
            h = 3 * o,
            d = 15 * o,
            p = 74 * o,
            f = 30 * o,
            m = document.createElement("canvas");
          (m.width = a),
            (m.height = l),
            (m.style.cssText = "width:80px;height:48px");
          var g = m.getContext("2d");
          return (
            (g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif"),
            (g.textBaseline = "top"),
            (g.fillStyle = n),
            g.fillRect(0, 0, a, l),
            (g.fillStyle = e),
            g.fillText(t, c, u),
            g.fillRect(h, d, p, f),
            (g.fillStyle = n),
            (g.globalAlpha = 0.9),
            g.fillRect(h, d, p, f),
            {
              dom: m,
              update: function (l, v) {
                (i = Math.min(i, l)),
                  (r = Math.max(r, l)),
                  (g.fillStyle = n),
                  (g.globalAlpha = 1),
                  g.fillRect(0, 0, a, d),
                  (g.fillStyle = e),
                  g.fillText(
                    s(l) + " " + t + " (" + s(i) + "-" + s(r) + ")",
                    c,
                    u
                  ),
                  g.drawImage(m, h + o, d, p - o, f, h, d, p - o, f),
                  g.fillRect(h + p - o, d, o, f),
                  (g.fillStyle = n),
                  (g.globalAlpha = 0.9),
                  g.fillRect(h + p - o, d, o, s((1 - l / v) * f));
              },
            }
          );
        };
        const BM = kM,
          zM = {
            type: "change",
          },
          HM = {
            type: "start",
          },
          VM = {
            type: "end",
          },
          GM = new vf(),
          WM = new ug(),
          jM = Math.cos(70 * dp.DEG2RAD);
        class qM extends Jd {
          constructor(t, e) {
            super(),
              (this.object = t),
              (this.domElement = e),
              (this.domElement.style.touchAction = "none"),
              (this.enabled = !0),
              (this.target = new Hp()),
              (this.minDistance = 0),
              (this.maxDistance = 1 / 0),
              (this.minZoom = 0),
              (this.maxZoom = 1 / 0),
              (this.minPolarAngle = 0),
              (this.maxPolarAngle = Math.PI),
              (this.minAzimuthAngle = -1 / 0),
              (this.maxAzimuthAngle = 1 / 0),
              (this.enableDamping = !1),
              (this.dampingFactor = 0.05),
              (this.enableZoom = !0),
              (this.zoomSpeed = 1),
              (this.enableRotate = !0),
              (this.rotateSpeed = 1),
              (this.enablePan = !0),
              (this.panSpeed = 1),
              (this.screenSpacePanning = !0),
              (this.keyPanSpeed = 7),
              (this.zoomToCursor = !1),
              (this.autoRotate = !1),
              (this.autoRotateSpeed = 2),
              (this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown",
              }),
              (this.mouseButtons = {
                LEFT: gh,
                MIDDLE: vh,
                RIGHT: yh,
              }),
              (this.touches = {
                ONE: _h,
                TWO: bh,
              }),
              (this.target0 = this.target.clone()),
              (this.position0 = this.object.position.clone()),
              (this.zoom0 = this.object.zoom),
              (this._domElementKeyEvents = null),
              (this.getPolarAngle = function () {
                return o.phi;
              }),
              (this.getAzimuthalAngle = function () {
                return o.theta;
              }),
              (this.getDistance = function () {
                return this.object.position.distanceTo(this.target);
              }),
              (this.listenToKeyEvents = function (t) {
                t.addEventListener("keydown", q),
                  (this._domElementKeyEvents = t);
              }),
              (this.stopListenToKeyEvents = function () {
                this._domElementKeyEvents.removeEventListener("keydown", q),
                  (this._domElementKeyEvents = null);
              }),
              (this.saveState = function () {
                n.target0.copy(n.target),
                  n.position0.copy(n.object.position),
                  (n.zoom0 = n.object.zoom);
              }),
              (this.reset = function () {
                n.target.copy(n.target0),
                  n.object.position.copy(n.position0),
                  (n.object.zoom = n.zoom0),
                  n.object.updateProjectionMatrix(),
                  n.dispatchEvent(zM),
                  n.update(),
                  (r = i.NONE);
              }),
              (this.update = (function () {
                const e = new Hp(),
                  u = new zp().setFromUnitVectors(t.up, new Hp(0, 1, 0)),
                  h = u.clone().invert(),
                  d = new Hp(),
                  p = new zp(),
                  f = new Hp(),
                  m = 2 * Math.PI;
                return function (g = null) {
                  const v = n.object.position;
                  e.copy(v).sub(n.target),
                    e.applyQuaternion(u),
                    o.setFromVector3(e),
                    n.autoRotate &&
                      r === i.NONE &&
                      M(
                        (function (t) {
                          return null !== t
                            ? ((2 * Math.PI) / 60) * n.autoRotateSpeed * t
                            : ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
                        })(g)
                      ),
                    n.enableDamping
                      ? ((o.theta += a.theta * n.dampingFactor),
                        (o.phi += a.phi * n.dampingFactor))
                      : ((o.theta += a.theta), (o.phi += a.phi));
                  let y = n.minAzimuthAngle,
                    w = n.maxAzimuthAngle;
                  isFinite(y) &&
                    isFinite(w) &&
                    (y < -Math.PI ? (y += m) : y > Math.PI && (y -= m),
                    w < -Math.PI ? (w += m) : w > Math.PI && (w -= m),
                    (o.theta =
                      y <= w
                        ? Math.max(y, Math.min(w, o.theta))
                        : o.theta > (y + w) / 2
                        ? Math.max(y, o.theta)
                        : Math.min(w, o.theta))),
                    (o.phi = Math.max(
                      n.minPolarAngle,
                      Math.min(n.maxPolarAngle, o.phi)
                    )),
                    o.makeSafe(),
                    !0 === n.enableDamping
                      ? n.target.addScaledVector(c, n.dampingFactor)
                      : n.target.add(c),
                    (n.zoomToCursor && b) || n.object.isOrthographicCamera
                      ? (o.radius = I(o.radius))
                      : (o.radius = I(o.radius * l)),
                    e.setFromSpherical(o),
                    e.applyQuaternion(h),
                    v.copy(n.target).add(e),
                    n.object.lookAt(n.target),
                    !0 === n.enableDamping
                      ? ((a.theta *= 1 - n.dampingFactor),
                        (a.phi *= 1 - n.dampingFactor),
                        c.multiplyScalar(1 - n.dampingFactor))
                      : (a.set(0, 0, 0), c.set(0, 0, 0));
                  let E = !1;
                  if (n.zoomToCursor && b) {
                    let i = null;
                    if (n.object.isPerspectiveCamera) {
                      const t = e.length();
                      i = I(t * l);
                      const r = t - i;
                      n.object.position.addScaledVector(_, r),
                        n.object.updateMatrixWorld();
                    } else if (n.object.isOrthographicCamera) {
                      const t = new Hp(x.x, x.y, 0);
                      t.unproject(n.object),
                        (n.object.zoom = Math.max(
                          n.minZoom,
                          Math.min(n.maxZoom, n.object.zoom / l)
                        )),
                        n.object.updateProjectionMatrix(),
                        (E = !0);
                      const r = new Hp(x.x, x.y, 0);
                      r.unproject(n.object),
                        n.object.position.sub(r).add(t),
                        n.object.updateMatrixWorld(),
                        (i = e.length());
                    } else
                      console.warn(
                        "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
                      ),
                        (n.zoomToCursor = !1);
                    null !== i &&
                      (this.screenSpacePanning
                        ? n.target
                            .set(0, 0, -1)
                            .transformDirection(n.object.matrix)
                            .multiplyScalar(i)
                            .add(n.object.position)
                        : (GM.origin.copy(n.object.position),
                          GM.direction
                            .set(0, 0, -1)
                            .transformDirection(n.object.matrix),
                          Math.abs(n.object.up.dot(GM.direction)) < jM
                            ? t.lookAt(n.target)
                            : (WM.setFromNormalAndCoplanarPoint(
                                n.object.up,
                                n.target
                              ),
                              GM.intersectPlane(WM, n.target))));
                  } else
                    n.object.isOrthographicCamera &&
                      ((n.object.zoom = Math.max(
                        n.minZoom,
                        Math.min(n.maxZoom, n.object.zoom / l)
                      )),
                      n.object.updateProjectionMatrix(),
                      (E = !0));
                  return (
                    (l = 1),
                    (b = !1),
                    !!(
                      E ||
                      d.distanceToSquared(n.object.position) > s ||
                      8 * (1 - p.dot(n.object.quaternion)) > s ||
                      f.distanceToSquared(n.target) > 0
                    ) &&
                      (n.dispatchEvent(zM),
                      d.copy(n.object.position),
                      p.copy(n.object.quaternion),
                      f.copy(n.target),
                      (E = !1),
                      !0)
                  );
                };
              })()),
              (this.dispose = function () {
                n.domElement.removeEventListener("contextmenu", X),
                  n.domElement.removeEventListener("pointerdown", V),
                  n.domElement.removeEventListener("pointercancel", W),
                  n.domElement.removeEventListener("wheel", j),
                  n.domElement.removeEventListener("pointermove", G),
                  n.domElement.removeEventListener("pointerup", W),
                  null !== n._domElementKeyEvents &&
                    (n._domElementKeyEvents.removeEventListener("keydown", q),
                    (n._domElementKeyEvents = null));
              });
            const n = this,
              i = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6,
              };
            let r = i.NONE;
            const s = 1e-6,
              o = new qx(),
              a = new qx();
            let l = 1;
            const c = new Hp(),
              u = new pp(),
              h = new pp(),
              d = new pp(),
              p = new pp(),
              f = new pp(),
              m = new pp(),
              g = new pp(),
              v = new pp(),
              y = new pp(),
              _ = new Hp(),
              x = new pp();
            let b = !1;
            const w = [],
              E = {};
            function S() {
              return Math.pow(0.95, n.zoomSpeed);
            }
            function M(t) {
              a.theta -= t;
            }
            function T(t) {
              a.phi -= t;
            }
            const A = (function () {
                const t = new Hp();
                return function (e, n) {
                  t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t);
                };
              })(),
              R = (function () {
                const t = new Hp();
                return function (e, i) {
                  !0 === n.screenSpacePanning
                    ? t.setFromMatrixColumn(i, 1)
                    : (t.setFromMatrixColumn(i, 0),
                      t.crossVectors(n.object.up, t)),
                    t.multiplyScalar(e),
                    c.add(t);
                };
              })(),
              C = (function () {
                const t = new Hp();
                return function (e, i) {
                  const r = n.domElement;
                  if (n.object.isPerspectiveCamera) {
                    const s = n.object.position;
                    t.copy(s).sub(n.target);
                    let o = t.length();
                    (o *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
                      A((2 * e * o) / r.clientHeight, n.object.matrix),
                      R((2 * i * o) / r.clientHeight, n.object.matrix);
                  } else
                    n.object.isOrthographicCamera
                      ? (A(
                          (e * (n.object.right - n.object.left)) /
                            n.object.zoom /
                            r.clientWidth,
                          n.object.matrix
                        ),
                        R(
                          (i * (n.object.top - n.object.bottom)) /
                            n.object.zoom /
                            r.clientHeight,
                          n.object.matrix
                        ))
                      : (console.warn(
                          "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                        ),
                        (n.enablePan = !1));
                };
              })();
            function L(t) {
              n.object.isPerspectiveCamera || n.object.isOrthographicCamera
                ? (l /= t)
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (n.enableZoom = !1));
            }
            function P(t) {
              n.object.isPerspectiveCamera || n.object.isOrthographicCamera
                ? (l *= t)
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (n.enableZoom = !1));
            }
            function O(t) {
              if (!n.zoomToCursor) return;
              b = !0;
              const e = n.domElement.getBoundingClientRect(),
                i = t.clientX - e.left,
                r = t.clientY - e.top,
                s = e.width,
                o = e.height;
              (x.x = (i / s) * 2 - 1),
                (x.y = (-r / o) * 2 + 1),
                _.set(x.x, x.y, 1)
                  .unproject(n.object)
                  .sub(n.object.position)
                  .normalize();
            }
            function I(t) {
              return Math.max(n.minDistance, Math.min(n.maxDistance, t));
            }
            function N(t) {
              u.set(t.clientX, t.clientY);
            }
            function D(t) {
              p.set(t.clientX, t.clientY);
            }
            function U() {
              if (1 === w.length) u.set(w[0].pageX, w[0].pageY);
              else {
                const t = 0.5 * (w[0].pageX + w[1].pageX),
                  e = 0.5 * (w[0].pageY + w[1].pageY);
                u.set(t, e);
              }
            }
            function F() {
              if (1 === w.length) p.set(w[0].pageX, w[0].pageY);
              else {
                const t = 0.5 * (w[0].pageX + w[1].pageX),
                  e = 0.5 * (w[0].pageY + w[1].pageY);
                p.set(t, e);
              }
            }
            function k() {
              const t = w[0].pageX - w[1].pageX,
                e = w[0].pageY - w[1].pageY,
                n = Math.sqrt(t * t + e * e);
              g.set(0, n);
            }
            function B(t) {
              if (1 == w.length) h.set(t.pageX, t.pageY);
              else {
                const e = K(t),
                  n = 0.5 * (t.pageX + e.x),
                  i = 0.5 * (t.pageY + e.y);
                h.set(n, i);
              }
              d.subVectors(h, u).multiplyScalar(n.rotateSpeed);
              const e = n.domElement;
              M((2 * Math.PI * d.x) / e.clientHeight),
                T((2 * Math.PI * d.y) / e.clientHeight),
                u.copy(h);
            }
            function z(t) {
              if (1 === w.length) f.set(t.pageX, t.pageY);
              else {
                const e = K(t),
                  n = 0.5 * (t.pageX + e.x),
                  i = 0.5 * (t.pageY + e.y);
                f.set(n, i);
              }
              m.subVectors(f, p).multiplyScalar(n.panSpeed),
                C(m.x, m.y),
                p.copy(f);
            }
            function H(t) {
              const e = K(t),
                i = t.pageX - e.x,
                r = t.pageY - e.y,
                s = Math.sqrt(i * i + r * r);
              v.set(0, s),
                y.set(0, Math.pow(v.y / g.y, n.zoomSpeed)),
                L(y.y),
                g.copy(v);
            }
            function V(t) {
              !1 !== n.enabled &&
                (0 === w.length &&
                  (n.domElement.setPointerCapture(t.pointerId),
                  n.domElement.addEventListener("pointermove", G),
                  n.domElement.addEventListener("pointerup", W)),
                (function (t) {
                  w.push(t);
                })(t),
                "touch" === t.pointerType
                  ? (function (t) {
                      switch ((Y(t), w.length)) {
                        case 1:
                          switch (n.touches.ONE) {
                            case _h:
                              if (!1 === n.enableRotate) return;
                              U(), (r = i.TOUCH_ROTATE);
                              break;
                            case xh:
                              if (!1 === n.enablePan) return;
                              F(), (r = i.TOUCH_PAN);
                              break;
                            default:
                              r = i.NONE;
                          }
                          break;
                        case 2:
                          switch (n.touches.TWO) {
                            case bh:
                              if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                              n.enableZoom && k(),
                                n.enablePan && F(),
                                (r = i.TOUCH_DOLLY_PAN);
                              break;
                            case wh:
                              if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                              n.enableZoom && k(),
                                n.enableRotate && U(),
                                (r = i.TOUCH_DOLLY_ROTATE);
                              break;
                            default:
                              r = i.NONE;
                          }
                          break;
                        default:
                          r = i.NONE;
                      }
                      r !== i.NONE && n.dispatchEvent(HM);
                    })(t)
                  : (function (t) {
                      let e;
                      switch (t.button) {
                        case 0:
                          e = n.mouseButtons.LEFT;
                          break;
                        case 1:
                          e = n.mouseButtons.MIDDLE;
                          break;
                        case 2:
                          e = n.mouseButtons.RIGHT;
                          break;
                        default:
                          e = -1;
                      }
                      switch (e) {
                        case vh:
                          if (!1 === n.enableZoom) return;
                          !(function (t) {
                            O(t), g.set(t.clientX, t.clientY);
                          })(t),
                            (r = i.DOLLY);
                          break;
                        case gh:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan) return;
                            D(t), (r = i.PAN);
                          } else {
                            if (!1 === n.enableRotate) return;
                            N(t), (r = i.ROTATE);
                          }
                          break;
                        case yh:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate) return;
                            N(t), (r = i.ROTATE);
                          } else {
                            if (!1 === n.enablePan) return;
                            D(t), (r = i.PAN);
                          }
                          break;
                        default:
                          r = i.NONE;
                      }
                      r !== i.NONE && n.dispatchEvent(HM);
                    })(t));
            }
            function G(t) {
              !1 !== n.enabled &&
                ("touch" === t.pointerType
                  ? (function (t) {
                      switch ((Y(t), r)) {
                        case i.TOUCH_ROTATE:
                          if (!1 === n.enableRotate) return;
                          B(t), n.update();
                          break;
                        case i.TOUCH_PAN:
                          if (!1 === n.enablePan) return;
                          z(t), n.update();
                          break;
                        case i.TOUCH_DOLLY_PAN:
                          if (!1 === n.enableZoom && !1 === n.enablePan) return;
                          !(function (t) {
                            n.enableZoom && H(t), n.enablePan && z(t);
                          })(t),
                            n.update();
                          break;
                        case i.TOUCH_DOLLY_ROTATE:
                          if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                          !(function (t) {
                            n.enableZoom && H(t), n.enableRotate && B(t);
                          })(t),
                            n.update();
                          break;
                        default:
                          r = i.NONE;
                      }
                    })(t)
                  : (function (t) {
                      switch (r) {
                        case i.ROTATE:
                          if (!1 === n.enableRotate) return;
                          !(function (t) {
                            h.set(t.clientX, t.clientY),
                              d.subVectors(h, u).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            M((2 * Math.PI * d.x) / e.clientHeight),
                              T((2 * Math.PI * d.y) / e.clientHeight),
                              u.copy(h),
                              n.update();
                          })(t);
                          break;
                        case i.DOLLY:
                          if (!1 === n.enableZoom) return;
                          !(function (t) {
                            v.set(t.clientX, t.clientY),
                              y.subVectors(v, g),
                              y.y > 0 ? L(S()) : y.y < 0 && P(S()),
                              g.copy(v),
                              n.update();
                          })(t);
                          break;
                        case i.PAN:
                          if (!1 === n.enablePan) return;
                          !(function (t) {
                            f.set(t.clientX, t.clientY),
                              m.subVectors(f, p).multiplyScalar(n.panSpeed),
                              C(m.x, m.y),
                              p.copy(f),
                              n.update();
                          })(t);
                      }
                    })(t));
            }
            function W(t) {
              !(function (t) {
                delete E[t.pointerId];
                for (let e = 0; e < w.length; e++)
                  if (w[e].pointerId == t.pointerId) return void w.splice(e, 1);
              })(t),
                0 === w.length &&
                  (n.domElement.releasePointerCapture(t.pointerId),
                  n.domElement.removeEventListener("pointermove", G),
                  n.domElement.removeEventListener("pointerup", W)),
                n.dispatchEvent(VM),
                (r = i.NONE);
            }
            function j(t) {
              !1 !== n.enabled &&
                !1 !== n.enableZoom &&
                r === i.NONE &&
                (t.preventDefault(),
                n.dispatchEvent(HM),
                (function (t) {
                  O(t),
                    t.deltaY < 0 ? P(S()) : t.deltaY > 0 && L(S()),
                    n.update();
                })(t),
                n.dispatchEvent(VM));
            }
            function q(t) {
              !1 !== n.enabled &&
                !1 !== n.enablePan &&
                (function (t) {
                  let e = !1;
                  switch (t.code) {
                    case n.keys.UP:
                      t.ctrlKey || t.metaKey || t.shiftKey
                        ? T(
                            (2 * Math.PI * n.rotateSpeed) /
                              n.domElement.clientHeight
                          )
                        : C(0, n.keyPanSpeed),
                        (e = !0);
                      break;
                    case n.keys.BOTTOM:
                      t.ctrlKey || t.metaKey || t.shiftKey
                        ? T(
                            (-2 * Math.PI * n.rotateSpeed) /
                              n.domElement.clientHeight
                          )
                        : C(0, -n.keyPanSpeed),
                        (e = !0);
                      break;
                    case n.keys.LEFT:
                      t.ctrlKey || t.metaKey || t.shiftKey
                        ? M(
                            (2 * Math.PI * n.rotateSpeed) /
                              n.domElement.clientHeight
                          )
                        : C(n.keyPanSpeed, 0),
                        (e = !0);
                      break;
                    case n.keys.RIGHT:
                      t.ctrlKey || t.metaKey || t.shiftKey
                        ? M(
                            (-2 * Math.PI * n.rotateSpeed) /
                              n.domElement.clientHeight
                          )
                        : C(-n.keyPanSpeed, 0),
                        (e = !0);
                  }
                  e && (t.preventDefault(), n.update());
                })(t);
            }
            function X(t) {
              !1 !== n.enabled && t.preventDefault();
            }
            function Y(t) {
              let e = E[t.pointerId];
              void 0 === e && ((e = new pp()), (E[t.pointerId] = e)),
                e.set(t.pageX, t.pageY);
            }
            function K(t) {
              const e = t.pointerId === w[0].pointerId ? w[1] : w[0];
              return E[e.pointerId];
            }
            n.domElement.addEventListener("contextmenu", X),
              n.domElement.addEventListener("pointerdown", V),
              n.domElement.addEventListener("pointercancel", W),
              n.domElement.addEventListener("wheel", j, {
                passive: !1,
              }),
              this.update();
          }
        }
        class XM {
          constructor(t, e) {
            (this.renderer = t),
              (this.camera = e),
              (window.GUI = null),
              (this.stats = null),
              (this.controls = null),
              this.setGui(),
              this.setStas(),
              this.setControls();
          }
          update() {
            null != this.stats && this.stats.update(),
              null != this.controls && this.controls.update();
          }
          setGui() {
            Kx.isGui && (window.GUI = new FM());
          }
          setStas() {
            Kx.isStats &&
              ((this.stats = new BM()),
              (this.stats.domElement.style =
                "position: fixed; top: 0; left: 0; right: initial; bottom: initial; z-index: 9999; opacity: 0.5;"),
              document.body.appendChild(this.stats.domElement));
          }
          setControls() {
            if (
              Kx.isControls &&
              ((this.controls = new qM(this.camera, this.renderer.domElement)),
              (this.controls.enableDamping = !0),
              (this.controls.dampingFactor = 0.2),
              Kx.isGui)
            ) {
              const t = window.GUI.addFolder("controls");
              t.close(),
                t.add(this.controls, "enabled").onChange((t) => {
                  this.controls.enabled = t;
                });
            }
          }
          disableDampingControls() {
            null != this.controls && (this.controls.enableDamping = !1);
          }
        }
        class YM extends bM {
          constructor(t, e) {
            const n = document.getElementById("world");
            if (
              (super(n, !1),
              (this.scene = null),
              (this.camera = null),
              (this.cameraRadianAngle = null),
              (this.renderer = null),
              (this.helpers = null),
              (this.element = n),
              (this.isMatchMediaWidth = t),
              (this.isMatchMediaHover = e),
              (this.pixelRatio = Math.min(2, window.devicePixelRatio)),
              (this.resolution = {
                x: window.innerWidth,
                y: window.innerHeight,
                aspect: this.element.clientWidth / this.element.clientHeight,
              }),
              (this.config = {
                cameraOffsetPosX: 0,
                cameraOffsetPosY: 0,
              }),
              (this.worldOriginPosition = new Hp(0, 0, 0)),
              (this.cameraTargetVector = new Hp()),
              (this.cannonWorld = new rM()),
              this.cannonWorld.gravity.set(0, 0, 0),
              (this.cannonWorldOriginPosition = new tb().set(0, 0, 0)),
              this.setRenderer(),
              this.setScene(),
              this.setCamera(),
              Kx.isHelpers &&
                (this.helpers = new XM(this.renderer, this.camera)),
              Kx.isGui)
            ) {
              const t = GUI.addFolder("camera");
              t
                .add(this.config, "cameraOffsetPosX", -10, 10, 0.1)
                .name("cameraOffsetPosX")
                .onChange((t) => {
                  (this.config.cameraOffsetPosX = t), this.updateCamera();
                })
                .listen(),
                t
                  .add(this.config, "cameraOffsetPosY", -10, 10, 0.1)
                  .name("cameraOffsetPosY")
                  .onChange((t) => {
                    (this.config.cameraOffsetPosY = t), this.updateCamera();
                  })
                  .listen();
            }
          }
          down(t) {
            super.down(t);
          }
          move(t) {
            super.move(t);
          }
          up(t) {
            super.up(t);
          }
          update() {
            super.update(),
              this.cannonWorld.fixedStep(),
              null != this.helpers && this.helpers.update();
          }
          resize(t, e) {
            (this.isMatchMediaWidth = t),
              (this.isMatchMediaHover = e),
              (this.resolution.x = this.element.clientWidth),
              (this.resolution.y = this.element.clientHeight),
              (this.resolution.aspect = this.resolution.x / this.resolution.y),
              this.updateRenderer(),
              this.updateCamera();
          }
          updateRenderer() {
            this.renderer.setSize(this.resolution.x, this.resolution.y),
              this.renderer.setPixelRatio(this.pixelRatio);
          }
          setRendererLight() {
            (this.renderer.shadowMap.enabled = !0),
              (this.renderer.shadowMap.needsUpdate = !0),
              (this.renderer.shadowMap.autoUpdate = !0),
              (this.renderer.shadowMap.type = Sh),
              (this.renderer.outputColorSpace = Dd),
              (this.renderer.toneMapping = $h),
              (this.renderer.toneMappingExposure = 1);
          }
          setRenderer() {
            (this.renderer = new Xy({
              antialias: !0,
              alpha: !0,
            })),
              this.setRendererLight(),
              this.updateRenderer(),
              this.element.appendChild(this.renderer.domElement);
          }
          updateCamera() {
            this.camera.aspect = this.resolution.aspect;
            const t = this.config.cameraOffsetPosX,
              e = this.config.cameraOffsetPosY;
            (this.camera.position.x = t),
              (this.camera.position.y = e),
              (this.cameraTargetVector.x = t),
              (this.cameraTargetVector.y = e),
              this.camera.lookAt(this.cameraTargetVector),
              this.camera.updateProjectionMatrix();
          }
          setCamera() {
            (this.camera = new ng()),
              (this.camera.fov = 60),
              (this.camera.near = 1),
              (this.camera.far = 60),
              (this.camera.position.z = 10),
              (this.cameraRadianAngle = xM.degreeToRadian(this.camera.fov)),
              this.updateCamera();
          }
          setScene() {
            (this.scene = new Yy()),
              Kx.isSceneHelper &&
                (this.scene.add(new Xx(1e3, 100)), this.scene.add(new Yx(100)));
          }
        }
        function KM(t, e) {
          if (0 === e)
            return (
              console.warn(
                "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
              ),
              t
            );
          if (2 === e || 1 === e) {
            let n = t.getIndex();
            if (null === n) {
              const e = [],
                i = t.getAttribute("position");
              if (void 0 === i)
                return (
                  console.error(
                    "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                  ),
                  t
                );
              for (let t = 0; t < i.count; t++) e.push(t);
              t.setIndex(e), (n = t.getIndex());
            }
            const i = n.count - 2,
              r = [];
            if (2 === e)
              for (let t = 1; t <= i; t++)
                r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
            else
              for (let t = 0; t < i; t++)
                t % 2 == 0
                  ? (r.push(n.getX(t)),
                    r.push(n.getX(t + 1)),
                    r.push(n.getX(t + 2)))
                  : (r.push(n.getX(t + 2)),
                    r.push(n.getX(t + 1)),
                    r.push(n.getX(t)));
            r.length / 3 !== i &&
              console.error(
                "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
              );
            const s = t.clone();
            return s.setIndex(r), s.clearGroups(), s;
          }
          return (
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
              e
            ),
            t
          );
        }
        class $M extends fx {
          constructor(t) {
            super(t),
              (this.dracoLoader = null),
              (this.ktx2Loader = null),
              (this.meshoptDecoder = null),
              (this.pluginCallbacks = []),
              this.register(function (t) {
                return new nT(t);
              }),
              this.register(function (t) {
                return new uT(t);
              }),
              this.register(function (t) {
                return new hT(t);
              }),
              this.register(function (t) {
                return new dT(t);
              }),
              this.register(function (t) {
                return new rT(t);
              }),
              this.register(function (t) {
                return new sT(t);
              }),
              this.register(function (t) {
                return new oT(t);
              }),
              this.register(function (t) {
                return new aT(t);
              }),
              this.register(function (t) {
                return new eT(t);
              }),
              this.register(function (t) {
                return new lT(t);
              }),
              this.register(function (t) {
                return new iT(t);
              }),
              this.register(function (t) {
                return new cT(t);
              }),
              this.register(function (t) {
                return new QM(t);
              }),
              this.register(function (t) {
                return new pT(t);
              }),
              this.register(function (t) {
                return new fT(t);
              });
          }
          load(t, e, n, i) {
            const r = this;
            let s;
            (s =
              "" !== this.resourcePath
                ? this.resourcePath
                : "" !== this.path
                ? this.path
                : Dx.extractUrlBase(t)),
              this.manager.itemStart(t);
            const o = function (e) {
                i ? i(e) : console.error(e),
                  r.manager.itemError(t),
                  r.manager.itemEnd(t);
              },
              a = new vx(this.manager);
            a.setPath(this.path),
              a.setResponseType("arraybuffer"),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(this.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    r.parse(
                      n,
                      s,
                      function (n) {
                        e(n), r.manager.itemEnd(t);
                      },
                      o
                    );
                  } catch (t) {
                    o(t);
                  }
                },
                n,
                o
              );
          }
          setDRACOLoader(t) {
            return (this.dracoLoader = t), this;
          }
          setDDSLoader() {
            throw new Error(
              'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
            );
          }
          setKTX2Loader(t) {
            return (this.ktx2Loader = t), this;
          }
          setMeshoptDecoder(t) {
            return (this.meshoptDecoder = t), this;
          }
          register(t) {
            return (
              -1 === this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.push(t),
              this
            );
          }
          unregister(t) {
            return (
              -1 !== this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
              this
            );
          }
          parse(t, e, n, i) {
            let r;
            const s = {},
              o = {},
              a = new TextDecoder();
            if ("string" == typeof t) r = JSON.parse(t);
            else if (t instanceof ArrayBuffer) {
              if (a.decode(new Uint8Array(t, 0, 4)) === mT) {
                try {
                  s[JM.KHR_BINARY_GLTF] = new yT(t);
                } catch (t) {
                  return void (i && i(t));
                }
                r = JSON.parse(s[JM.KHR_BINARY_GLTF].content);
              } else r = JSON.parse(a.decode(t));
            } else r = t;
            if (void 0 === r.asset || r.asset.version[0] < 2)
              return void (
                i &&
                i(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                )
              );
            const l = new WT(r, {
              path: e || this.resourcePath || "",
              crossOrigin: this.crossOrigin,
              requestHeader: this.requestHeader,
              manager: this.manager,
              ktx2Loader: this.ktx2Loader,
              meshoptDecoder: this.meshoptDecoder,
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let t = 0; t < this.pluginCallbacks.length; t++) {
              const e = this.pluginCallbacks[t](l);
              (o[e.name] = e), (s[e.name] = !0);
            }
            if (r.extensionsUsed)
              for (let t = 0; t < r.extensionsUsed.length; ++t) {
                const e = r.extensionsUsed[t],
                  n = r.extensionsRequired || [];
                switch (e) {
                  case JM.KHR_MATERIALS_UNLIT:
                    s[e] = new tT();
                    break;
                  case JM.KHR_DRACO_MESH_COMPRESSION:
                    s[e] = new _T(r, this.dracoLoader);
                    break;
                  case JM.KHR_TEXTURE_TRANSFORM:
                    s[e] = new xT();
                    break;
                  case JM.KHR_MESH_QUANTIZATION:
                    s[e] = new bT();
                    break;
                  default:
                    n.indexOf(e) >= 0 &&
                      void 0 === o[e] &&
                      console.warn(
                        'THREE.GLTFLoader: Unknown extension "' + e + '".'
                      );
                }
              }
            l.setExtensions(s), l.setPlugins(o), l.parse(n, i);
          }
          parseAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.parse(t, e, i, r);
            });
          }
        }
        function ZM() {
          let t = {};
          return {
            get: function (e) {
              return t[e];
            },
            add: function (e, n) {
              t[e] = n;
            },
            remove: function (e) {
              delete t[e];
            },
            removeAll: function () {
              t = {};
            },
          };
        }
        const JM = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_IOR: "KHR_materials_ior",
          KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
          KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
          KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_MATERIALS_VOLUME: "KHR_materials_volume",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_TEXTURE_AVIF: "EXT_texture_avif",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
          EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
        };
        class QM {
          constructor(t) {
            (this.parser = t),
              (this.name = JM.KHR_LIGHTS_PUNCTUAL),
              (this.cache = {
                refs: {},
                uses: {},
              });
          }
          _markDefs() {
            const t = this.parser,
              e = this.parser.json.nodes || [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              i.extensions &&
                i.extensions[this.name] &&
                void 0 !== i.extensions[this.name].light &&
                t._addNodeRef(this.cache, i.extensions[this.name].light);
            }
          }
          _loadLight(t) {
            const e = this.parser,
              n = "light:" + t;
            let i = e.cache.get(n);
            if (i) return i;
            const r = e.json,
              s = (((r.extensions && r.extensions[this.name]) || {}).lights ||
                [])[t];
            let o;
            const a = new lm(16777215);
            void 0 !== s.color &&
              a.setRGB(s.color[0], s.color[1], s.color[2], Ud);
            const l = void 0 !== s.range ? s.range : 0;
            switch (s.type) {
              case "directional":
                (o = new Nx(a)),
                  o.target.position.set(0, 0, -1),
                  o.add(o.target);
                break;
              case "point":
                (o = new Ox(a)), (o.distance = l);
                break;
              case "spot":
                (o = new Ax(a)),
                  (o.distance = l),
                  (s.spot = s.spot || {}),
                  (s.spot.innerConeAngle =
                    void 0 !== s.spot.innerConeAngle
                      ? s.spot.innerConeAngle
                      : 0),
                  (s.spot.outerConeAngle =
                    void 0 !== s.spot.outerConeAngle
                      ? s.spot.outerConeAngle
                      : Math.PI / 4),
                  (o.angle = s.spot.outerConeAngle),
                  (o.penumbra =
                    1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                  o.target.position.set(0, 0, -1),
                  o.add(o.target);
                break;
              default:
                throw new Error(
                  "THREE.GLTFLoader: Unexpected light type: " + s.type
                );
            }
            return (
              o.position.set(0, 0, 0),
              (o.decay = 2),
              kT(o, s),
              void 0 !== s.intensity && (o.intensity = s.intensity),
              (o.name = e.createUniqueName(s.name || "light_" + t)),
              (i = Promise.resolve(o)),
              e.cache.add(n, i),
              i
            );
          }
          getDependency(t, e) {
            if ("light" === t) return this._loadLight(e);
          }
          createNodeAttachment(t) {
            const e = this,
              n = this.parser,
              i = n.json.nodes[t],
              r = ((i.extensions && i.extensions[this.name]) || {}).light;
            return void 0 === r
              ? null
              : this._loadLight(r).then(function (t) {
                  return n._getNodeRef(e.cache, r, t);
                });
          }
        }
        class tT {
          constructor() {
            this.name = JM.KHR_MATERIALS_UNLIT;
          }
          getMaterialType() {
            return um;
          }
          extendParams(t, e, n) {
            const i = [];
            (t.color = new lm(1, 1, 1)), (t.opacity = 1);
            const r = e.pbrMetallicRoughness;
            if (r) {
              if (Array.isArray(r.baseColorFactor)) {
                const e = r.baseColorFactor;
                t.color.setRGB(e[0], e[1], e[2], Ud), (t.opacity = e[3]);
              }
              void 0 !== r.baseColorTexture &&
                i.push(n.assignTexture(t, "map", r.baseColorTexture, Dd));
            }
            return Promise.all(i);
          }
        }
        class eT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_EMISSIVE_STRENGTH);
          }
          extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const i = n.extensions[this.name].emissiveStrength;
            return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve();
          }
        }
        class nT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_CLEARCOAT);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            if (
              (void 0 !== s.clearcoatFactor &&
                (e.clearcoat = s.clearcoatFactor),
              void 0 !== s.clearcoatTexture &&
                r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
              void 0 !== s.clearcoatRoughnessFactor &&
                (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
              void 0 !== s.clearcoatRoughnessTexture &&
                r.push(
                  n.assignTexture(
                    e,
                    "clearcoatRoughnessMap",
                    s.clearcoatRoughnessTexture
                  )
                ),
              void 0 !== s.clearcoatNormalTexture &&
                (r.push(
                  n.assignTexture(
                    e,
                    "clearcoatNormalMap",
                    s.clearcoatNormalTexture
                  )
                ),
                void 0 !== s.clearcoatNormalTexture.scale))
            ) {
              const t = s.clearcoatNormalTexture.scale;
              e.clearcoatNormalScale = new pp(t, t);
            }
            return Promise.all(r);
          }
        }
        class iT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_IRIDESCENCE);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.iridescenceFactor &&
                (e.iridescence = s.iridescenceFactor),
              void 0 !== s.iridescenceTexture &&
                r.push(
                  n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)
                ),
              void 0 !== s.iridescenceIor &&
                (e.iridescenceIOR = s.iridescenceIor),
              void 0 === e.iridescenceThicknessRange &&
                (e.iridescenceThicknessRange = [100, 400]),
              void 0 !== s.iridescenceThicknessMinimum &&
                (e.iridescenceThicknessRange[0] =
                  s.iridescenceThicknessMinimum),
              void 0 !== s.iridescenceThicknessMaximum &&
                (e.iridescenceThicknessRange[1] =
                  s.iridescenceThicknessMaximum),
              void 0 !== s.iridescenceThicknessTexture &&
                r.push(
                  n.assignTexture(
                    e,
                    "iridescenceThicknessMap",
                    s.iridescenceThicknessTexture
                  )
                ),
              Promise.all(r)
            );
          }
        }
        class rT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_SHEEN);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [];
            (e.sheenColor = new lm(0, 0, 0)),
              (e.sheenRoughness = 0),
              (e.sheen = 1);
            const s = i.extensions[this.name];
            if (void 0 !== s.sheenColorFactor) {
              const t = s.sheenColorFactor;
              e.sheenColor.setRGB(t[0], t[1], t[2], Ud);
            }
            return (
              void 0 !== s.sheenRoughnessFactor &&
                (e.sheenRoughness = s.sheenRoughnessFactor),
              void 0 !== s.sheenColorTexture &&
                r.push(
                  n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, Dd)
                ),
              void 0 !== s.sheenRoughnessTexture &&
                r.push(
                  n.assignTexture(
                    e,
                    "sheenRoughnessMap",
                    s.sheenRoughnessTexture
                  )
                ),
              Promise.all(r)
            );
          }
        }
        class sT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_TRANSMISSION);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.transmissionFactor &&
                (e.transmission = s.transmissionFactor),
              void 0 !== s.transmissionTexture &&
                r.push(
                  n.assignTexture(e, "transmissionMap", s.transmissionTexture)
                ),
              Promise.all(r)
            );
          }
        }
        class oT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_VOLUME);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            (e.thickness =
              void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
              void 0 !== s.thicknessTexture &&
                r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
              (e.attenuationDistance = s.attenuationDistance || 1 / 0);
            const o = s.attenuationColor || [1, 1, 1];
            return (
              (e.attenuationColor = new lm().setRGB(o[0], o[1], o[2], Ud)),
              Promise.all(r)
            );
          }
        }
        class aT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_IOR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const i = n.extensions[this.name];
            return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
          }
        }
        class lT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_SPECULAR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            (e.specularIntensity =
              void 0 !== s.specularFactor ? s.specularFactor : 1),
              void 0 !== s.specularTexture &&
                r.push(
                  n.assignTexture(e, "specularIntensityMap", s.specularTexture)
                );
            const o = s.specularColorFactor || [1, 1, 1];
            return (
              (e.specularColor = new lm().setRGB(o[0], o[1], o[2], Ud)),
              void 0 !== s.specularColorTexture &&
                r.push(
                  n.assignTexture(
                    e,
                    "specularColorMap",
                    s.specularColorTexture,
                    Dd
                  )
                ),
              Promise.all(r)
            );
          }
        }
        class cT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_MATERIALS_ANISOTROPY);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? W_ : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const r = [],
              s = i.extensions[this.name];
            return (
              void 0 !== s.anisotropyStrength &&
                (e.anisotropy = s.anisotropyStrength),
              void 0 !== s.anisotropyRotation &&
                (e.anisotropyRotation = s.anisotropyRotation),
              void 0 !== s.anisotropyTexture &&
                r.push(
                  n.assignTexture(e, "anisotropyMap", s.anisotropyTexture)
                ),
              Promise.all(r)
            );
          }
        }
        class uT {
          constructor(t) {
            (this.parser = t), (this.name = JM.KHR_TEXTURE_BASISU);
          }
          loadTexture(t) {
            const e = this.parser,
              n = e.json,
              i = n.textures[t];
            if (!i.extensions || !i.extensions[this.name]) return null;
            const r = i.extensions[this.name],
              s = e.options.ktx2Loader;
            if (!s) {
              if (
                n.extensionsRequired &&
                n.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                );
              return null;
            }
            return e.loadTextureImage(t, r.source, s);
          }
        }
        class hT {
          constructor(t) {
            (this.parser = t),
              (this.name = JM.EXT_TEXTURE_WEBP),
              (this.isSupported = null);
          }
          loadTexture(t) {
            const e = this.name,
              n = this.parser,
              i = n.json,
              r = i.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const s = r.extensions[e],
              o = i.images[s.source];
            let a = n.textureLoader;
            if (o.uri) {
              const t = n.options.manager.getHandler(o.uri);
              null !== t && (a = t);
            }
            return this.detectSupport().then(function (r) {
              if (r) return n.loadTextureImage(t, s.source, a);
              if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: WebP required by asset but unsupported."
                );
              return n.loadTexture(t);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (t) {
                  const e = new Image();
                  (e.src =
                    "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                    (e.onload = e.onerror =
                      function () {
                        t(1 === e.height);
                      });
                })),
              this.isSupported
            );
          }
        }
        class dT {
          constructor(t) {
            (this.parser = t),
              (this.name = JM.EXT_TEXTURE_AVIF),
              (this.isSupported = null);
          }
          loadTexture(t) {
            const e = this.name,
              n = this.parser,
              i = n.json,
              r = i.textures[t];
            if (!r.extensions || !r.extensions[e]) return null;
            const s = r.extensions[e],
              o = i.images[s.source];
            let a = n.textureLoader;
            if (o.uri) {
              const t = n.options.manager.getHandler(o.uri);
              null !== t && (a = t);
            }
            return this.detectSupport().then(function (r) {
              if (r) return n.loadTextureImage(t, s.source, a);
              if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: AVIF required by asset but unsupported."
                );
              return n.loadTexture(t);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (t) {
                  const e = new Image();
                  (e.src =
                    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
                    (e.onload = e.onerror =
                      function () {
                        t(1 === e.height);
                      });
                })),
              this.isSupported
            );
          }
        }
        class pT {
          constructor(t) {
            (this.name = JM.EXT_MESHOPT_COMPRESSION), (this.parser = t);
          }
          loadBufferView(t) {
            const e = this.parser.json,
              n = e.bufferViews[t];
            if (n.extensions && n.extensions[this.name]) {
              const t = n.extensions[this.name],
                i = this.parser.getDependency("buffer", t.buffer),
                r = this.parser.options.meshoptDecoder;
              if (!r || !r.supported) {
                if (
                  e.extensionsRequired &&
                  e.extensionsRequired.indexOf(this.name) >= 0
                )
                  throw new Error(
                    "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                  );
                return null;
              }
              return i.then(function (e) {
                const n = t.byteOffset || 0,
                  i = t.byteLength || 0,
                  s = t.count,
                  o = t.byteStride,
                  a = new Uint8Array(e, n, i);
                return r.decodeGltfBufferAsync
                  ? r
                      .decodeGltfBufferAsync(s, o, a, t.mode, t.filter)
                      .then(function (t) {
                        return t.buffer;
                      })
                  : r.ready.then(function () {
                      const e = new ArrayBuffer(s * o);
                      return (
                        r.decodeGltfBuffer(
                          new Uint8Array(e),
                          s,
                          o,
                          a,
                          t.mode,
                          t.filter
                        ),
                        e
                      );
                    });
              });
            }
            return null;
          }
        }
        class fT {
          constructor(t) {
            (this.name = JM.EXT_MESH_GPU_INSTANCING), (this.parser = t);
          }
          createNodeMesh(t) {
            const e = this.parser.json,
              n = e.nodes[t];
            if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
              return null;
            const i = e.meshes[n.mesh];
            for (const t of i.primitives)
              if (
                t.mode !== MT.TRIANGLES &&
                t.mode !== MT.TRIANGLE_STRIP &&
                t.mode !== MT.TRIANGLE_FAN &&
                void 0 !== t.mode
              )
                return null;
            const r = n.extensions[this.name].attributes,
              s = [],
              o = {};
            for (const t in r)
              s.push(
                this.parser
                  .getDependency("accessor", r[t])
                  .then((e) => ((o[t] = e), o[t]))
              );
            return s.length < 1
              ? null
              : (s.push(this.parser.createNodeMesh(t)),
                Promise.all(s).then((t) => {
                  const e = t.pop(),
                    n = e.isGroup ? e.children : [e],
                    i = t[0].count,
                    r = [];
                  for (const t of n) {
                    const e = new yf(),
                      n = new Hp(),
                      s = new zp(),
                      a = new Hp(1, 1, 1),
                      l = new b_(t.geometry, t.material, i);
                    for (let t = 0; t < i; t++)
                      o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t),
                        o.ROTATION && s.fromBufferAttribute(o.ROTATION, t),
                        o.SCALE && a.fromBufferAttribute(o.SCALE, t),
                        l.setMatrixAt(t, e.compose(n, s, a));
                    for (const e in o)
                      "TRANSLATION" !== e &&
                        "ROTATION" !== e &&
                        "SCALE" !== e &&
                        t.geometry.setAttribute(e, o[e]);
                    Gf.prototype.copy.call(l, t),
                      this.parser.assignFinalMaterial(l),
                      r.push(l);
                  }
                  return e.isGroup ? (e.clear(), e.add(...r), e) : r[0];
                }));
          }
        }
        const mT = "glTF",
          gT = 1313821514,
          vT = 5130562;
        class yT {
          constructor(t) {
            (this.name = JM.KHR_BINARY_GLTF),
              (this.content = null),
              (this.body = null);
            const e = new DataView(t, 0, 12),
              n = new TextDecoder();
            if (
              ((this.header = {
                magic: n.decode(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0),
              }),
              this.header.magic !== mT)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported glTF-Binary header."
              );
            if (this.header.version < 2)
              throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - 12,
              r = new DataView(t, 12);
            let s = 0;
            for (; s < i; ) {
              const e = r.getUint32(s, !0);
              s += 4;
              const i = r.getUint32(s, !0);
              if (((s += 4), i === gT)) {
                const i = new Uint8Array(t, 12 + s, e);
                this.content = n.decode(i);
              } else if (i === vT) {
                const n = 12 + s;
                this.body = t.slice(n, n + e);
              }
              s += e;
            }
            if (null === this.content)
              throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
        class _T {
          constructor(t, e) {
            if (!e)
              throw new Error(
                "THREE.GLTFLoader: No DRACOLoader instance provided."
              );
            (this.name = JM.KHR_DRACO_MESH_COMPRESSION),
              (this.json = t),
              (this.dracoLoader = e),
              this.dracoLoader.preload();
          }
          decodePrimitive(t, e) {
            const n = this.json,
              i = this.dracoLoader,
              r = t.extensions[this.name].bufferView,
              s = t.extensions[this.name].attributes,
              o = {},
              a = {},
              l = {};
            for (const t in s) {
              const e = LT[t] || t.toLowerCase();
              o[e] = s[t];
            }
            for (const e in t.attributes) {
              const i = LT[e] || e.toLowerCase();
              if (void 0 !== s[e]) {
                const r = n.accessors[t.attributes[e]],
                  s = TT[r.componentType];
                (l[i] = s.name), (a[i] = !0 === r.normalized);
              }
            }
            return e.getDependency("bufferView", r).then(function (t) {
              return new Promise(function (e) {
                i.decodeDracoFile(
                  t,
                  function (t) {
                    for (const e in t.attributes) {
                      const n = t.attributes[e],
                        i = a[e];
                      void 0 !== i && (n.normalized = i);
                    }
                    e(t);
                  },
                  o,
                  l
                );
              });
            });
          }
        }
        class xT {
          constructor() {
            this.name = JM.KHR_TEXTURE_TRANSFORM;
          }
          extendTexture(t, e) {
            return (void 0 !== e.texCoord && e.texCoord !== t.channel) ||
              void 0 !== e.offset ||
              void 0 !== e.rotation ||
              void 0 !== e.scale
              ? ((t = t.clone()),
                void 0 !== e.texCoord && (t.channel = e.texCoord),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                (t.needsUpdate = !0),
                t)
              : t;
          }
        }
        class bT {
          constructor() {
            this.name = JM.KHR_MESH_QUANTIZATION;
          }
        }
        class wT extends Z_ {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i * 3 + i;
            for (let t = 0; t !== i; t++) e[t] = n[r + t];
            return e;
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = 2 * o,
              l = 3 * o,
              c = i - e,
              u = (n - e) / c,
              h = u * u,
              d = h * u,
              p = t * l,
              f = p - l,
              m = -2 * d + 3 * h,
              g = d - h,
              v = 1 - m,
              y = g - h + u;
            for (let t = 0; t !== o; t++) {
              const e = s[f + t + o],
                n = s[f + t + a] * c,
                i = s[p + t + o],
                l = s[p + t] * c;
              r[t] = v * e + y * n + m * i + g * l;
            }
            return r;
          }
        }
        const ET = new zp();
        class ST extends wT {
          interpolate_(t, e, n, i) {
            const r = super.interpolate_(t, e, n, i);
            return ET.fromArray(r).normalize().toArray(r), r;
          }
        }
        const MT = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123,
          },
          TT = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          AT = {
            9728: od,
            9729: cd,
            9984: ad,
            9985: ud,
            9986: ld,
            9987: hd,
          },
          RT = {
            33071: rd,
            33648: sd,
            10497: id,
          },
          CT = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
          },
          LT = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          PT = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          OT = {
            CUBICSPLINE: void 0,
            LINEAR: Rd,
            STEP: Ad,
          },
          IT = "OPAQUE",
          NT = "MASK",
          DT = "BLEND";
        function UT(t) {
          return (
            void 0 === t.DefaultMaterial &&
              (t.DefaultMaterial = new G_({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: Th,
              })),
            t.DefaultMaterial
          );
        }
        function FT(t, e, n) {
          for (const i in n.extensions)
            void 0 === t[i] &&
              ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
              (e.userData.gltfExtensions[i] = n.extensions[i]));
        }
        function kT(t, e) {
          void 0 !== e.extras &&
            ("object" == typeof e.extras
              ? Object.assign(t.userData, e.extras)
              : console.warn(
                  "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                    e.extras
                ));
        }
        function BT(t, e) {
          if ((t.updateMorphTargets(), void 0 !== e.weights))
            for (let n = 0, i = e.weights.length; n < i; n++)
              t.morphTargetInfluences[n] = e.weights[n];
          if (e.extras && Array.isArray(e.extras.targetNames)) {
            const n = e.extras.targetNames;
            if (t.morphTargetInfluences.length === n.length) {
              t.morphTargetDictionary = {};
              for (let e = 0, i = n.length; e < i; e++)
                t.morphTargetDictionary[n[e]] = e;
            } else
              console.warn(
                "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
              );
          }
        }
        function zT(t) {
          let e;
          const n = t.extensions && t.extensions[JM.KHR_DRACO_MESH_COMPRESSION];
          if (
            ((e = n
              ? "draco:" +
                n.bufferView +
                ":" +
                n.indices +
                ":" +
                HT(n.attributes)
              : t.indices + ":" + HT(t.attributes) + ":" + t.mode),
            void 0 !== t.targets)
          )
            for (let n = 0, i = t.targets.length; n < i; n++)
              e += ":" + HT(t.targets[n]);
          return e;
        }
        function HT(t) {
          let e = "";
          const n = Object.keys(t).sort();
          for (let i = 0, r = n.length; i < r; i++)
            e += n[i] + ":" + t[n[i]] + ";";
          return e;
        }
        function VT(t) {
          switch (t) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unsupported normalized accessor component type."
              );
          }
        }
        const GT = new yf();
        class WT {
          constructor(t = {}, e = {}) {
            (this.json = t),
              (this.extensions = {}),
              (this.plugins = {}),
              (this.options = e),
              (this.cache = new ZM()),
              (this.associations = new Map()),
              (this.primitiveCache = {}),
              (this.nodeCache = {}),
              (this.meshCache = {
                refs: {},
                uses: {},
              }),
              (this.cameraCache = {
                refs: {},
                uses: {},
              }),
              (this.lightCache = {
                refs: {},
                uses: {},
              }),
              (this.sourceCache = {}),
              (this.textureCache = {}),
              (this.nodeNamesUsed = {});
            let n = !1,
              i = !1,
              r = -1;
            "undefined" != typeof navigator &&
              ((n =
                !0 ===
                /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
              (i = navigator.userAgent.indexOf("Firefox") > -1),
              (r = i
                ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]
                : -1)),
              "undefined" == typeof createImageBitmap || n || (i && r < 98)
                ? (this.textureLoader = new xx(this.options.manager))
                : (this.textureLoader = new Ux(this.options.manager)),
              this.textureLoader.setCrossOrigin(this.options.crossOrigin),
              this.textureLoader.setRequestHeader(this.options.requestHeader),
              (this.fileLoader = new vx(this.options.manager)),
              this.fileLoader.setResponseType("arraybuffer"),
              "use-credentials" === this.options.crossOrigin &&
                this.fileLoader.setWithCredentials(!0);
          }
          setExtensions(t) {
            this.extensions = t;
          }
          setPlugins(t) {
            this.plugins = t;
          }
          parse(t, e) {
            const n = this,
              i = this.json,
              r = this.extensions;
            this.cache.removeAll(),
              (this.nodeCache = {}),
              this._invokeAll(function (t) {
                return t._markDefs && t._markDefs();
              }),
              Promise.all(
                this._invokeAll(function (t) {
                  return t.beforeRoot && t.beforeRoot();
                })
              )
                .then(function () {
                  return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera"),
                  ]);
                })
                .then(function (e) {
                  const s = {
                    scene: e[0][i.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: i.asset,
                    parser: n,
                    userData: {},
                  };
                  FT(r, s, i),
                    kT(s, i),
                    Promise.all(
                      n._invokeAll(function (t) {
                        return t.afterRoot && t.afterRoot(s);
                      })
                    ).then(function () {
                      t(s);
                    });
                })
                .catch(e);
          }
          _markDefs() {
            const t = this.json.nodes || [],
              e = this.json.skins || [],
              n = this.json.meshes || [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n].joints;
              for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0;
            }
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e];
              void 0 !== i.mesh &&
                (this._addNodeRef(this.meshCache, i.mesh),
                void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                void 0 !== i.camera &&
                  this._addNodeRef(this.cameraCache, i.camera);
            }
          }
          _addNodeRef(t, e) {
            void 0 !== e &&
              (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
              t.refs[e]++);
          }
          _getNodeRef(t, e, n) {
            if (t.refs[e] <= 1) return n;
            const i = n.clone(),
              r = (t, e) => {
                const n = this.associations.get(t);
                null != n && this.associations.set(e, n);
                for (const [n, i] of t.children.entries()) r(i, e.children[n]);
              };
            return r(n, i), (i.name += "_instance_" + t.uses[e]++), i;
          }
          _invokeOne(t) {
            const e = Object.values(this.plugins);
            e.push(this);
            for (let n = 0; n < e.length; n++) {
              const i = t(e[n]);
              if (i) return i;
            }
            return null;
          }
          _invokeAll(t) {
            const e = Object.values(this.plugins);
            e.unshift(this);
            const n = [];
            for (let i = 0; i < e.length; i++) {
              const r = t(e[i]);
              r && n.push(r);
            }
            return n;
          }
          getDependency(t, e) {
            const n = t + ":" + e;
            let i = this.cache.get(n);
            if (!i) {
              switch (t) {
                case "scene":
                  i = this.loadScene(e);
                  break;
                case "node":
                  i = this._invokeOne(function (t) {
                    return t.loadNode && t.loadNode(e);
                  });
                  break;
                case "mesh":
                  i = this._invokeOne(function (t) {
                    return t.loadMesh && t.loadMesh(e);
                  });
                  break;
                case "accessor":
                  i = this.loadAccessor(e);
                  break;
                case "bufferView":
                  i = this._invokeOne(function (t) {
                    return t.loadBufferView && t.loadBufferView(e);
                  });
                  break;
                case "buffer":
                  i = this.loadBuffer(e);
                  break;
                case "material":
                  i = this._invokeOne(function (t) {
                    return t.loadMaterial && t.loadMaterial(e);
                  });
                  break;
                case "texture":
                  i = this._invokeOne(function (t) {
                    return t.loadTexture && t.loadTexture(e);
                  });
                  break;
                case "skin":
                  i = this.loadSkin(e);
                  break;
                case "animation":
                  i = this._invokeOne(function (t) {
                    return t.loadAnimation && t.loadAnimation(e);
                  });
                  break;
                case "camera":
                  i = this.loadCamera(e);
                  break;
                default:
                  if (
                    ((i = this._invokeOne(function (n) {
                      return (
                        n != this && n.getDependency && n.getDependency(t, e)
                      );
                    })),
                    !i)
                  )
                    throw new Error("Unknown type: " + t);
              }
              this.cache.add(n, i);
            }
            return i;
          }
          getDependencies(t) {
            let e = this.cache.get(t);
            if (!e) {
              const n = this,
                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
              (e = Promise.all(
                i.map(function (e, i) {
                  return n.getDependency(t, i);
                })
              )),
                this.cache.add(t, e);
            }
            return e;
          }
          loadBuffer(t) {
            const e = this.json.buffers[t],
              n = this.fileLoader;
            if (e.type && "arraybuffer" !== e.type)
              throw new Error(
                "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
              );
            if (void 0 === e.uri && 0 === t)
              return Promise.resolve(this.extensions[JM.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise(function (t, r) {
              n.load(Dx.resolveURL(e.uri, i.path), t, void 0, function () {
                r(
                  new Error(
                    'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
                  )
                );
              });
            });
          }
          loadBufferView(t) {
            const e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then(function (t) {
              const n = e.byteLength || 0,
                i = e.byteOffset || 0;
              return t.slice(i, i + n);
            });
          }
          loadAccessor(t) {
            const e = this,
              n = this.json,
              i = this.json.accessors[t];
            if (void 0 === i.bufferView && void 0 === i.sparse) {
              const t = CT[i.type],
                e = TT[i.componentType],
                n = !0 === i.normalized,
                r = new e(i.count * t);
              return Promise.resolve(new ym(r, t, n));
            }
            const r = [];
            return (
              void 0 !== i.bufferView
                ? r.push(this.getDependency("bufferView", i.bufferView))
                : r.push(null),
              void 0 !== i.sparse &&
                (r.push(
                  this.getDependency("bufferView", i.sparse.indices.bufferView)
                ),
                r.push(
                  this.getDependency("bufferView", i.sparse.values.bufferView)
                )),
              Promise.all(r).then(function (t) {
                const r = t[0],
                  s = CT[i.type],
                  o = TT[i.componentType],
                  a = o.BYTES_PER_ELEMENT,
                  l = a * s,
                  c = i.byteOffset || 0,
                  u =
                    void 0 !== i.bufferView
                      ? n.bufferViews[i.bufferView].byteStride
                      : void 0,
                  h = !0 === i.normalized;
                let d, p;
                if (u && u !== l) {
                  const t = Math.floor(c / u),
                    n =
                      "InterleavedBuffer:" +
                      i.bufferView +
                      ":" +
                      i.componentType +
                      ":" +
                      t +
                      ":" +
                      i.count;
                  let l = e.cache.get(n);
                  l ||
                    ((d = new o(r, t * u, (i.count * u) / a)),
                    (l = new Ky(d, u / a)),
                    e.cache.add(n, l)),
                    (p = new Zy(l, s, (c % u) / a, h));
                } else (d = null === r ? new o(i.count * s) : new o(r, c, i.count * s)), (p = new ym(d, s, h));
                if (void 0 !== i.sparse) {
                  const e = CT.SCALAR,
                    n = TT[i.sparse.indices.componentType],
                    a = i.sparse.indices.byteOffset || 0,
                    l = i.sparse.values.byteOffset || 0,
                    c = new n(t[1], a, i.sparse.count * e),
                    u = new o(t[2], l, i.sparse.count * s);
                  null !== r &&
                    (p = new ym(p.array.slice(), p.itemSize, p.normalized));
                  for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    if (
                      (p.setX(e, u[t * s]),
                      s >= 2 && p.setY(e, u[t * s + 1]),
                      s >= 3 && p.setZ(e, u[t * s + 2]),
                      s >= 4 && p.setW(e, u[t * s + 3]),
                      s >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return p;
              })
            );
          }
          loadTexture(t) {
            const e = this.json,
              n = this.options,
              i = e.textures[t].source,
              r = e.images[i];
            let s = this.textureLoader;
            if (r.uri) {
              const t = n.manager.getHandler(r.uri);
              null !== t && (s = t);
            }
            return this.loadTextureImage(t, i, s);
          }
          loadTextureImage(t, e, n) {
            const i = this,
              r = this.json,
              s = r.textures[t],
              o = r.images[e],
              a = (o.uri || o.bufferView) + ":" + s.sampler;
            if (this.textureCache[a]) return this.textureCache[a];
            const l = this.loadImageSource(e, n)
              .then(function (e) {
                (e.flipY = !1),
                  (e.name = s.name || o.name || ""),
                  "" === e.name &&
                    "string" == typeof o.uri &&
                    !1 === o.uri.startsWith("data:image/") &&
                    (e.name = o.uri);
                const n = (r.samplers || {})[s.sampler] || {};
                return (
                  (e.magFilter = AT[n.magFilter] || cd),
                  (e.minFilter = AT[n.minFilter] || hd),
                  (e.wrapS = RT[n.wrapS] || id),
                  (e.wrapT = RT[n.wrapT] || id),
                  i.associations.set(e, {
                    textures: t,
                  }),
                  e
                );
              })
              .catch(function () {
                return null;
              });
            return (this.textureCache[a] = l), l;
          }
          loadImageSource(t, e) {
            const n = this,
              i = this.json,
              r = this.options;
            if (void 0 !== this.sourceCache[t])
              return this.sourceCache[t].then((t) => t.clone());
            const s = i.images[t],
              o = self.URL || self.webkitURL;
            let a = s.uri || "",
              l = !1;
            if (void 0 !== s.bufferView)
              a = n
                .getDependency("bufferView", s.bufferView)
                .then(function (t) {
                  l = !0;
                  const e = new Blob([t], {
                    type: s.mimeType,
                  });
                  return (a = o.createObjectURL(e)), a;
                });
            else if (void 0 === s.uri)
              throw new Error(
                "THREE.GLTFLoader: Image " +
                  t +
                  " is missing URI and bufferView"
              );
            const c = Promise.resolve(a)
              .then(function (t) {
                return new Promise(function (n, i) {
                  let s = n;
                  !0 === e.isImageBitmapLoader &&
                    (s = function (t) {
                      const e = new Np(t);
                      (e.needsUpdate = !0), n(e);
                    }),
                    e.load(Dx.resolveURL(t, r.path), s, void 0, i);
                });
              })
              .then(function (t) {
                var e;
                return (
                  !0 === l && o.revokeObjectURL(a),
                  (t.userData.mimeType =
                    s.mimeType ||
                    ((e = s.uri).search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === e.search(/^data\:image\/jpeg/)
                      ? "image/jpeg"
                      : e.search(/\.webp($|\?)/i) > 0 ||
                        0 === e.search(/^data\:image\/webp/)
                      ? "image/webp"
                      : "image/png")),
                  t
                );
              })
              .catch(function (t) {
                throw (
                  (console.error("THREE.GLTFLoader: Couldn't load texture", a),
                  t)
                );
              });
            return (this.sourceCache[t] = c), c;
          }
          assignTexture(t, e, n, i) {
            const r = this;
            return this.getDependency("texture", n.index).then(function (s) {
              if (!s) return null;
              if (
                (void 0 !== n.texCoord &&
                  n.texCoord > 0 &&
                  ((s = s.clone()).channel = n.texCoord),
                r.extensions[JM.KHR_TEXTURE_TRANSFORM])
              ) {
                const t =
                  void 0 !== n.extensions
                    ? n.extensions[JM.KHR_TEXTURE_TRANSFORM]
                    : void 0;
                if (t) {
                  const e = r.associations.get(s);
                  (s = r.extensions[JM.KHR_TEXTURE_TRANSFORM].extendTexture(
                    s,
                    t
                  )),
                    r.associations.set(s, e);
                }
              }
              return void 0 !== i && (s.colorSpace = i), (t[e] = s), s;
            });
          }
          assignFinalMaterial(t) {
            const e = t.geometry;
            let n = t.material;
            const i = void 0 === e.attributes.tangent,
              r = void 0 !== e.attributes.color,
              s = void 0 === e.attributes.normal;
            if (t.isPoints) {
              const t = "PointsMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new I_()),
                im.prototype.copy.call(e, n),
                e.color.copy(n.color),
                (e.map = n.map),
                (e.sizeAttenuation = !1),
                this.cache.add(t, e)),
                (n = e);
            } else if (t.isLine) {
              const t = "LineBasicMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new w_()),
                im.prototype.copy.call(e, n),
                e.color.copy(n.color),
                (e.map = n.map),
                this.cache.add(t, e)),
                (n = e);
            }
            if (i || r || s) {
              let t = "ClonedMaterial:" + n.uuid + ":";
              i && (t += "derivative-tangents:"),
                r && (t += "vertex-colors:"),
                s && (t += "flat-shading:");
              let e = this.cache.get(t);
              e ||
                ((e = n.clone()),
                r && (e.vertexColors = !0),
                s && (e.flatShading = !0),
                i &&
                  (e.normalScale && (e.normalScale.y *= -1),
                  e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                this.cache.add(t, e),
                this.associations.set(e, this.associations.get(n))),
                (n = e);
            }
            t.material = n;
          }
          getMaterialType() {
            return G_;
          }
          loadMaterial(t) {
            const e = this,
              n = this.json,
              i = this.extensions,
              r = n.materials[t];
            let s;
            const o = {},
              a = [];
            if ((r.extensions || {})[JM.KHR_MATERIALS_UNLIT]) {
              const t = i[JM.KHR_MATERIALS_UNLIT];
              (s = t.getMaterialType()), a.push(t.extendParams(o, r, e));
            } else {
              const n = r.pbrMetallicRoughness || {};
              if (
                ((o.color = new lm(1, 1, 1)),
                (o.opacity = 1),
                Array.isArray(n.baseColorFactor))
              ) {
                const t = n.baseColorFactor;
                o.color.setRGB(t[0], t[1], t[2], Ud), (o.opacity = t[3]);
              }
              void 0 !== n.baseColorTexture &&
                a.push(e.assignTexture(o, "map", n.baseColorTexture, Dd)),
                (o.metalness =
                  void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                (o.roughness =
                  void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                void 0 !== n.metallicRoughnessTexture &&
                  (a.push(
                    e.assignTexture(
                      o,
                      "metalnessMap",
                      n.metallicRoughnessTexture
                    )
                  ),
                  a.push(
                    e.assignTexture(
                      o,
                      "roughnessMap",
                      n.metallicRoughnessTexture
                    )
                  )),
                (s = this._invokeOne(function (e) {
                  return e.getMaterialType && e.getMaterialType(t);
                })),
                a.push(
                  Promise.all(
                    this._invokeAll(function (e) {
                      return (
                        e.extendMaterialParams && e.extendMaterialParams(t, o)
                      );
                    })
                  )
                );
            }
            !0 === r.doubleSided && (o.side = 2);
            const l = r.alphaMode || IT;
            if (
              (l === DT
                ? ((o.transparent = !0), (o.depthWrite = !1))
                : ((o.transparent = !1),
                  l === NT &&
                    (o.alphaTest =
                      void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
              void 0 !== r.normalTexture &&
                s !== um &&
                (a.push(e.assignTexture(o, "normalMap", r.normalTexture)),
                (o.normalScale = new pp(1, 1)),
                void 0 !== r.normalTexture.scale))
            ) {
              const t = r.normalTexture.scale;
              o.normalScale.set(t, t);
            }
            if (
              (void 0 !== r.occlusionTexture &&
                s !== um &&
                (a.push(e.assignTexture(o, "aoMap", r.occlusionTexture)),
                void 0 !== r.occlusionTexture.strength &&
                  (o.aoMapIntensity = r.occlusionTexture.strength)),
              void 0 !== r.emissiveFactor && s !== um)
            ) {
              const t = r.emissiveFactor;
              o.emissive = new lm().setRGB(t[0], t[1], t[2], Ud);
            }
            return (
              void 0 !== r.emissiveTexture &&
                s !== um &&
                a.push(
                  e.assignTexture(o, "emissiveMap", r.emissiveTexture, Dd)
                ),
              Promise.all(a).then(function () {
                const n = new s(o);
                return (
                  r.name && (n.name = r.name),
                  kT(n, r),
                  e.associations.set(n, {
                    materials: t,
                  }),
                  r.extensions && FT(i, n, r),
                  n
                );
              })
            );
          }
          createUniqueName(t) {
            const e = jx.sanitizeNodeName(t || "");
            return e in this.nodeNamesUsed
              ? e + "_" + ++this.nodeNamesUsed[e]
              : ((this.nodeNamesUsed[e] = 0), e);
          }
          loadGeometries(t) {
            const e = this,
              n = this.extensions,
              i = this.primitiveCache;
            function r(t) {
              return n[JM.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(t, e)
                .then(function (n) {
                  return jT(n, t, e);
                });
            }
            const s = [];
            for (let n = 0, o = t.length; n < o; n++) {
              const o = t[n],
                a = zT(o),
                l = i[a];
              if (l) s.push(l.promise);
              else {
                let t;
                (t =
                  o.extensions && o.extensions[JM.KHR_DRACO_MESH_COMPRESSION]
                    ? r(o)
                    : jT(new Cm(), o, e)),
                  (i[a] = {
                    primitive: o,
                    promise: t,
                  }),
                  s.push(t);
              }
            }
            return Promise.all(s);
          }
          loadMesh(t) {
            const e = this,
              n = this.json,
              i = this.extensions,
              r = n.meshes[t],
              s = r.primitives,
              o = [];
            for (let t = 0, e = s.length; t < e; t++) {
              const e =
                void 0 === s[t].material
                  ? UT(this.cache)
                  : this.getDependency("material", s[t].material);
              o.push(e);
            }
            return (
              o.push(e.loadGeometries(s)),
              Promise.all(o).then(function (n) {
                const o = n.slice(0, n.length - 1),
                  a = n[n.length - 1],
                  l = [];
                for (let n = 0, c = a.length; n < c; n++) {
                  const c = a[n],
                    u = s[n];
                  let h;
                  const d = o[n];
                  if (
                    u.mode === MT.TRIANGLES ||
                    u.mode === MT.TRIANGLE_STRIP ||
                    u.mode === MT.TRIANGLE_FAN ||
                    void 0 === u.mode
                  )
                    (h = !0 === r.isSkinnedMesh ? new a_(c, d) : new Xm(c, d)),
                      !0 === h.isSkinnedMesh && h.normalizeSkinWeights(),
                      u.mode === MT.TRIANGLE_STRIP
                        ? (h.geometry = KM(h.geometry, 1))
                        : u.mode === MT.TRIANGLE_FAN &&
                          (h.geometry = KM(h.geometry, 2));
                  else if (u.mode === MT.LINES) h = new P_(c, d);
                  else if (u.mode === MT.LINE_STRIP) h = new R_(c, d);
                  else if (u.mode === MT.LINE_LOOP) h = new O_(c, d);
                  else {
                    if (u.mode !== MT.POINTS)
                      throw new Error(
                        "THREE.GLTFLoader: Primitive mode unsupported: " +
                          u.mode
                      );
                    h = new k_(c, d);
                  }
                  Object.keys(h.geometry.morphAttributes).length > 0 &&
                    BT(h, r),
                    (h.name = e.createUniqueName(r.name || "mesh_" + t)),
                    kT(h, r),
                    u.extensions && FT(i, h, u),
                    e.assignFinalMaterial(h),
                    l.push(h);
                }
                for (let n = 0, i = l.length; n < i; n++)
                  e.associations.set(l[n], {
                    meshes: t,
                    primitives: n,
                  });
                if (1 === l.length) return r.extensions && FT(i, l[0], r), l[0];
                const c = new zy();
                r.extensions && FT(i, c, r),
                  e.associations.set(c, {
                    meshes: t,
                  });
                for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                return c;
              })
            );
          }
          loadCamera(t) {
            let e;
            const n = this.json.cameras[t],
              i = n[n.type];
            if (i)
              return (
                "perspective" === n.type
                  ? (e = new ng(
                      dp.radToDeg(i.yfov),
                      i.aspectRatio || 1,
                      i.znear || 1,
                      i.zfar || 2e6
                    ))
                  : "orthographic" === n.type &&
                    (e = new Ag(
                      -i.xmag,
                      i.xmag,
                      i.ymag,
                      -i.ymag,
                      i.znear,
                      i.zfar
                    )),
                n.name && (e.name = this.createUniqueName(n.name)),
                kT(e, n),
                Promise.resolve(e)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }
          loadSkin(t) {
            const e = this.json.skins[t],
              n = [];
            for (let t = 0, i = e.joints.length; t < i; t++)
              n.push(this._loadNodeShallow(e.joints[t]));
            return (
              void 0 !== e.inverseBindMatrices
                ? n.push(this.getDependency("accessor", e.inverseBindMatrices))
                : n.push(null),
              Promise.all(n).then(function (t) {
                const n = t.pop(),
                  i = t,
                  r = [],
                  s = [];
                for (let t = 0, o = i.length; t < o; t++) {
                  const o = i[t];
                  if (o) {
                    r.push(o);
                    const e = new yf();
                    null !== n && e.fromArray(n.array, 16 * t), s.push(e);
                  } else
                    console.warn(
                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                      e.joints[t]
                    );
                }
                return new d_(r, s);
              })
            );
          }
          loadAnimation(t) {
            const e = this.json,
              n = this,
              i = e.animations[t],
              r = i.name ? i.name : "animation_" + t,
              s = [],
              o = [],
              a = [],
              l = [],
              c = [];
            for (let t = 0, e = i.channels.length; t < e; t++) {
              const e = i.channels[t],
                n = i.samplers[e.sampler],
                r = e.target,
                u = r.node,
                h = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
              void 0 !== r.node &&
                (s.push(this.getDependency("node", u)),
                o.push(this.getDependency("accessor", h)),
                a.push(this.getDependency("accessor", d)),
                l.push(n),
                c.push(r));
            }
            return Promise.all([
              Promise.all(s),
              Promise.all(o),
              Promise.all(a),
              Promise.all(l),
              Promise.all(c),
            ]).then(function (t) {
              const e = t[0],
                i = t[1],
                s = t[2],
                o = t[3],
                a = t[4],
                l = [];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = e[t],
                  c = i[t],
                  u = s[t],
                  h = o[t],
                  d = a[t];
                if (void 0 === r) continue;
                r.updateMatrix && r.updateMatrix();
                const p = n._createAnimationTracks(r, c, u, h, d);
                if (p) for (let t = 0; t < p.length; t++) l.push(p[t]);
              }
              return new cx(r, void 0, l);
            });
          }
          createNodeMesh(t) {
            const e = this.json,
              n = this,
              i = e.nodes[t];
            return void 0 === i.mesh
              ? null
              : n.getDependency("mesh", i.mesh).then(function (t) {
                  const e = n._getNodeRef(n.meshCache, i.mesh, t);
                  return (
                    void 0 !== i.weights &&
                      e.traverse(function (t) {
                        if (t.isMesh)
                          for (let e = 0, n = i.weights.length; e < n; e++)
                            t.morphTargetInfluences[e] = i.weights[e];
                      }),
                    e
                  );
                });
          }
          loadNode(t) {
            const e = this,
              n = this.json.nodes[t],
              i = e._loadNodeShallow(t),
              r = [],
              s = n.children || [];
            for (let t = 0, n = s.length; t < n; t++)
              r.push(e.getDependency("node", s[t]));
            const o =
              void 0 === n.skin
                ? Promise.resolve(null)
                : e.getDependency("skin", n.skin);
            return Promise.all([i, Promise.all(r), o]).then(function (t) {
              const e = t[0],
                n = t[1],
                i = t[2];
              null !== i &&
                e.traverse(function (t) {
                  t.isSkinnedMesh && t.bind(i, GT);
                });
              for (let t = 0, i = n.length; t < i; t++) e.add(n[t]);
              return e;
            });
          }
          _loadNodeShallow(t) {
            const e = this.json,
              n = this.extensions,
              i = this;
            if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
            const r = e.nodes[t],
              s = r.name ? i.createUniqueName(r.name) : "",
              o = [],
              a = i._invokeOne(function (e) {
                return e.createNodeMesh && e.createNodeMesh(t);
              });
            return (
              a && o.push(a),
              void 0 !== r.camera &&
                o.push(
                  i.getDependency("camera", r.camera).then(function (t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t);
                  })
                ),
              i
                ._invokeAll(function (e) {
                  return e.createNodeAttachment && e.createNodeAttachment(t);
                })
                .forEach(function (t) {
                  o.push(t);
                }),
              (this.nodeCache[t] = Promise.all(o).then(function (e) {
                let o;
                if (
                  ((o =
                    !0 === r.isBone
                      ? new l_()
                      : e.length > 1
                      ? new zy()
                      : 1 === e.length
                      ? e[0]
                      : new Gf()),
                  o !== e[0])
                )
                  for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                if (
                  (r.name && ((o.userData.name = r.name), (o.name = s)),
                  kT(o, r),
                  r.extensions && FT(n, o, r),
                  void 0 !== r.matrix)
                ) {
                  const t = new yf();
                  t.fromArray(r.matrix), o.applyMatrix4(t);
                } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                return (
                  i.associations.has(o) || i.associations.set(o, {}),
                  (i.associations.get(o).nodes = t),
                  o
                );
              })),
              this.nodeCache[t]
            );
          }
          loadScene(t) {
            const e = this.extensions,
              n = this.json.scenes[t],
              i = this,
              r = new zy();
            n.name && (r.name = i.createUniqueName(n.name)),
              kT(r, n),
              n.extensions && FT(e, r, n);
            const s = n.nodes || [],
              o = [];
            for (let t = 0, e = s.length; t < e; t++)
              o.push(i.getDependency("node", s[t]));
            return Promise.all(o).then(function (t) {
              for (let e = 0, n = t.length; e < n; e++) r.add(t[e]);
              return (
                (i.associations = ((t) => {
                  const e = new Map();
                  for (const [t, n] of i.associations)
                    (t instanceof im || t instanceof Np) && e.set(t, n);
                  return (
                    t.traverse((t) => {
                      const n = i.associations.get(t);
                      null != n && e.set(t, n);
                    }),
                    e
                  );
                })(r)),
                r
              );
            });
          }
          _createAnimationTracks(t, e, n, i, r) {
            const s = [],
              o = t.name ? t.name : t.uuid,
              a = [];
            let l;
            switch (
              (PT[r.path] === PT.weights
                ? t.traverse(function (t) {
                    t.morphTargetInfluences && a.push(t.name ? t.name : t.uuid);
                  })
                : a.push(o),
              PT[r.path])
            ) {
              case PT.weights:
                l = rx;
                break;
              case PT.rotation:
                l = ox;
                break;
              case PT.position:
              case PT.scale:
                l = lx;
                break;
              default:
                if (1 === n.itemSize) l = rx;
                else l = lx;
            }
            const c = void 0 !== i.interpolation ? OT[i.interpolation] : Rd,
              u = this._getArrayFromAccessor(n);
            for (let t = 0, n = a.length; t < n; t++) {
              const n = new l(a[t] + "." + PT[r.path], e.array, u, c);
              "CUBICSPLINE" === i.interpolation &&
                this._createCubicSplineTrackInterpolant(n),
                s.push(n);
            }
            return s;
          }
          _getArrayFromAccessor(t) {
            let e = t.array;
            if (t.normalized) {
              const t = VT(e.constructor),
                n = new Float32Array(e.length);
              for (let i = 0, r = e.length; i < r; i++) n[i] = e[i] * t;
              e = n;
            }
            return e;
          }
          _createCubicSplineTrackInterpolant(t) {
            (t.createInterpolant = function (t) {
              return new (this instanceof ox ? ST : wT)(
                this.times,
                this.values,
                this.getValueSize() / 3,
                t
              );
            }),
              (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                !0);
          }
        }
        function jT(t, e, n) {
          const i = e.attributes,
            r = [];
          function s(e, i) {
            return n.getDependency("accessor", e).then(function (e) {
              t.setAttribute(i, e);
            });
          }
          for (const e in i) {
            const n = LT[e] || e.toLowerCase();
            n in t.attributes || r.push(s(i[e], n));
          }
          if (void 0 !== e.indices && !t.index) {
            const i = n.getDependency("accessor", e.indices).then(function (e) {
              t.setIndex(e);
            });
            r.push(i);
          }
          return (
            Ap.workingColorSpace !== Ud &&
              "COLOR_0" in i &&
              console.warn(
                `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ap.workingColorSpace}" not supported.`
              ),
            kT(t, e),
            (function (t, e, n) {
              const i = e.attributes,
                r = new Wp();
              if (void 0 === i.POSITION) return;
              {
                const t = n.json.accessors[i.POSITION],
                  e = t.min,
                  s = t.max;
                if (void 0 === e || void 0 === s)
                  return void console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
                if (
                  (r.set(new Hp(e[0], e[1], e[2]), new Hp(s[0], s[1], s[2])),
                  t.normalized)
                ) {
                  const e = VT(TT[t.componentType]);
                  r.min.multiplyScalar(e), r.max.multiplyScalar(e);
                }
              }
              const s = e.targets;
              if (void 0 !== s) {
                const t = new Hp(),
                  e = new Hp();
                for (let i = 0, r = s.length; i < r; i++) {
                  const r = s[i];
                  if (void 0 !== r.POSITION) {
                    const i = n.json.accessors[r.POSITION],
                      s = i.min,
                      o = i.max;
                    if (void 0 !== s && void 0 !== o) {
                      if (
                        (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                        e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                        e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                        i.normalized)
                      ) {
                        const t = VT(TT[i.componentType]);
                        e.multiplyScalar(t);
                      }
                      t.max(e);
                    } else
                      console.warn(
                        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                      );
                  }
                }
                r.expandByVector(t);
              }
              t.boundingBox = r;
              const o = new cf();
              r.getCenter(o.center),
                (o.radius = r.min.distanceTo(r.max) / 2),
                (t.boundingSphere = o);
            })(t, e, n),
            Promise.all(r).then(function () {
              return void 0 !== e.targets
                ? (function (t, e, n) {
                    let i = !1,
                      r = !1,
                      s = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t];
                      if (
                        (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (s = !0),
                        i && r && s)
                      )
                        break;
                    }
                    if (!i && !r && !s) return Promise.resolve(t);
                    const o = [],
                      a = [],
                      l = [];
                    for (let c = 0, u = e.length; c < u; c++) {
                      const u = e[c];
                      if (i) {
                        const e =
                          void 0 !== u.POSITION
                            ? n.getDependency("accessor", u.POSITION)
                            : t.attributes.position;
                        o.push(e);
                      }
                      if (r) {
                        const e =
                          void 0 !== u.NORMAL
                            ? n.getDependency("accessor", u.NORMAL)
                            : t.attributes.normal;
                        a.push(e);
                      }
                      if (s) {
                        const e =
                          void 0 !== u.COLOR_0
                            ? n.getDependency("accessor", u.COLOR_0)
                            : t.attributes.color;
                        l.push(e);
                      }
                    }
                    return Promise.all([
                      Promise.all(o),
                      Promise.all(a),
                      Promise.all(l),
                    ]).then(function (e) {
                      const n = e[0],
                        o = e[1],
                        a = e[2];
                      return (
                        i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = o),
                        s && (t.morphAttributes.color = a),
                        (t.morphTargetsRelative = !0),
                        t
                      );
                    });
                  })(t, e.targets, n)
                : t;
            })
          );
        }
        class qT extends _x {
          constructor(t) {
            super(t), (this.type = vd);
          }
          parse(t) {
            const e = function (t, e) {
                switch (t) {
                  case 1:
                    throw new Error(
                      "THREE.RGBELoader: Read Error: " + (e || "")
                    );
                  case 2:
                    throw new Error(
                      "THREE.RGBELoader: Write Error: " + (e || "")
                    );
                  case 3:
                    throw new Error(
                      "THREE.RGBELoader: Bad File Format: " + (e || "")
                    );
                  default:
                    throw new Error(
                      "THREE.RGBELoader: Memory Error: " + (e || "")
                    );
                }
              },
              n = function (t, e, n) {
                e = e || 1024;
                let i = t.pos,
                  r = -1,
                  s = 0,
                  o = "",
                  a = String.fromCharCode.apply(
                    null,
                    new Uint16Array(t.subarray(i, i + 128))
                  );
                for (; 0 > (r = a.indexOf("\n")) && s < e && i < t.byteLength; )
                  (o += a),
                    (s += a.length),
                    (i += 128),
                    (a += String.fromCharCode.apply(
                      null,
                      new Uint16Array(t.subarray(i, i + 128))
                    ));
                return (
                  -1 < r &&
                  (!1 !== n && (t.pos += s + r + 1), o + a.slice(0, r))
                );
              },
              i = function (t, e, n, i) {
                const r = t[e + 3],
                  s = Math.pow(2, r - 128) / 255;
                (n[i + 0] = t[e + 0] * s),
                  (n[i + 1] = t[e + 1] * s),
                  (n[i + 2] = t[e + 2] * s),
                  (n[i + 3] = 1);
              },
              r = function (t, e, n, i) {
                const r = t[e + 3],
                  s = Math.pow(2, r - 128) / 255;
                (n[i + 0] = mm.toHalfFloat(Math.min(t[e + 0] * s, 65504))),
                  (n[i + 1] = mm.toHalfFloat(Math.min(t[e + 1] * s, 65504))),
                  (n[i + 2] = mm.toHalfFloat(Math.min(t[e + 2] * s, 65504))),
                  (n[i + 3] = mm.toHalfFloat(1));
              },
              s = new Uint8Array(t);
            s.pos = 0;
            const o = (function (t) {
                const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                  r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                  s = /^\s*FORMAT=(\S+)\s*$/,
                  o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                  a = {
                    valid: 0,
                    string: "",
                    comments: "",
                    programtype: "RGBE",
                    format: "",
                    gamma: 1,
                    exposure: 1,
                    width: 0,
                    height: 0,
                  };
                let l, c;
                for (
                  (t.pos >= t.byteLength || !(l = n(t))) &&
                    e(1, "no header found"),
                    (c = l.match(/^#\?(\S+)/)) || e(3, "bad initial token"),
                    a.valid |= 1,
                    a.programtype = c[1],
                    a.string += l + "\n";
                  (l = n(t)), !1 !== l;

                )
                  if (((a.string += l + "\n"), "#" !== l.charAt(0))) {
                    if (
                      ((c = l.match(i)) && (a.gamma = parseFloat(c[1])),
                      (c = l.match(r)) && (a.exposure = parseFloat(c[1])),
                      (c = l.match(s)) && ((a.valid |= 2), (a.format = c[1])),
                      (c = l.match(o)) &&
                        ((a.valid |= 4),
                        (a.height = parseInt(c[1], 10)),
                        (a.width = parseInt(c[2], 10))),
                      2 & a.valid && 4 & a.valid)
                    )
                      break;
                  } else a.comments += l + "\n";
                return (
                  2 & a.valid || e(3, "missing format specifier"),
                  4 & a.valid || e(3, "missing image size specifier"),
                  a
                );
              })(s),
              a = o.width,
              l = o.height,
              c = (function (t, n, i) {
                const r = n;
                if (
                  r < 8 ||
                  r > 32767 ||
                  2 !== t[0] ||
                  2 !== t[1] ||
                  128 & t[2]
                )
                  return new Uint8Array(t);
                r !== ((t[2] << 8) | t[3]) && e(3, "wrong scanline width");
                const s = new Uint8Array(4 * n * i);
                s.length || e(4, "unable to allocate buffer space");
                let o = 0,
                  a = 0;
                const l = 4 * r,
                  c = new Uint8Array(4),
                  u = new Uint8Array(l);
                let h = i;
                for (; h > 0 && a < t.byteLength; ) {
                  a + 4 > t.byteLength && e(1),
                    (c[0] = t[a++]),
                    (c[1] = t[a++]),
                    (c[2] = t[a++]),
                    (c[3] = t[a++]),
                    (2 == c[0] && 2 == c[1] && ((c[2] << 8) | c[3]) == r) ||
                      e(3, "bad rgbe scanline format");
                  let n,
                    i = 0;
                  for (; i < l && a < t.byteLength; ) {
                    n = t[a++];
                    const r = n > 128;
                    if (
                      (r && (n -= 128),
                      (0 === n || i + n > l) && e(3, "bad scanline data"),
                      r)
                    ) {
                      const e = t[a++];
                      for (let t = 0; t < n; t++) u[i++] = e;
                    } else u.set(t.subarray(a, a + n), i), (i += n), (a += n);
                  }
                  const d = r;
                  for (let t = 0; t < d; t++) {
                    let e = 0;
                    (s[o] = u[t + e]),
                      (e += r),
                      (s[o + 1] = u[t + e]),
                      (e += r),
                      (s[o + 2] = u[t + e]),
                      (e += r),
                      (s[o + 3] = u[t + e]),
                      (o += 4);
                  }
                  h--;
                }
                return s;
              })(s.subarray(s.pos), a, l);
            let u, h, d;
            switch (this.type) {
              case gd:
                d = c.length / 4;
                const t = new Float32Array(4 * d);
                for (let e = 0; e < d; e++) i(c, 4 * e, t, 4 * e);
                (u = t), (h = gd);
                break;
              case vd:
                d = c.length / 4;
                const e = new Uint16Array(4 * d);
                for (let t = 0; t < d; t++) r(c, 4 * t, e, 4 * t);
                (u = e), (h = vd);
                break;
              default:
                throw new Error(
                  "THREE.RGBELoader: unsupported type: ",
                  this.type
                );
            }
            return {
              width: a,
              height: l,
              data: u,
              header: o.string,
              gamma: o.gamma,
              exposure: o.exposure,
              type: h,
            };
          }
          setDataType(t) {
            return (this.type = t), this;
          }
          load(t, e, n, i) {
            return super.load(
              t,
              function (t, n) {
                switch (t.type) {
                  case gd:
                  case vd:
                    (t.colorSpace = Ud),
                      (t.minFilter = cd),
                      (t.magFilter = cd),
                      (t.generateMipmaps = !1),
                      (t.flipY = !0);
                }
                e && e(t, n);
              },
              n,
              i
            );
          }
        }
        class XT {
          constructor() {
            (this.modelLoader = null),
              (this.modelLoader = new $M()),
              (this.textureLoader = new xx()),
              (this.envTextureLoader = new qT());
          }
          toLoadAsyncTexture(t) {
            return this.textureLoader.loadAsync(t);
          }
          toLoadAsyncModel(t) {
            return this.modelLoader.loadAsync(t);
          }
          toLoadElementImg(t) {
            return new Promise((e) => {
              const n = t.getAttribute("src"),
                i = t.getAttribute("width"),
                r = t.getAttribute("height"),
                s = new Image();
              (s.src = n),
                s.addEventListener("load", (s) => {
                  const o = {
                    texture: this.textureLoader.load(n),
                    ele: t,
                    src: n,
                    w: i,
                    h: r,
                    aspect: i / r,
                  };
                  return (o.texture.outputColorSpace = Dd), e(o);
                });
            });
          }
          toLoadElementVideo(t) {
            const e = t.getAttribute("src"),
              n = t.getAttribute("width"),
              i = t.getAttribute("height");
            return new Promise(async (r) => {
              try {
                await t.play();
                let s = !1;
                t.addEventListener("timeupdate", (o) => {
                  if (!s) {
                    s = !0;
                    const o = {
                      ele: t,
                      src: e,
                      texture: new z_(t),
                      w: n,
                      h: i,
                      aspect: n / i,
                    };
                    return (
                      (o.texture.outputColorSpace = Dd),
                      setTimeout(() => {}, 300),
                      r(o)
                    );
                  }
                });
              } catch (t) {
                return console.error(t), r(null);
              }
            });
          }
          toLoadHDR(t) {
            return this.envTextureLoader.loadAsync(t);
          }
        }
        var KT = n(5921),
          $T = n.n(KT),
          ZT = n(2545),
          JT = n.n(ZT);
        class QT {
          constructor(t, e, n) {
            (this.stage = t),
              (this.isMatchMediaWidth = e),
              (this.isMatchMediaHover = n),
              (this.sphereAmount = 6),
              (this.pointerMesh = null),
              (this.pointerBody = null),
              (this.sphereMeshs = []),
              (this.sphereBodys = []),
              (this.config = {
                correctionY: this.isMatchMediaWidth ? 0.5 : 0,
                commonRadius: this.isMatchMediaWidth ? 0.75 : 1.5,
                bodyRadius: this.isMatchMediaWidth ? 1.3 : 0.65,
                initPosRange: (this.isMatchMediaWidth, 8),
                angularDamping: 0.3,
                linearDamping: 0.9,
                mass: 0.4,
                uDiffuseThreshold: Kx.lightDiffuse,
                uSunStrength: Kx.lightStrength,
                moveScaler: 2.7,
                backToRelativeScaler: -16,
                timeSpeed: 1,
                lightPosition: new Hp(0.63, 0.16, 1),
                sunColor: Kx.sunColor,
                colors: Kx.colorPalette,
              }),
              (this.loader = new XT());
          }
          resize(t, e) {
            (this.isMatchMediaWidth = t), (this.isMatchMediaHover = e);
          }
          update(t) {
            const e = t.elapsed;
            for (let t = 0; t < this.sphereBodys.length; t++) {
              const n = t % 2 == 0 ? 1 : -1,
                i = this.sphereBodys[t],
                r =
                  0.27 *
                  Math.sin(t + 1.26 * e * (1.03 + 0.5 * Math.cos(0.21 * t))) *
                  this.config.moveScaler *
                  n,
                s =
                  0.77 *
                    Math.abs(
                      Math.cos(t + 1.12 * e * Math.cos(1.22 + 0.1424 * t))
                    ) -
                  this.config.correctionY,
                o =
                  0.27 *
                    Math.cos(t + 1.32 * e * 0.1 * Math.sin(0.92 + 0.53 * t)) *
                    this.config.moveScaler *
                    n +
                  0.5,
                a = this.sphereMeshs[t].relativePosition;
              a
                .set(i.position.x + r, i.position.y + s, i.position.z + o)
                .normalize()
                .multiplyScalar(this.config.backToRelativeScaler),
                i.applyForce(
                  i.applyForceVector.set(a.x, a.y, a.z),
                  this.stage.cannonWorldOriginPosition
                );
            }
            for (let t = 0; t < this.sphereMeshs.length; t++) {
              this.sphereMeshs[t].position.copy(this.sphereBodys[t].position);
            }
            {
              const t = this.stage.coords.normalize,
                e = 0,
                n =
                  Math.tan(0.5 * this.stage.cameraRadianAngle) *
                  (this.stage.camera.position.z - e) *
                  2,
                i = n * this.stage.resolution.aspect;
              (this.pointerBody.position.x =
                t.x * i * 0.5 + this.stage.camera.position.x),
                (this.pointerBody.position.y =
                  t.y * n * 0.5 + this.stage.camera.position.y),
                (this.pointerBody.position.z = e);
            }
          }
          getDepthScaler(t) {
            let e =
              (this.stage.resolution.y /
                Math.tan((this.stage.camera.fov * Math.PI) / 360)) *
              0.5;
            return Math.abs(this.stage.camera.position.z - t) / e;
          }
          init() {
            return new Promise(async (t) => {
              const e = new H_(this.config.commonRadius, 8, 8),
                n = e.parameters.radius,
                i = new V_({
                  vertexShader: $T(),
                  fragmentShader: JT(),
                  uniforms: {
                    uTime: {
                      value: 0,
                    },
                    uColor: {
                      value: this.config.colors[0],
                    },
                    uSunColor: {
                      value: this.config.sunColor,
                    },
                    uSunStrength: {
                      value: this.config.uSunStrength,
                    },
                    uDiffuseThreshold: {
                      value: this.config.uDiffuseThreshold,
                    },
                    uLightPosition: {
                      value: this.config.lightPosition,
                    },
                  },
                  transparent: !1,
                  side: Th,
                });
              let r = null,
                s = null;
              Kx.isGui &&
                ((r = GUI.addFolder("sphere material")),
                (s = GUI.addFolder("sphere physics")));
              {
                const t = 1.25 * n,
                  e = new Cb({
                    type: Cb.KINEMATIC,
                    shape: new xb(new tb(t, t, t)),
                    position: new tb(0, 0, 0),
                  });
                (this.pointerBody = e),
                  this.stage.cannonWorld.addBody(this.pointerBody);
              }
              for (let t = 0; t < this.sphereAmount; t++) {
                const s = new Xm(e, i.clone());
                (s.relativePosition = new Hp()),
                  (s.material.uniforms.uColor.value = this.config.colors[t]);
                const o = this.config.initPosRange;
                s.position.set(
                  xM.clampRandom(-o, o),
                  xM.clampRandom(-o, o),
                  xM.clampRandom(-o, o)
                );
                const a = n * this.config.bodyRadius,
                  l = new Cb({
                    mass: this.config.mass,
                    shape: new xb(new tb(a, a, a)),
                    angularDamping: this.config.angularDamping,
                    linearDamping: this.config.linearDamping,
                    position: s.position,
                  });
                (l.applyForceVector = new tb()),
                  this.sphereBodys.push(l),
                  this.stage.cannonWorld.addBody(l),
                  this.sphereMeshs.push(s),
                  this.stage.scene.add(s),
                  Kx.isGui &&
                    r
                      .addColor(s.material.uniforms.uColor, "value")
                      .name(`color${t + 1}`)
                      .onChange((t) => {
                        s.material.uniforms.uColor.value = t;
                      });
              }
              Kx.isGui &&
                (r
                  .addColor(this.config, "sunColor")
                  .name("sunColor")
                  .onChange((t) => {
                    this.config.lightPosition.z = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[e].material.uniforms.uSunColor.value = t;
                    }
                  })
                  .listen(),
                r
                  .add(this.config, "uDiffuseThreshold", 0, 1, 0.01)
                  .name("uDiffuseThreshold")
                  .onChange((t) => {
                    this.config.uDiffuseThreshold = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[
                        e
                      ].material.uniforms.uDiffuseThreshold.value = t;
                    }
                  })
                  .listen(),
                r
                  .add(this.config, "uSunStrength", 0, 1, 0.01)
                  .name("uSunStrength")
                  .onChange((t) => {
                    this.config.uSunStrength = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[e].material.uniforms.uSunStrength.value =
                        t;
                    }
                  })
                  .listen(),
                r
                  .add(this.config.lightPosition, "x", -1, 1, 0.01)
                  .name("uLightPosition.x")
                  .onChange((t) => {
                    this.config.lightPosition.x = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[
                        e
                      ].material.uniforms.uLightPosition.value.x = t;
                    }
                  })
                  .listen(),
                r
                  .add(this.config.lightPosition, "y", -1, 1, 0.01)
                  .name("uLightPosition.y")
                  .onChange((t) => {
                    this.config.lightPosition.y = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[
                        e
                      ].material.uniforms.uLightPosition.value.y = t;
                    }
                  })
                  .listen(),
                r
                  .add(this.config.lightPosition, "z", -1, 1, 0.01)
                  .name("uLightPosition.z")
                  .onChange((t) => {
                    this.config.lightPosition.z = t;
                    for (let e = 0; e < this.sphereMeshs.length; e++) {
                      this.sphereMeshs[
                        e
                      ].material.uniforms.uLightPosition.value.z = t;
                    }
                  })
                  .listen(),
                s
                  .add(this.config, "angularDamping", 0, 1, 0.01)
                  .name("angularDamping")
                  .onChange((t) => {
                    this.config.angularDamping = t;
                    for (let e = 0; e < this.sphereBodys.length; e++) {
                      this.sphereBodys[e].angularDamping = t;
                    }
                  })
                  .listen(),
                s
                  .add(this.config, "linearDamping", 0, 1, 0.01)
                  .name("linearDamping")
                  .onChange((t) => {
                    this.config.linearDamping = t;
                    for (let e = 0; e < this.sphereBodys.length; e++) {
                      this.sphereBodys[e].linearDamping = t;
                    }
                  })
                  .listen(),
                s
                  .add(this.config, "backToRelativeScaler", -30, -1, 1)
                  .name("backToRelativePositionScaler")
                  .onChange((t) => {
                    this.config.backToRelativeScaler = t;
                  })
                  .listen(),
                s
                  .add(this.config, "moveScaler", 0, 10, 0.1)
                  .name("moveScaler")
                  .onChange((t) => {
                    this.config.moveScaler = t;
                  })
                  .listen()),
                t();
            });
          }
        }
        var tA = n(1321),
          eA = n.n(tA),
          nA = n(7195),
          iA = n.n(nA),
          rA = n(3801),
          sA = n.n(rA),
          oA = n(7118),
          aA = n.n(oA);
        class lA {
          constructor(t, e) {
            (this.stage = t),
              (this.objects = e),
              (this.resolution = {
                x: this.stage.resolution.x * this.stage.pixelRatio,
                y: this.stage.resolution.y * this.stage.pixelRatio,
                minx: Math.round(0.5 * this.stage.resolution.x),
                miny: Math.round(0.5 * this.stage.resolution.y),
                aspectRatio: this.stage.resolution.aspect,
              }),
              (this.CONFIG = {
                GAUSS_RADIUS: 128,
                CONTRAST: 80,
                SUBTRACT: 15,
                BACKGROUND: Kx.bgColor,
                MIN_BUFFER: 0.05,
              });
          }
          calcGaussWeight(t) {
            let e = 0;
            const n = [];
            for (let i = 0; i < t; i++) {
              const r = 1 + 2 * i;
              let s = Math.exp((r * r * -0.5) / (t * t));
              n.push(s), i > 0 && (s *= 2), (e += s);
            }
            for (let t = 0; t < n.length; t++) n[t] /= e;
            return n;
          }
          getRenderTarget(t = this.resolution.x, e = this.resolution.y) {
            return new Fp(t, e, {});
          }
          resize() {
            (this.resolution.x =
              this.stage.resolution.x * this.stage.pixelRatio),
              (this.resolution.y =
                this.stage.resolution.y * this.stage.pixelRatio);
            const t = this.resolution.x,
              e = this.resolution.y;
            (this.resolution.minx = Math.round(0.5 * t)),
              (this.resolution.miny = Math.round(0.5 * e)),
              (this.resolution.aspectRatio = t / e);
            const n = this.CONFIG.MIN_BUFFER;
            this.fbos.input.setSize(t, e),
              this.fbos.output.setSize(t, e),
              this.fbos.horizontal.setSize(t * n, e * n),
              this.fbos.vertical.setSize(t * n, e * n),
              (this.horizontalMaterial.uniforms.uPixelSize.value.x = 1 / t),
              (this.horizontalMaterial.uniforms.uPixelSize.value.y = 1 / e),
              (this.verticalMaterial.uniforms.uPixelSize.value.x = 1 / t),
              (this.verticalMaterial.uniforms.uPixelSize.value.y = 1 / e);
          }
          update(t) {
            this.stage.renderer.setClearColor(16777215, 0),
              this.stage.renderer.setRenderTarget(this.fbos.input),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.stage.scene, this.stage.camera),
              (this.mesh.material = this.horizontalMaterial),
              this.stage.renderer.setRenderTarget(this.fbos.horizontal),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera),
              (this.mesh.material = this.verticalMaterial),
              this.stage.renderer.setRenderTarget(this.fbos.vertical),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera),
              (this.mesh.material = this.outputMaterial),
              this.stage.renderer.setClearColor(this.CONFIG.BACKGROUND, 1),
              this.stage.renderer.setRenderTarget(null),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera);
          }
          updateScreenshot() {
            this.stage.renderer.setClearColor(16777215, 0),
              this.stage.renderer.setRenderTarget(this.fbos.input),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.stage.scene, this.stage.camera),
              (this.mesh.material = this.horizontalMaterial),
              this.stage.renderer.setRenderTarget(this.fbos.horizontal),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera),
              (this.mesh.material = this.verticalMaterial),
              this.stage.renderer.setRenderTarget(this.fbos.vertical),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera),
              (this.mesh.material = this.outputMaterial),
              this.stage.renderer.setClearColor(this.CONFIG.BACKGROUND, 1),
              this.stage.renderer.setRenderTarget(this.fbos.output),
              this.stage.renderer.clear(),
              this.stage.renderer.render(this.mesh, this.stage.camera),
              (this.objects.gooeyPlaneMesh.material.uniforms.uTexture.value =
                this.fbos.output.texture);
          }
          init() {
            return new Promise((t) => {
              if (
                ((this.fbos = {
                  input: this.getRenderTarget(
                    this.resolution.x,
                    this.resolution.y
                  ),
                  output: this.getRenderTarget(
                    this.resolution.x,
                    this.resolution.y
                  ),
                  horizontal: this.getRenderTarget(
                    this.resolution.x * this.CONFIG.MIN_BUFFER,
                    this.resolution.y * this.CONFIG.MIN_BUFFER
                  ),
                  vertical: this.getRenderTarget(
                    this.resolution.x * this.CONFIG.MIN_BUFFER,
                    this.resolution.y * this.CONFIG.MIN_BUFFER
                  ),
                }),
                (this.mesh = new Xm(
                  new gg(2.1, 2.1, 1, 1),
                  new V_({
                    vertexShader: eA(),
                    fragmentShader: iA(),
                    uniforms: {},
                    side: Th,
                  })
                )),
                (this.outputMaterial = new V_({
                  vertexShader: eA(),
                  fragmentShader: sA(),
                  uniforms: {
                    uTexture: {
                      value: this.fbos.vertical.texture,
                    },
                    uContrast: {
                      value: this.CONFIG.CONTRAST,
                    },
                    uSubtract: {
                      value: this.CONFIG.SUBTRACT,
                    },
                  },
                  transparent: !0,
                  side: Th,
                })),
                (this.horizontalMaterial = new V_({
                  vertexShader: eA(),
                  fragmentShader: aA(),
                  uniforms: {
                    uTexture: {
                      value: this.fbos.input.texture,
                    },
                    uPixelSize: {
                      value: new pp(
                        1 / this.resolution.x,
                        1 / this.resolution.y
                      ),
                    },
                    uDirection: {
                      value: new pp(1, 0),
                    },
                    uWeights: {
                      value: this.calcGaussWeight(this.CONFIG.GAUSS_RADIUS),
                    },
                  },
                  defines: {
                    GAUSS_RADIUS: this.CONFIG.GAUSS_RADIUS,
                  },
                  transparent: !1,
                  side: Th,
                })),
                (this.verticalMaterial = new V_({
                  vertexShader: eA(),
                  fragmentShader: aA(),
                  uniforms: {
                    uTexture: {
                      value: this.fbos.horizontal.texture,
                    },
                    uPixelSize: {
                      value: new pp(
                        1 / this.resolution.x,
                        1 / this.resolution.y
                      ),
                    },
                    uDirection: {
                      value: new pp(0, 1),
                    },
                    uWeights: {
                      value: this.calcGaussWeight(this.CONFIG.GAUSS_RADIUS),
                    },
                  },
                  defines: {
                    GAUSS_RADIUS: this.CONFIG.GAUSS_RADIUS,
                  },
                  transparent: !1,
                  side: Th,
                })),
                Kx.isGui)
              ) {
                const t = window.GUI.addFolder("gooey");
                t
                  .add(this.CONFIG, "CONTRAST", 10, 500)
                  .name("uContrast")
                  .onChange((t) => {
                    (this.CONFIG.CONTRAST = t),
                      (this.outputMaterial.uniforms.uContrast.value = t);
                  })
                  .listen(),
                  t
                    .add(this.CONFIG, "SUBTRACT", 0, 500)
                    .name("uSubtract")
                    .onChange((t) => {
                      (this.CONFIG.SUBTRACT = t),
                        (this.outputMaterial.uniforms.uSubtract.value = t);
                    })
                    .listen(),
                  t
                    .add(this.CONFIG, "GAUSS_RADIUS", 0, 200)
                    .name("Gauss radius")
                    .onChange((t) => {
                      (this.CONFIG.GAUSS_RADIUS = t),
                        (this.horizontalMaterial.uniforms.uWeights.value =
                          this.calcGaussWeight(this.CONFIG.GAUSS_RADIUS)),
                        (this.verticalMaterial.uniforms.uWeights.value =
                          this.calcGaussWeight(this.CONFIG.GAUSS_RADIUS)),
                        (this.verticalMaterial.needsUpdate = !0),
                        (this.horizontalMaterial.needsUpdate = !0);
                    })
                    .listen(),
                  t
                    .addColor(this.CONFIG, "BACKGROUND")
                    .name("background")
                    .onChange((t) => {
                      this.CONFIG.BACKGROUND = t;
                    })
                    .listen();
              }
              t();
            });
          }
        }
        n(1629), n(3500);
        var cA,
          uA = n(4610),
          hA = n.n(uA),
          dA =
            (n(2008),
            n(3792),
            n(9085),
            n(6099),
            n(8940),
            n(7764),
            n(3772),
            n(2953),
            n(5858)),
          pA = n.n(dA),
          fA = n(181),
          mA = n.n(fA),
          gA = n(7654),
          vA = n.n(gA),
          yA = [],
          _A = "ResizeObserver loop completed with undelivered notifications.";
        !(function (t) {
          (t.BORDER_BOX = "border-box"),
            (t.CONTENT_BOX = "content-box"),
            (t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box");
        })(cA || (cA = {}));
        var xA,
          bA = function (t) {
            return Object.freeze(t);
          },
          wA = function (t, e) {
            (this.inlineSize = t), (this.blockSize = e), bA(this);
          },
          EA = (function () {
            function t(t, e, n, i) {
              return (
                (this.x = t),
                (this.y = e),
                (this.width = n),
                (this.height = i),
                (this.top = this.y),
                (this.left = this.x),
                (this.bottom = this.top + this.height),
                (this.right = this.left + this.width),
                bA(this)
              );
            }
            return (
              (t.prototype.toJSON = function () {
                var t = this;
                return {
                  x: t.x,
                  y: t.y,
                  top: t.top,
                  right: t.right,
                  bottom: t.bottom,
                  left: t.left,
                  width: t.width,
                  height: t.height,
                };
              }),
              (t.fromRect = function (e) {
                return new t(e.x, e.y, e.width, e.height);
              }),
              t
            );
          })(),
          SA = function (t) {
            return t instanceof SVGElement && "getBBox" in t;
          },
          MA = function (t) {
            if (SA(t)) {
              var e = t.getBBox(),
                n = e.width,
                i = e.height;
              return !n && !i;
            }
            var r = t,
              s = r.offsetWidth,
              o = r.offsetHeight;
            return !(s || o || t.getClientRects().length);
          },
          TA = function (t) {
            var e;
            if (t instanceof Element) return !0;
            var n =
              null === (e = null == t ? void 0 : t.ownerDocument) ||
              void 0 === e
                ? void 0
                : e.defaultView;
            return !!(n && t instanceof n.Element);
          },
          AA = "undefined" != typeof window ? window : {},
          RA = new WeakMap(),
          CA = /auto|scroll/,
          LA = /^tb|vertical/,
          PA = /msie|trident/i.test(AA.navigator && AA.navigator.userAgent),
          OA = function (t) {
            return parseFloat(t || "0");
          },
          IA = function (t, e, n) {
            return (
              void 0 === t && (t = 0),
              void 0 === e && (e = 0),
              void 0 === n && (n = !1),
              new wA((n ? e : t) || 0, (n ? t : e) || 0)
            );
          },
          NA = bA({
            devicePixelContentBoxSize: IA(),
            borderBoxSize: IA(),
            contentBoxSize: IA(),
            contentRect: new EA(0, 0, 0, 0),
          }),
          DA = function (t, e) {
            if ((void 0 === e && (e = !1), RA.has(t) && !e)) return RA.get(t);
            if (MA(t)) return RA.set(t, NA), NA;
            var n = getComputedStyle(t),
              i = SA(t) && t.ownerSVGElement && t.getBBox(),
              r = !PA && "border-box" === n.boxSizing,
              s = LA.test(n.writingMode || ""),
              o = !i && CA.test(n.overflowY || ""),
              a = !i && CA.test(n.overflowX || ""),
              l = i ? 0 : OA(n.paddingTop),
              c = i ? 0 : OA(n.paddingRight),
              u = i ? 0 : OA(n.paddingBottom),
              h = i ? 0 : OA(n.paddingLeft),
              d = i ? 0 : OA(n.borderTopWidth),
              p = i ? 0 : OA(n.borderRightWidth),
              f = i ? 0 : OA(n.borderBottomWidth),
              m = h + c,
              g = l + u,
              v = (i ? 0 : OA(n.borderLeftWidth)) + p,
              y = d + f,
              _ = a ? t.offsetHeight - y - t.clientHeight : 0,
              x = o ? t.offsetWidth - v - t.clientWidth : 0,
              b = r ? m + v : 0,
              w = r ? g + y : 0,
              E = i ? i.width : OA(n.width) - b - x,
              S = i ? i.height : OA(n.height) - w - _,
              M = E + m + x + v,
              T = S + g + _ + y,
              A = bA({
                devicePixelContentBoxSize: IA(
                  Math.round(E * devicePixelRatio),
                  Math.round(S * devicePixelRatio),
                  s
                ),
                borderBoxSize: IA(M, T, s),
                contentBoxSize: IA(E, S, s),
                contentRect: new EA(h, l, E, S),
              });
            return RA.set(t, A), A;
          },
          UA = function (t, e, n) {
            var i = DA(t, n),
              r = i.borderBoxSize,
              s = i.contentBoxSize,
              o = i.devicePixelContentBoxSize;
            switch (e) {
              case cA.DEVICE_PIXEL_CONTENT_BOX:
                return o;
              case cA.BORDER_BOX:
                return r;
              default:
                return s;
            }
          },
          FA = function (t) {
            var e = DA(t);
            (this.target = t),
              (this.contentRect = e.contentRect),
              (this.borderBoxSize = bA([e.borderBoxSize])),
              (this.contentBoxSize = bA([e.contentBoxSize])),
              (this.devicePixelContentBoxSize = bA([
                e.devicePixelContentBoxSize,
              ]));
          },
          kA = function (t) {
            if (MA(t)) return 1 / 0;
            for (var e = 0, n = t.parentNode; n; ) (e += 1), (n = n.parentNode);
            return e;
          },
          BA = function () {
            var t = 1 / 0,
              e = [];
            yA.forEach(function (n) {
              if (0 !== n.activeTargets.length) {
                var i = [];
                n.activeTargets.forEach(function (e) {
                  var n = new FA(e.target),
                    r = kA(e.target);
                  i.push(n),
                    (e.lastReportedSize = UA(e.target, e.observedBox)),
                    r < t && (t = r);
                }),
                  e.push(function () {
                    n.callback.call(n.observer, i, n.observer);
                  }),
                  n.activeTargets.splice(0, n.activeTargets.length);
              }
            });
            for (var n = 0, i = e; n < i.length; n++) {
              (0, i[n])();
            }
            return t;
          },
          zA = function (t) {
            yA.forEach(function (e) {
              e.activeTargets.splice(0, e.activeTargets.length),
                e.skippedTargets.splice(0, e.skippedTargets.length),
                e.observationTargets.forEach(function (n) {
                  n.isActive() &&
                    (kA(n.target) > t
                      ? e.activeTargets.push(n)
                      : e.skippedTargets.push(n));
                });
            });
          },
          HA = function () {
            var t,
              e = 0;
            for (
              zA(e);
              yA.some(function (t) {
                return t.activeTargets.length > 0;
              });

            )
              (e = BA()), zA(e);
            return (
              yA.some(function (t) {
                return t.skippedTargets.length > 0;
              }) &&
                ("function" == typeof ErrorEvent
                  ? (t = new ErrorEvent("error", {
                      message: _A,
                    }))
                  : ((t = document.createEvent("Event")).initEvent(
                      "error",
                      !1,
                      !1
                    ),
                    (t.message = _A)),
                window.dispatchEvent(t)),
              e > 0
            );
          },
          VA = [],
          GA = function (t) {
            if (!xA) {
              var e = 0,
                n = document.createTextNode("");
              new MutationObserver(function () {
                return VA.splice(0).forEach(function (t) {
                  return t();
                });
              }).observe(n, {
                characterData: !0,
              }),
                (xA = function () {
                  n.textContent = "".concat(e ? e-- : e++);
                });
            }
            VA.push(t), xA();
          },
          WA = 0,
          jA = {
            attributes: !0,
            characterData: !0,
            childList: !0,
            subtree: !0,
          },
          qA = [
            "resize",
            "load",
            "transitionend",
            "animationend",
            "animationstart",
            "animationiteration",
            "keyup",
            "keydown",
            "mouseup",
            "mousedown",
            "mouseover",
            "mouseout",
            "blur",
            "focus",
          ],
          XA = function (t) {
            return void 0 === t && (t = 0), Date.now() + t;
          },
          YA = !1,
          KA = (function () {
            function t() {
              var t = this;
              (this.stopped = !0),
                (this.listener = function () {
                  return t.schedule();
                });
            }
            return (
              (t.prototype.run = function (t) {
                var e = this;
                if ((void 0 === t && (t = 250), !YA)) {
                  YA = !0;
                  var n = XA(t);
                  !(function (t) {
                    GA(function () {
                      requestAnimationFrame(t);
                    });
                  })(function () {
                    var i = !1;
                    try {
                      i = HA();
                    } finally {
                      if (((YA = !1), (t = n - XA()), !WA)) return;
                      i ? e.run(1e3) : t > 0 ? e.run(t) : e.start();
                    }
                  });
                }
              }),
              (t.prototype.schedule = function () {
                this.stop(), this.run();
              }),
              (t.prototype.observe = function () {
                var t = this,
                  e = function () {
                    return t.observer && t.observer.observe(document.body, jA);
                  };
                document.body
                  ? e()
                  : AA.addEventListener("DOMContentLoaded", e);
              }),
              (t.prototype.start = function () {
                var t = this;
                this.stopped &&
                  ((this.stopped = !1),
                  (this.observer = new MutationObserver(this.listener)),
                  this.observe(),
                  qA.forEach(function (e) {
                    return AA.addEventListener(e, t.listener, !0);
                  }));
              }),
              (t.prototype.stop = function () {
                var t = this;
                this.stopped ||
                  (this.observer && this.observer.disconnect(),
                  qA.forEach(function (e) {
                    return AA.removeEventListener(e, t.listener, !0);
                  }),
                  (this.stopped = !0));
              }),
              t
            );
          })(),
          $A = new KA(),
          ZA = function (t) {
            !WA && t > 0 && $A.start(), !(WA += t) && $A.stop();
          },
          JA = (function () {
            function t(t, e) {
              (this.target = t),
                (this.observedBox = e || cA.CONTENT_BOX),
                (this.lastReportedSize = {
                  inlineSize: 0,
                  blockSize: 0,
                });
            }
            return (
              (t.prototype.isActive = function () {
                var t,
                  e = UA(this.target, this.observedBox, !0);
                return (
                  (t = this.target),
                  SA(t) ||
                    (function (t) {
                      switch (t.tagName) {
                        case "INPUT":
                          if ("image" !== t.type) break;
                        case "VIDEO":
                        case "AUDIO":
                        case "EMBED":
                        case "OBJECT":
                        case "CANVAS":
                        case "IFRAME":
                        case "IMG":
                          return !0;
                      }
                      return !1;
                    })(t) ||
                    "inline" !== getComputedStyle(t).display ||
                    (this.lastReportedSize = e),
                  this.lastReportedSize.inlineSize !== e.inlineSize ||
                    this.lastReportedSize.blockSize !== e.blockSize
                );
              }),
              t
            );
          })(),
          QA = function (t, e) {
            (this.activeTargets = []),
              (this.skippedTargets = []),
              (this.observationTargets = []),
              (this.observer = t),
              (this.callback = e);
          },
          tR = new WeakMap(),
          eR = function (t, e) {
            for (var n = 0; n < t.length; n += 1)
              if (t[n].target === e) return n;
            return -1;
          },
          nR = (function () {
            function t() {}
            return (
              (t.connect = function (t, e) {
                var n = new QA(t, e);
                tR.set(t, n);
              }),
              (t.observe = function (t, e, n) {
                var i = tR.get(t),
                  r = 0 === i.observationTargets.length;
                eR(i.observationTargets, e) < 0 &&
                  (r && yA.push(i),
                  i.observationTargets.push(new JA(e, n && n.box)),
                  ZA(1),
                  $A.schedule());
              }),
              (t.unobserve = function (t, e) {
                var n = tR.get(t),
                  i = eR(n.observationTargets, e),
                  r = 1 === n.observationTargets.length;
                i >= 0 &&
                  (r && yA.splice(yA.indexOf(n), 1),
                  n.observationTargets.splice(i, 1),
                  ZA(-1));
              }),
              (t.disconnect = function (t) {
                var e = this,
                  n = tR.get(t);
                n.observationTargets.slice().forEach(function (n) {
                  return e.unobserve(t, n.target);
                }),
                  n.activeTargets.splice(0, n.activeTargets.length);
              }),
              t
            );
          })(),
          iR = (function () {
            function t(t) {
              if (0 === arguments.length)
                throw new TypeError(
                  "Failed to construct 'ResizeObserver': 1 argument required, but only 0 present."
                );
              if ("function" != typeof t)
                throw new TypeError(
                  "Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function."
                );
              nR.connect(this, t);
            }
            return (
              (t.prototype.observe = function (t, e) {
                if (0 === arguments.length)
                  throw new TypeError(
                    "Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present."
                  );
                if (!TA(t))
                  throw new TypeError(
                    "Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element"
                  );
                nR.observe(this, t, e);
              }),
              (t.prototype.unobserve = function (t) {
                if (0 === arguments.length)
                  throw new TypeError(
                    "Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present."
                  );
                if (!TA(t))
                  throw new TypeError(
                    "Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element"
                  );
                nR.unobserve(this, t);
              }),
              (t.prototype.disconnect = function () {
                nR.disconnect(this);
              }),
              (t.toString = function () {
                return "function ResizeObserver () { [polyfill code] }";
              }),
              t
            );
          })(),
          rR =
            (n(2712),
            n(2010),
            n(7495),
            n(1761),
            n(5440),
            function (t) {
              return Array.prototype.reduce.call(
                t,
                function (t, e) {
                  var n = e.name.match(/data-simplebar-(.+)/);
                  if (n) {
                    var i = n[1].replace(/\W+(.)/g, function (t, e) {
                      return e.toUpperCase();
                    });
                    switch (e.value) {
                      case "true":
                        t[i] = !0;
                        break;
                      case "false":
                        t[i] = !1;
                        break;
                      case void 0:
                        t[i] = !0;
                        break;
                      default:
                        t[i] = e.value;
                    }
                  }
                  return t;
                },
                {}
              );
            });
        function sR(t) {
          return t && t.ownerDocument && t.ownerDocument.defaultView
            ? t.ownerDocument.defaultView
            : window;
        }
        function oR(t) {
          return t && t.ownerDocument ? t.ownerDocument : document;
        }
        var aR = null,
          lR = null;
        function cR(t) {
          if (null === aR) {
            var e = oR(t);
            if (void 0 === e) return (aR = 0);
            var n = e.body,
              i = e.createElement("div");
            i.classList.add("simplebar-hide-scrollbar"), n.appendChild(i);
            var r = i.getBoundingClientRect().right;
            n.removeChild(i), (aR = r);
          }
          return aR;
        }
        hA() &&
          window.addEventListener("resize", function () {
            lR !== window.devicePixelRatio &&
              ((lR = window.devicePixelRatio), (aR = null));
          });
        var uR = (function () {
          function t(e, n) {
            var i = this;
            (this.onScroll = function () {
              var t = sR(i.el);
              i.scrollXTicking ||
                (t.requestAnimationFrame(i.scrollX), (i.scrollXTicking = !0)),
                i.scrollYTicking ||
                  (t.requestAnimationFrame(i.scrollY), (i.scrollYTicking = !0));
            }),
              (this.scrollX = function () {
                i.axis.x.isOverflowing &&
                  (i.showScrollbar("x"), i.positionScrollbar("x")),
                  (i.scrollXTicking = !1);
              }),
              (this.scrollY = function () {
                i.axis.y.isOverflowing &&
                  (i.showScrollbar("y"), i.positionScrollbar("y")),
                  (i.scrollYTicking = !1);
              }),
              (this.onMouseEnter = function () {
                i.showScrollbar("x"), i.showScrollbar("y");
              }),
              (this.onMouseMove = function (t) {
                (i.mouseX = t.clientX),
                  (i.mouseY = t.clientY),
                  (i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
                    i.onMouseMoveForAxis("x"),
                  (i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
                    i.onMouseMoveForAxis("y");
              }),
              (this.onMouseLeave = function () {
                i.onMouseMove.cancel(),
                  (i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
                    i.onMouseLeaveForAxis("x"),
                  (i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
                    i.onMouseLeaveForAxis("y"),
                  (i.mouseX = -1),
                  (i.mouseY = -1);
              }),
              (this.onWindowResize = function () {
                (i.scrollbarWidth = i.getScrollbarWidth()),
                  i.hideNativeScrollbar();
              }),
              (this.hideScrollbars = function () {
                (i.axis.x.track.rect =
                  i.axis.x.track.el.getBoundingClientRect()),
                  (i.axis.y.track.rect =
                    i.axis.y.track.el.getBoundingClientRect()),
                  i.isWithinBounds(i.axis.y.track.rect) ||
                    (i.axis.y.scrollbar.el.classList.remove(
                      i.classNames.visible
                    ),
                    (i.axis.y.isVisible = !1)),
                  i.isWithinBounds(i.axis.x.track.rect) ||
                    (i.axis.x.scrollbar.el.classList.remove(
                      i.classNames.visible
                    ),
                    (i.axis.x.isVisible = !1));
              }),
              (this.onPointerEvent = function (t) {
                var e, n;
                (i.axis.x.track.rect =
                  i.axis.x.track.el.getBoundingClientRect()),
                  (i.axis.y.track.rect =
                    i.axis.y.track.el.getBoundingClientRect()),
                  (i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
                    (e = i.isWithinBounds(i.axis.x.track.rect)),
                  (i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
                    (n = i.isWithinBounds(i.axis.y.track.rect)),
                  (e || n) &&
                    (t.preventDefault(),
                    t.stopPropagation(),
                    "mousedown" === t.type &&
                      (e &&
                        ((i.axis.x.scrollbar.rect =
                          i.axis.x.scrollbar.el.getBoundingClientRect()),
                        i.isWithinBounds(i.axis.x.scrollbar.rect)
                          ? i.onDragStart(t, "x")
                          : i.onTrackClick(t, "x")),
                      n &&
                        ((i.axis.y.scrollbar.rect =
                          i.axis.y.scrollbar.el.getBoundingClientRect()),
                        i.isWithinBounds(i.axis.y.scrollbar.rect)
                          ? i.onDragStart(t, "y")
                          : i.onTrackClick(t, "y"))));
              }),
              (this.drag = function (e) {
                var n = i.axis[i.draggedAxis].track,
                  r = n.rect[i.axis[i.draggedAxis].sizeAttr],
                  s = i.axis[i.draggedAxis].scrollbar,
                  o = i.contentWrapperEl[i.axis[i.draggedAxis].scrollSizeAttr],
                  a = parseInt(i.elStyles[i.axis[i.draggedAxis].sizeAttr], 10);
                e.preventDefault(), e.stopPropagation();
                var l =
                  ((("y" === i.draggedAxis ? e.pageY : e.pageX) -
                    n.rect[i.axis[i.draggedAxis].offsetAttr] -
                    i.axis[i.draggedAxis].dragOffset) /
                    (r - s.size)) *
                  (o - a);
                "x" === i.draggedAxis &&
                  ((l =
                    i.isRtl && t.getRtlHelpers().isRtlScrollbarInverted
                      ? l - (r + s.size)
                      : l),
                  (l =
                    i.isRtl && t.getRtlHelpers().isRtlScrollingInverted
                      ? -l
                      : l)),
                  (i.contentWrapperEl[i.axis[i.draggedAxis].scrollOffsetAttr] =
                    l);
              }),
              (this.onEndDrag = function (t) {
                var e = oR(i.el),
                  n = sR(i.el);
                t.preventDefault(),
                  t.stopPropagation(),
                  i.el.classList.remove(i.classNames.dragging),
                  e.removeEventListener("mousemove", i.drag, !0),
                  e.removeEventListener("mouseup", i.onEndDrag, !0),
                  (i.removePreventClickId = n.setTimeout(function () {
                    e.removeEventListener("click", i.preventClick, !0),
                      e.removeEventListener("dblclick", i.preventClick, !0),
                      (i.removePreventClickId = null);
                  }));
              }),
              (this.preventClick = function (t) {
                t.preventDefault(), t.stopPropagation();
              }),
              (this.el = e),
              (this.minScrollbarWidth = 20),
              (this.options = Object.assign({}, t.defaultOptions, {}, n)),
              (this.classNames = Object.assign(
                {},
                t.defaultOptions.classNames,
                {},
                this.options.classNames
              )),
              (this.axis = {
                x: {
                  scrollOffsetAttr: "scrollLeft",
                  sizeAttr: "width",
                  scrollSizeAttr: "scrollWidth",
                  offsetSizeAttr: "offsetWidth",
                  offsetAttr: "left",
                  overflowAttr: "overflowX",
                  dragOffset: 0,
                  isOverflowing: !0,
                  isVisible: !1,
                  forceVisible: !1,
                  track: {},
                  scrollbar: {},
                },
                y: {
                  scrollOffsetAttr: "scrollTop",
                  sizeAttr: "height",
                  scrollSizeAttr: "scrollHeight",
                  offsetSizeAttr: "offsetHeight",
                  offsetAttr: "top",
                  overflowAttr: "overflowY",
                  dragOffset: 0,
                  isOverflowing: !0,
                  isVisible: !1,
                  forceVisible: !1,
                  track: {},
                  scrollbar: {},
                },
              }),
              (this.removePreventClickId = null),
              t.instances.has(this.el) ||
                ((this.recalculate = pA()(this.recalculate.bind(this), 64)),
                (this.onMouseMove = pA()(this.onMouseMove.bind(this), 64)),
                (this.hideScrollbars = mA()(
                  this.hideScrollbars.bind(this),
                  this.options.timeout
                )),
                (this.onWindowResize = mA()(
                  this.onWindowResize.bind(this),
                  64,
                  {
                    leading: !0,
                  }
                )),
                (t.getRtlHelpers = vA()(t.getRtlHelpers)),
                this.init());
          }
          (t.getRtlHelpers = function () {
            var e = document.createElement("div");
            e.innerHTML =
              '<div class="hs-dummy-scrollbar-size"><div style="height: 200%; width: 200%; margin: 10px 0;"></div></div>';
            var n = e.firstElementChild;
            document.body.appendChild(n);
            var i = n.firstElementChild;
            n.scrollLeft = 0;
            var r = t.getOffset(n),
              s = t.getOffset(i);
            n.scrollLeft = 999;
            var o = t.getOffset(i);
            return {
              isRtlScrollingInverted: r.left !== s.left && s.left - o.left != 0,
              isRtlScrollbarInverted: r.left !== s.left,
            };
          }),
            (t.getOffset = function (t) {
              var e = t.getBoundingClientRect(),
                n = oR(t),
                i = sR(t);
              return {
                top: e.top + (i.pageYOffset || n.documentElement.scrollTop),
                left: e.left + (i.pageXOffset || n.documentElement.scrollLeft),
              };
            });
          var e = t.prototype;
          return (
            (e.init = function () {
              t.instances.set(this.el, this),
                hA() &&
                  (this.initDOM(),
                  this.setAccessibilityAttributes(),
                  (this.scrollbarWidth = this.getScrollbarWidth()),
                  this.recalculate(),
                  this.initListeners());
            }),
            (e.initDOM = function () {
              var t = this;
              if (
                Array.prototype.filter.call(this.el.children, function (e) {
                  return e.classList.contains(t.classNames.wrapper);
                }).length
              )
                (this.wrapperEl = this.el.querySelector(
                  "." + this.classNames.wrapper
                )),
                  (this.contentWrapperEl =
                    this.options.scrollableNode ||
                    this.el.querySelector(
                      "." + this.classNames.contentWrapper
                    )),
                  (this.contentEl =
                    this.options.contentNode ||
                    this.el.querySelector("." + this.classNames.contentEl)),
                  (this.offsetEl = this.el.querySelector(
                    "." + this.classNames.offset
                  )),
                  (this.maskEl = this.el.querySelector(
                    "." + this.classNames.mask
                  )),
                  (this.placeholderEl = this.findChild(
                    this.wrapperEl,
                    "." + this.classNames.placeholder
                  )),
                  (this.heightAutoObserverWrapperEl = this.el.querySelector(
                    "." + this.classNames.heightAutoObserverWrapperEl
                  )),
                  (this.heightAutoObserverEl = this.el.querySelector(
                    "." + this.classNames.heightAutoObserverEl
                  )),
                  (this.axis.x.track.el = this.findChild(
                    this.el,
                    "." +
                      this.classNames.track +
                      "." +
                      this.classNames.horizontal
                  )),
                  (this.axis.y.track.el = this.findChild(
                    this.el,
                    "." + this.classNames.track + "." + this.classNames.vertical
                  ));
              else {
                for (
                  this.wrapperEl = document.createElement("div"),
                    this.contentWrapperEl = document.createElement("div"),
                    this.offsetEl = document.createElement("div"),
                    this.maskEl = document.createElement("div"),
                    this.contentEl = document.createElement("div"),
                    this.placeholderEl = document.createElement("div"),
                    this.heightAutoObserverWrapperEl =
                      document.createElement("div"),
                    this.heightAutoObserverEl = document.createElement("div"),
                    this.wrapperEl.classList.add(this.classNames.wrapper),
                    this.contentWrapperEl.classList.add(
                      this.classNames.contentWrapper
                    ),
                    this.offsetEl.classList.add(this.classNames.offset),
                    this.maskEl.classList.add(this.classNames.mask),
                    this.contentEl.classList.add(this.classNames.contentEl),
                    this.placeholderEl.classList.add(
                      this.classNames.placeholder
                    ),
                    this.heightAutoObserverWrapperEl.classList.add(
                      this.classNames.heightAutoObserverWrapperEl
                    ),
                    this.heightAutoObserverEl.classList.add(
                      this.classNames.heightAutoObserverEl
                    );
                  this.el.firstChild;

                )
                  this.contentEl.appendChild(this.el.firstChild);
                this.contentWrapperEl.appendChild(this.contentEl),
                  this.offsetEl.appendChild(this.contentWrapperEl),
                  this.maskEl.appendChild(this.offsetEl),
                  this.heightAutoObserverWrapperEl.appendChild(
                    this.heightAutoObserverEl
                  ),
                  this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl),
                  this.wrapperEl.appendChild(this.maskEl),
                  this.wrapperEl.appendChild(this.placeholderEl),
                  this.el.appendChild(this.wrapperEl);
              }
              if (!this.axis.x.track.el || !this.axis.y.track.el) {
                var e = document.createElement("div"),
                  n = document.createElement("div");
                e.classList.add(this.classNames.track),
                  n.classList.add(this.classNames.scrollbar),
                  e.appendChild(n),
                  (this.axis.x.track.el = e.cloneNode(!0)),
                  this.axis.x.track.el.classList.add(
                    this.classNames.horizontal
                  ),
                  (this.axis.y.track.el = e.cloneNode(!0)),
                  this.axis.y.track.el.classList.add(this.classNames.vertical),
                  this.el.appendChild(this.axis.x.track.el),
                  this.el.appendChild(this.axis.y.track.el);
              }
              (this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector(
                "." + this.classNames.scrollbar
              )),
                (this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector(
                  "." + this.classNames.scrollbar
                )),
                this.options.autoHide ||
                  (this.axis.x.scrollbar.el.classList.add(
                    this.classNames.visible
                  ),
                  this.axis.y.scrollbar.el.classList.add(
                    this.classNames.visible
                  )),
                this.el.setAttribute("data-simplebar", "init");
            }),
            (e.setAccessibilityAttributes = function () {
              var t = this.options.ariaLabel || "scrollable content";
              this.contentWrapperEl.setAttribute("tabindex", "0"),
                this.contentWrapperEl.setAttribute("role", "region"),
                this.contentWrapperEl.setAttribute("aria-label", t);
            }),
            (e.initListeners = function () {
              var t = this,
                e = sR(this.el);
              this.options.autoHide &&
                this.el.addEventListener("mouseenter", this.onMouseEnter),
                ["mousedown", "click", "dblclick"].forEach(function (e) {
                  t.el.addEventListener(e, t.onPointerEvent, !0);
                }),
                ["touchstart", "touchend", "touchmove"].forEach(function (e) {
                  t.el.addEventListener(e, t.onPointerEvent, {
                    capture: !0,
                    passive: !0,
                  });
                }),
                this.el.addEventListener("mousemove", this.onMouseMove),
                this.el.addEventListener("mouseleave", this.onMouseLeave),
                this.contentWrapperEl.addEventListener("scroll", this.onScroll),
                e.addEventListener("resize", this.onWindowResize);
              var n = !1,
                i = e.ResizeObserver || iR;
              (this.resizeObserver = new i(function () {
                n && t.recalculate();
              })),
                this.resizeObserver.observe(this.el),
                this.resizeObserver.observe(this.contentEl),
                e.requestAnimationFrame(function () {
                  n = !0;
                }),
                (this.mutationObserver = new e.MutationObserver(
                  this.recalculate
                )),
                this.mutationObserver.observe(this.contentEl, {
                  childList: !0,
                  subtree: !0,
                  characterData: !0,
                });
            }),
            (e.recalculate = function () {
              var t = sR(this.el);
              (this.elStyles = t.getComputedStyle(this.el)),
                (this.isRtl = "rtl" === this.elStyles.direction);
              var e = this.heightAutoObserverEl.offsetHeight <= 1,
                n = this.heightAutoObserverEl.offsetWidth <= 1,
                i = this.contentEl.offsetWidth,
                r = this.contentWrapperEl.offsetWidth,
                s = this.elStyles.overflowX,
                o = this.elStyles.overflowY;
              (this.contentEl.style.padding =
                this.elStyles.paddingTop +
                " " +
                this.elStyles.paddingRight +
                " " +
                this.elStyles.paddingBottom +
                " " +
                this.elStyles.paddingLeft),
                (this.wrapperEl.style.margin =
                  "-" +
                  this.elStyles.paddingTop +
                  " -" +
                  this.elStyles.paddingRight +
                  " -" +
                  this.elStyles.paddingBottom +
                  " -" +
                  this.elStyles.paddingLeft);
              var a = this.contentEl.scrollHeight,
                l = this.contentEl.scrollWidth;
              (this.contentWrapperEl.style.height = e ? "auto" : "100%"),
                (this.placeholderEl.style.width = n ? i + "px" : "auto"),
                (this.placeholderEl.style.height = a + "px");
              var c = this.contentWrapperEl.offsetHeight;
              (this.axis.x.isOverflowing = l > i),
                (this.axis.y.isOverflowing = a > c),
                (this.axis.x.isOverflowing =
                  "hidden" !== s && this.axis.x.isOverflowing),
                (this.axis.y.isOverflowing =
                  "hidden" !== o && this.axis.y.isOverflowing),
                (this.axis.x.forceVisible =
                  "x" === this.options.forceVisible ||
                  !0 === this.options.forceVisible),
                (this.axis.y.forceVisible =
                  "y" === this.options.forceVisible ||
                  !0 === this.options.forceVisible),
                this.hideNativeScrollbar();
              var u = this.axis.x.isOverflowing ? this.scrollbarWidth : 0,
                h = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
              (this.axis.x.isOverflowing =
                this.axis.x.isOverflowing && l > r - h),
                (this.axis.y.isOverflowing =
                  this.axis.y.isOverflowing && a > c - u),
                (this.axis.x.scrollbar.size = this.getScrollbarSize("x")),
                (this.axis.y.scrollbar.size = this.getScrollbarSize("y")),
                (this.axis.x.scrollbar.el.style.width =
                  this.axis.x.scrollbar.size + "px"),
                (this.axis.y.scrollbar.el.style.height =
                  this.axis.y.scrollbar.size + "px"),
                this.positionScrollbar("x"),
                this.positionScrollbar("y"),
                this.toggleTrackVisibility("x"),
                this.toggleTrackVisibility("y");
            }),
            (e.getScrollbarSize = function (t) {
              if ((void 0 === t && (t = "y"), !this.axis[t].isOverflowing))
                return 0;
              var e,
                n = this.contentEl[this.axis[t].scrollSizeAttr],
                i = this.axis[t].track.el[this.axis[t].offsetSizeAttr],
                r = i / n;
              return (
                (e = Math.max(~~(r * i), this.options.scrollbarMinSize)),
                this.options.scrollbarMaxSize &&
                  (e = Math.min(e, this.options.scrollbarMaxSize)),
                e
              );
            }),
            (e.positionScrollbar = function (e) {
              if ((void 0 === e && (e = "y"), this.axis[e].isOverflowing)) {
                var n = this.contentWrapperEl[this.axis[e].scrollSizeAttr],
                  i = this.axis[e].track.el[this.axis[e].offsetSizeAttr],
                  r = parseInt(this.elStyles[this.axis[e].sizeAttr], 10),
                  s = this.axis[e].scrollbar,
                  o = this.contentWrapperEl[this.axis[e].scrollOffsetAttr],
                  a =
                    (o =
                      "x" === e &&
                      this.isRtl &&
                      t.getRtlHelpers().isRtlScrollingInverted
                        ? -o
                        : o) /
                    (n - r),
                  l = ~~((i - s.size) * a);
                (l =
                  "x" === e &&
                  this.isRtl &&
                  t.getRtlHelpers().isRtlScrollbarInverted
                    ? l + (i - s.size)
                    : l),
                  (s.el.style.transform =
                    "x" === e
                      ? "translate3d(" + l + "px, 0, 0)"
                      : "translate3d(0, " + l + "px, 0)");
              }
            }),
            (e.toggleTrackVisibility = function (t) {
              void 0 === t && (t = "y");
              var e = this.axis[t].track.el,
                n = this.axis[t].scrollbar.el;
              this.axis[t].isOverflowing || this.axis[t].forceVisible
                ? ((e.style.visibility = "visible"),
                  (this.contentWrapperEl.style[this.axis[t].overflowAttr] =
                    "scroll"))
                : ((e.style.visibility = "hidden"),
                  (this.contentWrapperEl.style[this.axis[t].overflowAttr] =
                    "hidden")),
                this.axis[t].isOverflowing
                  ? (n.style.display = "block")
                  : (n.style.display = "none");
            }),
            (e.hideNativeScrollbar = function () {
              (this.offsetEl.style[this.isRtl ? "left" : "right"] =
                this.axis.y.isOverflowing || this.axis.y.forceVisible
                  ? "-" + this.scrollbarWidth + "px"
                  : 0),
                (this.offsetEl.style.bottom =
                  this.axis.x.isOverflowing || this.axis.x.forceVisible
                    ? "-" + this.scrollbarWidth + "px"
                    : 0);
            }),
            (e.onMouseMoveForAxis = function (t) {
              void 0 === t && (t = "y"),
                (this.axis[t].track.rect =
                  this.axis[t].track.el.getBoundingClientRect()),
                (this.axis[t].scrollbar.rect =
                  this.axis[t].scrollbar.el.getBoundingClientRect()),
                this.isWithinBounds(this.axis[t].scrollbar.rect)
                  ? this.axis[t].scrollbar.el.classList.add(
                      this.classNames.hover
                    )
                  : this.axis[t].scrollbar.el.classList.remove(
                      this.classNames.hover
                    ),
                this.isWithinBounds(this.axis[t].track.rect)
                  ? (this.showScrollbar(t),
                    this.axis[t].track.el.classList.add(this.classNames.hover))
                  : this.axis[t].track.el.classList.remove(
                      this.classNames.hover
                    );
            }),
            (e.onMouseLeaveForAxis = function (t) {
              void 0 === t && (t = "y"),
                this.axis[t].track.el.classList.remove(this.classNames.hover),
                this.axis[t].scrollbar.el.classList.remove(
                  this.classNames.hover
                );
            }),
            (e.showScrollbar = function (t) {
              void 0 === t && (t = "y");
              var e = this.axis[t].scrollbar.el;
              this.axis[t].isVisible ||
                (e.classList.add(this.classNames.visible),
                (this.axis[t].isVisible = !0)),
                this.options.autoHide && this.hideScrollbars();
            }),
            (e.onDragStart = function (t, e) {
              void 0 === e && (e = "y");
              var n = oR(this.el),
                i = sR(this.el),
                r = this.axis[e].scrollbar,
                s = "y" === e ? t.pageY : t.pageX;
              (this.axis[e].dragOffset = s - r.rect[this.axis[e].offsetAttr]),
                (this.draggedAxis = e),
                this.el.classList.add(this.classNames.dragging),
                n.addEventListener("mousemove", this.drag, !0),
                n.addEventListener("mouseup", this.onEndDrag, !0),
                null === this.removePreventClickId
                  ? (n.addEventListener("click", this.preventClick, !0),
                    n.addEventListener("dblclick", this.preventClick, !0))
                  : (i.clearTimeout(this.removePreventClickId),
                    (this.removePreventClickId = null));
            }),
            (e.onTrackClick = function (t, e) {
              var n = this;
              if ((void 0 === e && (e = "y"), this.options.clickOnTrack)) {
                var i = sR(this.el);
                this.axis[e].scrollbar.rect =
                  this.axis[e].scrollbar.el.getBoundingClientRect();
                var r = this.axis[e].scrollbar.rect[this.axis[e].offsetAttr],
                  s = parseInt(this.elStyles[this.axis[e].sizeAttr], 10),
                  o = this.contentWrapperEl[this.axis[e].scrollOffsetAttr],
                  a =
                    ("y" === e ? this.mouseY - r : this.mouseX - r) < 0
                      ? -1
                      : 1,
                  l = -1 === a ? o - s : o + s;
                !(function t() {
                  var r, s;
                  -1 === a
                    ? o > l &&
                      ((o -= n.options.clickOnTrackSpeed),
                      n.contentWrapperEl.scrollTo(
                        (((r = {})[n.axis[e].offsetAttr] = o), r)
                      ),
                      i.requestAnimationFrame(t))
                    : o < l &&
                      ((o += n.options.clickOnTrackSpeed),
                      n.contentWrapperEl.scrollTo(
                        (((s = {})[n.axis[e].offsetAttr] = o), s)
                      ),
                      i.requestAnimationFrame(t));
                })();
              }
            }),
            (e.getContentElement = function () {
              return this.contentEl;
            }),
            (e.getScrollElement = function () {
              return this.contentWrapperEl;
            }),
            (e.getScrollbarWidth = function () {
              try {
                return "none" ===
                  getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar")
                    .display ||
                  "scrollbarWidth" in document.documentElement.style ||
                  "-ms-overflow-style" in document.documentElement.style
                  ? 0
                  : cR(this.el);
              } catch (t) {
                return cR(this.el);
              }
            }),
            (e.removeListeners = function () {
              var t = this,
                e = sR(this.el);
              this.options.autoHide &&
                this.el.removeEventListener("mouseenter", this.onMouseEnter),
                ["mousedown", "click", "dblclick"].forEach(function (e) {
                  t.el.removeEventListener(e, t.onPointerEvent, !0);
                }),
                ["touchstart", "touchend", "touchmove"].forEach(function (e) {
                  t.el.removeEventListener(e, t.onPointerEvent, {
                    capture: !0,
                    passive: !0,
                  });
                }),
                this.el.removeEventListener("mousemove", this.onMouseMove),
                this.el.removeEventListener("mouseleave", this.onMouseLeave),
                this.contentWrapperEl &&
                  this.contentWrapperEl.removeEventListener(
                    "scroll",
                    this.onScroll
                  ),
                e.removeEventListener("resize", this.onWindowResize),
                this.mutationObserver && this.mutationObserver.disconnect(),
                this.resizeObserver && this.resizeObserver.disconnect(),
                this.recalculate.cancel(),
                this.onMouseMove.cancel(),
                this.hideScrollbars.cancel(),
                this.onWindowResize.cancel();
            }),
            (e.unMount = function () {
              this.removeListeners(), t.instances.delete(this.el);
            }),
            (e.isWithinBounds = function (t) {
              return (
                this.mouseX >= t.left &&
                this.mouseX <= t.left + t.width &&
                this.mouseY >= t.top &&
                this.mouseY <= t.top + t.height
              );
            }),
            (e.findChild = function (t, e) {
              var n =
                t.matches ||
                t.webkitMatchesSelector ||
                t.mozMatchesSelector ||
                t.msMatchesSelector;
              return Array.prototype.filter.call(t.children, function (t) {
                return n.call(t, e);
              })[0];
            }),
            t
          );
        })();
        (uR.defaultOptions = {
          autoHide: !0,
          forceVisible: !1,
          clickOnTrack: !0,
          clickOnTrackSpeed: 40,
          classNames: {
            contentEl: "simplebar-content",
            contentWrapper: "simplebar-content-wrapper",
            offset: "simplebar-offset",
            mask: "simplebar-mask",
            wrapper: "simplebar-wrapper",
            placeholder: "simplebar-placeholder",
            scrollbar: "simplebar-scrollbar",
            track: "simplebar-track",
            heightAutoObserverWrapperEl:
              "simplebar-height-auto-observer-wrapper",
            heightAutoObserverEl: "simplebar-height-auto-observer",
            visible: "simplebar-visible",
            horizontal: "simplebar-horizontal",
            vertical: "simplebar-vertical",
            hover: "simplebar-hover",
            dragging: "simplebar-dragging",
          },
          scrollbarMinSize: 25,
          scrollbarMaxSize: 0,
          timeout: 1e3,
        }),
          (uR.instances = new WeakMap()),
          (uR.initDOMLoadedElements = function () {
            document.removeEventListener(
              "DOMContentLoaded",
              this.initDOMLoadedElements
            ),
              window.removeEventListener("load", this.initDOMLoadedElements),
              Array.prototype.forEach.call(
                document.querySelectorAll("[data-simplebar]"),
                function (t) {
                  "init" === t.getAttribute("data-simplebar") ||
                    uR.instances.has(t) ||
                    new uR(t, rR(t.attributes));
                }
              );
          }),
          (uR.removeObserver = function () {
            this.globalObserver.disconnect();
          }),
          (uR.initHtmlApi = function () {
            (this.initDOMLoadedElements =
              this.initDOMLoadedElements.bind(this)),
              "undefined" != typeof MutationObserver &&
                ((this.globalObserver = new MutationObserver(
                  uR.handleMutations
                )),
                this.globalObserver.observe(document, {
                  childList: !0,
                  subtree: !0,
                })),
              "complete" === document.readyState ||
              ("loading" !== document.readyState &&
                !document.documentElement.doScroll)
                ? window.setTimeout(this.initDOMLoadedElements)
                : (document.addEventListener(
                    "DOMContentLoaded",
                    this.initDOMLoadedElements
                  ),
                  window.addEventListener("load", this.initDOMLoadedElements));
          }),
          (uR.handleMutations = function (t) {
            t.forEach(function (t) {
              Array.prototype.forEach.call(t.addedNodes, function (t) {
                1 === t.nodeType &&
                  (t.hasAttribute("data-simplebar")
                    ? !uR.instances.has(t) &&
                      document.documentElement.contains(t) &&
                      new uR(t, rR(t.attributes))
                    : Array.prototype.forEach.call(
                        t.querySelectorAll("[data-simplebar]"),
                        function (t) {
                          "init" !== t.getAttribute("data-simplebar") &&
                            !uR.instances.has(t) &&
                            document.documentElement.contains(t) &&
                            new uR(t, rR(t.attributes));
                        }
                      ));
              }),
                Array.prototype.forEach.call(t.removedNodes, function (t) {
                  1 === t.nodeType &&
                    ("init" === t.getAttribute("data-simplebar")
                      ? uR.instances.has(t) &&
                        !document.documentElement.contains(t) &&
                        uR.instances.get(t).unMount()
                      : Array.prototype.forEach.call(
                          t.querySelectorAll('[data-simplebar="init"]'),
                          function (t) {
                            uR.instances.has(t) &&
                              !document.documentElement.contains(t) &&
                              uR.instances.get(t).unMount();
                          }
                        ));
                });
            });
          }),
          (uR.getOptions = rR),
          hA() && uR.initHtmlApi();
        const hR = uR;
        class dR {
          static hex2rgb(t) {
            return (
              "#" === t.slice(0, 1) && (t = t.slice(1)),
              3 === t.length &&
                (t =
                  t.slice(0, 1) +
                  t.slice(0, 1) +
                  t.slice(1, 2) +
                  t.slice(1, 2) +
                  t.slice(2, 3) +
                  t.slice(2, 3)),
              [t.slice(0, 2), t.slice(2, 4), t.slice(4, 6)].map(function (t) {
                return parseInt(t, 16);
              })
            );
          }
          static rgbToGLSLColor(t) {
            const [e, n, i] = t;
            return [e / 255, n / 255, i / 255];
          }
          static hexToGlslColor(t, e = 1) {
            return this.rgbToGLSLColor(this.hex2rgb(t)).concat([e]);
          }
          static glslColorToHex(t) {
            const e = Math.round(255 * t[0]),
              n = Math.round(255 * t[1]),
              i = Math.round(255 * t[2]);
            return `#${e.toString(16).padStart(2, "0")}${n
              .toString(16)
              .padStart(2, "0")}${i.toString(16).padStart(2, "0")}`;
          }
        }
        class pR {
          constructor(t, e, n, i) {
            if (
              ((this.body = t),
              (this.stage = e),
              (this.objects = n),
              (this.pp = i),
              (this.isAbleToScreenshot = !1),
              (this.configMenuBtn = document.getElementById("jsConfigBtn")),
              (this.containerElement = document.getElementById("jsConfigMenu")),
              (this.closeBtns = [
                ...document.querySelectorAll(".jsConfigCloseBtn"),
              ]),
              (this.isAbleToOpen = !0),
              (this.isOpend = !1),
              this.configMenuBtn &&
                this.configMenuBtn.addEventListener("click", async (t) => {
                  if (this.isAbleToOpen) {
                    if (
                      ((this.isAbleToOpen = !1),
                      (this.isOpend = !this.isOpend),
                      this.body.setAttribute(
                        "data-config",
                        this.isOpend ? "1" : "0"
                      ),
                      this.isOpend)
                    ) {
                      this.containerElement
                        .querySelector(".simplebar-content-wrapper")
                        .scrollTo(0, 0);
                    }
                    setTimeout(() => {
                      this.isAbleToOpen = !0;
                    }, 300);
                  }
                }),
              this.closeBtns.length > 0)
            )
              for (let t = 0; t < this.closeBtns.length; t++) {
                this.closeBtns[t].addEventListener("click", (t) => {
                  this.isAbleToOpen &&
                    ((this.isAbleToOpen = !1),
                    (this.isOpend = !1),
                    this.body.setAttribute("data-config", "0"),
                    setTimeout(() => {
                      this.isAbleToOpen = !0;
                    }, 300));
                });
              }
            !(function () {
              const t = [...document.querySelectorAll(".jsSimplebar")];
              if (t.length > 0) for (let e = 0; e < t.length; e++) new hR(t[e]);
            })();
          }
          setInputColor(t, e, n, i = !0) {
            const r = dR.glslColorToHex([e.r, e.g, e.b]),
              s = this.containerElement.querySelector(`#${t}`);
            s.value = r;
            const o = (t) => {
              const e = i
                ? new lm(t.target.value).convertLinearToSRGB()
                : new lm(t.target.value);
              if (n.length > 0)
                for (let t = 0; t < n.length; t++) {
                  const i = n[t];
                  (i.r = e.r), (i.g = e.g), (i.b = e.b);
                }
              else (n.r = e.r), (n.g = e.g), (n.b = e.b);
            };
            s.addEventListener("change", o), s.addEventListener("input", o);
          }
          setInputRange(t, e, n, i) {
            const r = this.containerElement.querySelector(`#${t}`);
            r.value = e;
            const s = (t) => {
              const e = Number(t.target.value);
              if (n.length > 0) for (let t = 0; t < n.length; t++) n[t][i] = e;
              else n[i] = e;
            };
            r.addEventListener("change", s), r.addEventListener("input", s);
          }
          getCurrentDateTime() {
            const t = new Date();
            return `${t.getFullYear()}${String(t.getMonth() + 1).padStart(
              2,
              "0"
            )}${String(t.getDate()).padStart(2, "0")}${String(
              t.getHours()
            ).padStart(2, "0")}${String(t.getMinutes()).padStart(
              2,
              "0"
            )}${String(t.getSeconds()).padStart(2, "0")}`;
          }
          init() {
            let t = null;
            if (this.containerElement) {
              this.setInputColor(
                "background",
                Kx.bgColor,
                this.pp.CONFIG.BACKGROUND
              ),
                this.setInputColor(
                  "sphereColor1",
                  this.objects.config.colors[0],
                  this.objects.sphereMeshs[0].material.uniforms.uColor.value
                ),
                this.setInputColor(
                  "sphereColor2",
                  this.objects.config.colors[1],
                  this.objects.sphereMeshs[1].material.uniforms.uColor.value
                ),
                this.setInputColor(
                  "sphereColor3",
                  this.objects.config.colors[2],
                  this.objects.sphereMeshs[2].material.uniforms.uColor.value
                ),
                this.setInputColor(
                  "sphereColor4",
                  this.objects.config.colors[3],
                  this.objects.sphereMeshs[3].material.uniforms.uColor.value
                ),
                this.setInputColor(
                  "sphereColor5",
                  this.objects.config.colors[4],
                  this.objects.sphereMeshs[4].material.uniforms.uColor.value
                ),
                this.setInputColor(
                  "sphereColor6",
                  this.objects.config.colors[5],
                  this.objects.sphereMeshs[5].material.uniforms.uColor.value
                ),
                (t = []);
              for (let e = 0; e < this.objects.sphereMeshs.length; e++)
                t.push(
                  this.objects.sphereMeshs[e].material.uniforms.uSunColor.value
                );
              this.setInputColor("sunColor", this.objects.config.sunColor, t),
                (t = []);
              for (let e = 0; e < this.objects.sphereMeshs.length; e++)
                t.push(
                  this.objects.sphereMeshs[e].material.uniforms.uSunStrength
                );
              this.setInputRange(
                "sunStrength",
                this.objects.config.uSunStrength,
                t,
                "value"
              ),
                (t = []);
              for (let e = 0; e < this.objects.sphereMeshs.length; e++)
                t.push(
                  this.objects.sphereMeshs[e].material.uniforms
                    .uDiffuseThreshold
                );
              this.setInputRange(
                "lighting",
                this.objects.config.uDiffuseThreshold,
                t,
                "value"
              ),
                (t = []);
              for (let e = 0; e < this.objects.sphereBodys.length; e++)
                t.push(this.objects.sphereBodys[e]);
              this.setInputRange(
                "angularDamping",
                this.objects.config.angularDamping,
                t,
                "angularDamping"
              ),
                this.setInputRange(
                  "linearDamping",
                  this.objects.config.linearDamping,
                  t,
                  "linearDamping"
                ),
                this.setInputRange(
                  "returnForce",
                  this.objects.config.backToRelativeScaler,
                  this.objects.config,
                  "backToRelativeScaler"
                ),
                this.setInputRange(
                  "moveRange",
                  this.objects.config.moveScaler,
                  this.objects.config,
                  "moveScaler"
                ),
                (this.downloadElement = document.createElement("a")),
                (this.downloadElement.download = `cellinteractive-${this.getCurrentDateTime()}.png`);
              const e = document.getElementById("jsImgDownloadBtn");
              if (e) {
                let t = !0;
                e.addEventListener("click", (e) => {
                  t &&
                    ((t = !1),
                    this.isAbleToScreenshot || (this.isAbleToScreenshot = !0),
                    setTimeout(() => {
                      t = !0;
                    }, 300));
                });
              }
            }
          }
          update() {
            if (!this.isAbleToScreenshot) return;
            this.isAbleToScreenshot = !1;
            const t = this.stage.renderer.domElement.toDataURL("image/png", 1);
            (this.downloadElement.href = t), this.downloadElement.click();
          }
        }
        class fR extends Zx {
          constructor() {
            super(),
              (this.isInitialized = !1),
              (this.stage = new YM(
                this.isMatchMediaWidth,
                this.isMatchMediaHover
              )),
              (this.objects = new QT(
                this.stage,
                this.isMatchMediaWidth,
                this.isMatchMediaHover
              )),
              (this.pp = null),
              (this.pp = new lA(this.stage, this.objects)),
              (this.gui = null),
              (this.gui = new pR(this.body, this.stage, this.objects, this.pp));
            let t = !0;
            const e = document.getElementById("jsToggleBtn");
            e &&
              e.addEventListener("click", (n) => {
                t
                  ? ((e.innerText = "▶️"), this.pause(), (t = !1))
                  : ((e.innerText = "⏸"), this.play(), (t = !0));
              });
          }
          delay(t) {
            return new Promise((e) => {
              setTimeout(() => {
                e();
              }, t);
            });
          }
          play() {
            super.play();
          }
          pause() {
            super.pause();
          }
          resize() {
            this.isInitialized &&
              (super.resize(),
              this.isAbleToResize &&
                (this.stage.resize(
                  this.isMatchMediaWidth,
                  this.isMatchMediaHover
                ),
                this.objects.resize(
                  this.isMatchMediaWidth,
                  this.isMatchMediaHover
                ),
                null != this.pp && this.pp.resize()));
          }
          update() {
            this.isInitialized &&
              this.isPlaying &&
              (super.update(),
              this.stage.update(),
              this.objects.update(this.time),
              this.pp.update(this.time));
          }
          load() {
            return new Promise(async (t) => {
              super.pause(),
                null != this.pp && (await this.pp.init()),
                await this.objects.init(),
                this.gui.init(),
                t();
            });
          }
          init() {
            return new Promise(async (t) => {
              await this.delay(300),
                (this.isInitialized = !0),
                super.play(),
                this.body.setAttribute("data-loaded", "1"),
                this.resize(),
                t();
            });
          }
        }
        Yi.registerPlugin(th);
        class mR {
          constructor(t) {
            (this.tgt = t), (this.video = t.querySelector("video"));
          }
          init() {
            return this.bind();
          }
          bind() {
            const t = this;
            t.scaleAction(), t.scrollObserver(t.video);
          }
          scaleAction() {
            const t = this;
            th.create({
              trigger: t.tgt,
              start: "top-=4% top",
              end: "bottom top",
              pin: !0,
              scrub: 1,
              markers: !1,
              pinSpacing: !1,
            }),
              Yi.fromTo(
                t.tgt,
                {
                  scaleX: 0.85,
                  scaleY: 0.85,
                },
                {
                  scaleX: 1,
                  scaleY: 1,
                  duration: 10,
                  scrollTrigger: {
                    trigger: t.tgt,
                    start: "top-=50% top",
                    end: "top top",
                    scrub: 1,
                    toggleActions: "play none none reverse",
                    markers: !1,
                  },
                }
              );
          }
          scrollObserver(t) {
            const e = this;
            (this.observer = new IntersectionObserver(
              function (n) {
                n.forEach(function (n) {
                  n.target === e.tgt &&
                    (n.isIntersecting ? t.play() : t.pause());
                });
              },
              {
                root: null,
                rootMargin: "0px",
                threshold: 0,
              }
            )),
              this.observer.observe(e.tgt);
          }
        }
        class gR {
          constructor(t, e, n) {
            (this.area = t),
              (this.stalker = e),
              (this.posX = 0),
              (this.posY = 0);
          }
          init() {
            return this.bind();
          }
          bind() {
            const t = this;
            t.area.addEventListener("mousemove", t.mousePosition.bind(this)),
              t.area.addEventListener("mouseover", t.mouseover.bind(this)),
              t.area.addEventListener("mouseleave", t.mouseleave.bind(this));
          }
          mouseover() {}
          mouseleave() {
            this.stalker.style.opacity = "0";
          }
          mousePosition(t) {
            const e = this;
            (e.posX = t.clientX),
              (e.posY = t.clientY),
              (e.stalker.style.opacity = "1"),
              Yi.to(e.stalker, {
                x: e.posX,
                y: e.posY,
              });
          }
        }
        class vR {
          constructor(t, e) {
            (this.area = t),
              (this.stalker = e),
              (this.posX = 0),
              (this.posY = 0);
          }
          init() {
            return this.bind();
          }
          bind() {
            const t = this;
            t.area.addEventListener("mousemove", t.mousePosition.bind(this)),
              t.area.addEventListener("mouseover", t.mouseover.bind(this)),
              t.area.addEventListener("mouseleave", t.mouseleave.bind(this));
          }
          mouseover() {
            const t = this;
            t.stalker.classList.add("-mouseover"),
              t.changeCursorSize(),
              t.carouselHover();
          }
          mouseleave() {
            this.stalker.classList.remove("-mouseover"),
              this.changeCursorSize();
          }
          changeCursorSize() {
            const t = this;
            t.area.classList.contains("cursor-stalker--min")
              ? (t.stalker.classList.remove("--large"),
                t.stalker.classList.add("--min"))
              : (t.stalker.classList.remove("--min"),
                t.stalker.classList.add("--large"));
          }
          carouselHover() {
            const t = this;
            document.querySelector(".carousel-item[data-js-carousel-hover]") &&
              t.area.classList.contains("cursor-hover") &&
              (document
                .querySelector(".carousel-item[data-js-carousel-hover].is-show")
                .classList.remove("is-show"),
              (this.dataNum = t.area.getAttribute("data-js-carousel-hover")),
              document
                .querySelector(
                  ".carousel-item[data-js-carousel-hover='" +
                    this.dataNum +
                    "']"
                )
                .classList.add("is-show"));
          }
          mousePosition(t) {
            const e = this;
            (e.posX = t.clientX),
              (e.posY = t.clientY),
              Yi.to(e.stalker, {
                x: e.posX,
                y: e.posY,
              });
          }
        }
        class yR {
          constructor(t) {
            (this.tgt = t),
              (this.body = document.querySelector("body")),
              (this.movieModalArea =
                document.querySelector(".movie-modal-area")),
              (this.cenceptMovieArea = document.querySelector(
                ".cencept-movie-area"
              )),
              (this.spVideo = document.querySelector(".sp-video")),
              (this.pcVideo = document.querySelector(".pc-video")),
              (this.closeBtn = document.querySelector(
                ".movie-modal-area .menu-button"
              )),
              this.timer,
              (this.positionPrev = 0),
              (this.buffer = 100),
              (this.scroll_buffer = 300),
              (this.timeout_start = 500),
              (this.timeout_end = 800),
              (this.videos = [
                {
                  flg: "PC",
                  src: "https://cellinteractive.jp/_int/wp-content/themes/pj-wp_cellinteractive/dist/video/top/PC_short.mp4",
                },
                {
                  flg: "SP",
                  src: "https://cellinteractive.jp/_int/wp-content/themes/pj-wp_cellinteractive/dist/video/top/SP_short.mp4",
                },
              ]);
          }
          init() {
            return this.bind();
          }
          bind() {
            const t = this;
            t.videos.forEach((e) => {
              t.EmbeddingVideoElements(e.flg, e.src);
            }),
              t.toggleClass(),
              setTimeout(() => {
                t.ytPlayerControl();
              }, 500);
          }
          toggleClass() {
            const t = this;
            t.tgt.addEventListener("click", () => {
              t.tgt.classList.add("is-open"),
                t.tgt.classList.add("is-disabled"),
                t.body.classList.add("is-disabled"),
                (t.movieModalArea.style.display = "block"),
                setTimeout(() => {
                  (t.movieModalArea.style.opacity = "1"),
                    t.movieModalArea.classList.add("is-show");
                }, t.timeout_start),
                setTimeout(() => {
                  t.tgt.classList.remove("is-disabled");
                }, t.timeout_end);
            }),
              t.closeBtn.addEventListener("click", () => {
                t.tgt.classList.remove("is-open"),
                  t.tgt.classList.remove("is-disabled"),
                  t.body.classList.remove("is-disabled"),
                  t.movieModalArea.classList.remove("is-show"),
                  setTimeout(() => {
                    (t.movieModalArea.style.opacity = ""),
                      (t.movieModalArea.style.display = "");
                  }, t.timeout_end);
              });
          }
          ytPlayerControl() {
            const t = this;
            (this.tag = document.createElement("script")),
              (this.tag.src = "https://www.youtube.com/iframe_api"),
              (this.firstScriptTag =
                document.getElementsByTagName("script")[0]),
              this.firstScriptTag.parentNode.insertBefore(
                this.tag,
                this.firstScriptTag
              ),
              t.player,
              t.tgt.addEventListener("click", () => {
                t.player.playVideo();
              }),
              t.closeBtn.addEventListener("click", () => {
                t.player.stopVideo();
              }),
              setTimeout(() => {
                t.player = new YT.Player("player", {
                  videoId: "kQs0qhGAUww",
                });
              }, 500);
          }
          EmbeddingVideoElements(t, e) {
            const n = this;
            "PC" === t
              ? n.pcVideo.setAttribute("src", e)
              : n.spVideo.setAttribute("src", e);
          }
          lowPowerMode() {
            const t = this;
            (this.isLowPowerMode = !1),
              (this.detectVideo = document.getElementById("detect-video")),
              (this.video_promise = this.detectVideo.play()),
              this.video_promise.catch(function (e) {
                (this.isLowPowerMode = !0),
                  t.cenceptMovieArea.classList.add("--low-pow-mode"),
                  this.detectVideo.removeAttribute("autoplay");
              });
          }
        }
        Yi.registerPlugin(th);
        class _R {
          constructor(t, e) {
            (this.sec1 = t),
              (this.sec2 = e),
              (this.sec1_video = t.querySelector("video")),
              (this.sec2_video = e.querySelector("video")),
              this.startParam,
              this.endParam;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.scrollAction();
          }
          scrollAction() {
            const t = this;
            t.sec1_video.play(),
              t.sec2_video.play(),
              window.matchMedia("(min-width: 769px)").matches &&
                (th.create({
                  trigger: t.sec1,
                  start: "top top",
                  end: "bottom top",
                  pin: !0,
                  scrub: 1,
                  markers: !1,
                  pinSpacing: !1,
                }),
                th.create({
                  trigger: t.sec2,
                  start: "top+=100% bottom",
                  end: "bottom+=100% bottom",
                  pin: !0,
                  scrub: 1,
                  markers: !1,
                  pinSpacing: !1,
                }));
          }
        }
        var xR,
          bR,
          wR = n(4595),
          ER = n.n(wR);
        class SR {
          constructor(t) {
            this.tgt = t;
          }
          init() {
            return this.bind();
          }
          bind() {
            this.carouselAction();
          }
          carouselAction() {
            new (ER())(this.tgt, {
              speed: 8,
              smartSpeed: !0,
              autoplay: !0,
            });
          }
        }
        class MR {
          constructor(t) {
            (this.tgt = t),
              (this.menu = document.querySelector(
                "[data-js-side-menu-trigger]"
              )),
              (this.linkNum = document.querySelectorAll(
                "[data-js-side-menu-trigger] .link-list-item"
              ).length),
              (this.options = {
                root: null,
                rootMargin: "-50% 0px",
                threshold: 0,
              }),
              (this.buffer = 1e3);
          }
          init() {
            return this.bind();
          }
          bind() {
            this.menuAction();
          }
          menuAction() {
            const t = this,
              e = new IntersectionObserver(function (e) {
                e.forEach((e) => {
                  e.isIntersecting && t.changeClass(e.target);
                });
              }, t.options);
            t.tgt.forEach((t) => {
              e.observe(t);
            });
          }
          changeClass(t) {
            (this.num = t.getAttribute("data-js-current-num")),
              this.num || (this.num = this.linkNum),
              document
                .querySelector(
                  "[data-js-side-menu-trigger] .link-list-item.is-current"
                )
                .classList.remove("is-current"),
              document
                .querySelector(
                  '[data-js-side-menu-trigger] [data-js-current-num="' +
                    this.num +
                    '"]'
                )
                .classList.add("is-current");
          }
        }
        function TR(t) {
          return "object" == typeof t && "function" == typeof t.to;
        }
        function AR(t) {
          t.parentElement.removeChild(t);
        }
        function RR(t) {
          return null != t;
        }
        function CR(t) {
          t.preventDefault();
        }
        function LR(t) {
          return "number" == typeof t && !isNaN(t) && isFinite(t);
        }
        function PR(t, e, n) {
          n > 0 &&
            (DR(t, e),
            setTimeout(function () {
              UR(t, e);
            }, n));
        }
        function OR(t) {
          return Math.max(Math.min(t, 100), 0);
        }
        function IR(t) {
          return Array.isArray(t) ? t : [t];
        }
        function NR(t) {
          var e = (t = String(t)).split(".");
          return e.length > 1 ? e[1].length : 0;
        }
        function DR(t, e) {
          t.classList && !/\s/.test(e)
            ? t.classList.add(e)
            : (t.className += " " + e);
        }
        function UR(t, e) {
          t.classList && !/\s/.test(e)
            ? t.classList.remove(e)
            : (t.className = t.className.replace(
                new RegExp(
                  "(^|\\b)" + e.split(" ").join("|") + "(\\b|$)",
                  "gi"
                ),
                " "
              ));
        }
        function FR(t) {
          var e = void 0 !== window.pageXOffset,
            n = "CSS1Compat" === (t.compatMode || "");
          return {
            x: e
              ? window.pageXOffset
              : n
              ? t.documentElement.scrollLeft
              : t.body.scrollLeft,
            y: e
              ? window.pageYOffset
              : n
              ? t.documentElement.scrollTop
              : t.body.scrollTop,
          };
        }
        function kR(t, e) {
          return 100 / (e - t);
        }
        function BR(t, e, n) {
          return (100 * e) / (t[n + 1] - t[n]);
        }
        function zR(t, e) {
          for (var n = 1; t >= e[n]; ) n += 1;
          return n;
        }
        function HR(t, e, n) {
          if (n >= t.slice(-1)[0]) return 100;
          var i = zR(n, t),
            r = t[i - 1],
            s = t[i],
            o = e[i - 1],
            a = e[i];
          return (
            o +
            (function (t, e) {
              return BR(t, t[0] < 0 ? e + Math.abs(t[0]) : e - t[0], 0);
            })([r, s], n) /
              kR(o, a)
          );
        }
        function VR(t, e, n, i) {
          if (100 === i) return i;
          var r = zR(i, t),
            s = t[r - 1],
            o = t[r];
          return n
            ? i - s > (o - s) / 2
              ? o
              : s
            : e[r - 1]
            ? t[r - 1] +
              (function (t, e) {
                return Math.round(t / e) * e;
              })(i - t[r - 1], e[r - 1])
            : i;
        }
        !(function (t) {
          (t.Range = "range"),
            (t.Steps = "steps"),
            (t.Positions = "positions"),
            (t.Count = "count"),
            (t.Values = "values");
        })(xR || (xR = {})),
          (function (t) {
            (t[(t.None = -1)] = "None"),
              (t[(t.NoValue = 0)] = "NoValue"),
              (t[(t.LargeValue = 1)] = "LargeValue"),
              (t[(t.SmallValue = 2)] = "SmallValue");
          })(bR || (bR = {}));
        var GR = (function () {
            function t(t, e, n) {
              var i;
              (this.xPct = []),
                (this.xVal = []),
                (this.xSteps = []),
                (this.xNumSteps = []),
                (this.xHighestCompleteStep = []),
                (this.xSteps = [n || !1]),
                (this.xNumSteps = [!1]),
                (this.snap = e);
              var r = [];
              for (
                Object.keys(t).forEach(function (e) {
                  r.push([IR(t[e]), e]);
                }),
                  r.sort(function (t, e) {
                    return t[0][0] - e[0][0];
                  }),
                  i = 0;
                i < r.length;
                i++
              )
                this.handleEntryPoint(r[i][1], r[i][0]);
              for (
                this.xNumSteps = this.xSteps.slice(0), i = 0;
                i < this.xNumSteps.length;
                i++
              )
                this.handleStepPoint(i, this.xNumSteps[i]);
            }
            return (
              (t.prototype.getDistance = function (t) {
                for (var e = [], n = 0; n < this.xNumSteps.length - 1; n++)
                  e[n] = BR(this.xVal, t, n);
                return e;
              }),
              (t.prototype.getAbsoluteDistance = function (t, e, n) {
                var i,
                  r = 0;
                if (t < this.xPct[this.xPct.length - 1])
                  for (; t > this.xPct[r + 1]; ) r++;
                else
                  t === this.xPct[this.xPct.length - 1] &&
                    (r = this.xPct.length - 2);
                n || t !== this.xPct[r + 1] || r++, null === e && (e = []);
                var s = 1,
                  o = e[r],
                  a = 0,
                  l = 0,
                  c = 0,
                  u = 0;
                for (
                  i = n
                    ? (t - this.xPct[r]) / (this.xPct[r + 1] - this.xPct[r])
                    : (this.xPct[r + 1] - t) /
                      (this.xPct[r + 1] - this.xPct[r]);
                  o > 0;

                )
                  (a = this.xPct[r + 1 + u] - this.xPct[r + u]),
                    e[r + u] * s + 100 - 100 * i > 100
                      ? ((l = a * i), (s = (o - 100 * i) / e[r + u]), (i = 1))
                      : ((l = ((e[r + u] * a) / 100) * s), (s = 0)),
                    n
                      ? ((c -= l), this.xPct.length + u >= 1 && u--)
                      : ((c += l), this.xPct.length - u >= 1 && u++),
                    (o = e[r + u] * s);
                return t + c;
              }),
              (t.prototype.toStepping = function (t) {
                return (t = HR(this.xVal, this.xPct, t));
              }),
              (t.prototype.fromStepping = function (t) {
                return (function (t, e, n) {
                  if (n >= 100) return t.slice(-1)[0];
                  var i = zR(n, e),
                    r = t[i - 1],
                    s = t[i],
                    o = e[i - 1];
                  return (function (t, e) {
                    return (e * (t[1] - t[0])) / 100 + t[0];
                  })([r, s], (n - o) * kR(o, e[i]));
                })(this.xVal, this.xPct, t);
              }),
              (t.prototype.getStep = function (t) {
                return (t = VR(this.xPct, this.xSteps, this.snap, t));
              }),
              (t.prototype.getDefaultStep = function (t, e, n) {
                var i = zR(t, this.xPct);
                return (
                  (100 === t || (e && t === this.xPct[i - 1])) &&
                    (i = Math.max(i - 1, 1)),
                  (this.xVal[i] - this.xVal[i - 1]) / n
                );
              }),
              (t.prototype.getNearbySteps = function (t) {
                var e = zR(t, this.xPct);
                return {
                  stepBefore: {
                    startValue: this.xVal[e - 2],
                    step: this.xNumSteps[e - 2],
                    highestStep: this.xHighestCompleteStep[e - 2],
                  },
                  thisStep: {
                    startValue: this.xVal[e - 1],
                    step: this.xNumSteps[e - 1],
                    highestStep: this.xHighestCompleteStep[e - 1],
                  },
                  stepAfter: {
                    startValue: this.xVal[e],
                    step: this.xNumSteps[e],
                    highestStep: this.xHighestCompleteStep[e],
                  },
                };
              }),
              (t.prototype.countStepDecimals = function () {
                var t = this.xNumSteps.map(NR);
                return Math.max.apply(null, t);
              }),
              (t.prototype.hasNoSize = function () {
                return this.xVal[0] === this.xVal[this.xVal.length - 1];
              }),
              (t.prototype.convert = function (t) {
                return this.getStep(this.toStepping(t));
              }),
              (t.prototype.handleEntryPoint = function (t, e) {
                var n;
                if (
                  !LR(
                    (n = "min" === t ? 0 : "max" === t ? 100 : parseFloat(t))
                  ) ||
                  !LR(e[0])
                )
                  throw new Error("noUiSlider: 'range' value isn't numeric.");
                this.xPct.push(n), this.xVal.push(e[0]);
                var i = Number(e[1]);
                n
                  ? this.xSteps.push(!isNaN(i) && i)
                  : isNaN(i) || (this.xSteps[0] = i),
                  this.xHighestCompleteStep.push(0);
              }),
              (t.prototype.handleStepPoint = function (t, e) {
                if (e)
                  if (this.xVal[t] !== this.xVal[t + 1]) {
                    this.xSteps[t] =
                      BR([this.xVal[t], this.xVal[t + 1]], e, 0) /
                      kR(this.xPct[t], this.xPct[t + 1]);
                    var n =
                        (this.xVal[t + 1] - this.xVal[t]) / this.xNumSteps[t],
                      i = Math.ceil(Number(n.toFixed(3)) - 1),
                      r = this.xVal[t] + this.xNumSteps[t] * i;
                    this.xHighestCompleteStep[t] = r;
                  } else
                    this.xSteps[t] = this.xHighestCompleteStep[t] =
                      this.xVal[t];
              }),
              t
            );
          })(),
          WR = {
            to: function (t) {
              return void 0 === t ? "" : t.toFixed(2);
            },
            from: Number,
          },
          jR = {
            target: "target",
            base: "base",
            origin: "origin",
            handle: "handle",
            handleLower: "handle-lower",
            handleUpper: "handle-upper",
            touchArea: "touch-area",
            horizontal: "horizontal",
            vertical: "vertical",
            background: "background",
            connect: "connect",
            connects: "connects",
            ltr: "ltr",
            rtl: "rtl",
            textDirectionLtr: "txt-dir-ltr",
            textDirectionRtl: "txt-dir-rtl",
            draggable: "draggable",
            drag: "state-drag",
            tap: "state-tap",
            active: "active",
            tooltip: "tooltip",
            pips: "pips",
            pipsHorizontal: "pips-horizontal",
            pipsVertical: "pips-vertical",
            marker: "marker",
            markerHorizontal: "marker-horizontal",
            markerVertical: "marker-vertical",
            markerNormal: "marker-normal",
            markerLarge: "marker-large",
            markerSub: "marker-sub",
            value: "value",
            valueHorizontal: "value-horizontal",
            valueVertical: "value-vertical",
            valueNormal: "value-normal",
            valueLarge: "value-large",
            valueSub: "value-sub",
          },
          qR = {
            tooltips: ".__tooltips",
            aria: ".__aria",
          };
        function XR(t, e) {
          if (!LR(e)) throw new Error("noUiSlider: 'step' is not numeric.");
          t.singleStep = e;
        }
        function YR(t, e) {
          if (!LR(e))
            throw new Error(
              "noUiSlider: 'keyboardPageMultiplier' is not numeric."
            );
          t.keyboardPageMultiplier = e;
        }
        function KR(t, e) {
          if (!LR(e))
            throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
          t.keyboardMultiplier = e;
        }
        function $R(t, e) {
          if (!LR(e))
            throw new Error(
              "noUiSlider: 'keyboardDefaultStep' is not numeric."
            );
          t.keyboardDefaultStep = e;
        }
        function ZR(t, e) {
          if ("object" != typeof e || Array.isArray(e))
            throw new Error("noUiSlider: 'range' is not an object.");
          if (void 0 === e.min || void 0 === e.max)
            throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
          t.spectrum = new GR(e, t.snap || !1, t.singleStep);
        }
        function JR(t, e) {
          if (((e = IR(e)), !Array.isArray(e) || !e.length))
            throw new Error("noUiSlider: 'start' option is incorrect.");
          (t.handles = e.length), (t.start = e);
        }
        function QR(t, e) {
          if ("boolean" != typeof e)
            throw new Error("noUiSlider: 'snap' option must be a boolean.");
          t.snap = e;
        }
        function tC(t, e) {
          if ("boolean" != typeof e)
            throw new Error("noUiSlider: 'animate' option must be a boolean.");
          t.animate = e;
        }
        function eC(t, e) {
          if ("number" != typeof e)
            throw new Error(
              "noUiSlider: 'animationDuration' option must be a number."
            );
          t.animationDuration = e;
        }
        function nC(t, e) {
          var n,
            i = [!1];
          if (
            ("lower" === e ? (e = [!0, !1]) : "upper" === e && (e = [!1, !0]),
            !0 === e || !1 === e)
          ) {
            for (n = 1; n < t.handles; n++) i.push(e);
            i.push(!1);
          } else {
            if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1)
              throw new Error(
                "noUiSlider: 'connect' option doesn't match handle count."
              );
            i = e;
          }
          t.connect = i;
        }
        function iC(t, e) {
          switch (e) {
            case "horizontal":
              t.ort = 0;
              break;
            case "vertical":
              t.ort = 1;
              break;
            default:
              throw new Error("noUiSlider: 'orientation' option is invalid.");
          }
        }
        function rC(t, e) {
          if (!LR(e))
            throw new Error("noUiSlider: 'margin' option must be numeric.");
          0 !== e && (t.margin = t.spectrum.getDistance(e));
        }
        function sC(t, e) {
          if (!LR(e))
            throw new Error("noUiSlider: 'limit' option must be numeric.");
          if (
            ((t.limit = t.spectrum.getDistance(e)), !t.limit || t.handles < 2)
          )
            throw new Error(
              "noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles."
            );
        }
        function oC(t, e) {
          var n;
          if (!LR(e) && !Array.isArray(e))
            throw new Error(
              "noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."
            );
          if (Array.isArray(e) && 2 !== e.length && !LR(e[0]) && !LR(e[1]))
            throw new Error(
              "noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."
            );
          if (0 !== e) {
            for (
              Array.isArray(e) || (e = [e, e]),
                t.padding = [
                  t.spectrum.getDistance(e[0]),
                  t.spectrum.getDistance(e[1]),
                ],
                n = 0;
              n < t.spectrum.xNumSteps.length - 1;
              n++
            )
              if (t.padding[0][n] < 0 || t.padding[1][n] < 0)
                throw new Error(
                  "noUiSlider: 'padding' option must be a positive number(s)."
                );
            var i = e[0] + e[1],
              r = t.spectrum.xVal[0];
            if (i / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - r) > 1)
              throw new Error(
                "noUiSlider: 'padding' option must not exceed 100% of the range."
              );
          }
        }
        function aC(t, e) {
          switch (e) {
            case "ltr":
              t.dir = 0;
              break;
            case "rtl":
              t.dir = 1;
              break;
            default:
              throw new Error(
                "noUiSlider: 'direction' option was not recognized."
              );
          }
        }
        function lC(t, e) {
          if ("string" != typeof e)
            throw new Error(
              "noUiSlider: 'behaviour' must be a string containing options."
            );
          var n = e.indexOf("tap") >= 0,
            i = e.indexOf("drag") >= 0,
            r = e.indexOf("fixed") >= 0,
            s = e.indexOf("snap") >= 0,
            o = e.indexOf("hover") >= 0,
            a = e.indexOf("unconstrained") >= 0,
            l = e.indexOf("invert-connects") >= 0,
            c = e.indexOf("drag-all") >= 0,
            u = e.indexOf("smooth-steps") >= 0;
          if (r) {
            if (2 !== t.handles)
              throw new Error(
                "noUiSlider: 'fixed' behaviour must be used with 2 handles"
              );
            rC(t, t.start[1] - t.start[0]);
          }
          if (l && 2 !== t.handles)
            throw new Error(
              "noUiSlider: 'invert-connects' behaviour must be used with 2 handles"
            );
          if (a && (t.margin || t.limit))
            throw new Error(
              "noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit"
            );
          t.events = {
            tap: n || s,
            drag: i,
            dragAll: c,
            smoothSteps: u,
            fixed: r,
            snap: s,
            hover: o,
            unconstrained: a,
            invertConnects: l,
          };
        }
        function cC(t, e) {
          if (!1 !== e)
            if (!0 === e || TR(e)) {
              t.tooltips = [];
              for (var n = 0; n < t.handles; n++) t.tooltips.push(e);
            } else {
              if ((e = IR(e)).length !== t.handles)
                throw new Error(
                  "noUiSlider: must pass a formatter for all handles."
                );
              e.forEach(function (t) {
                if ("boolean" != typeof t && !TR(t))
                  throw new Error(
                    "noUiSlider: 'tooltips' must be passed a formatter or 'false'."
                  );
              }),
                (t.tooltips = e);
            }
        }
        function uC(t, e) {
          if (e.length !== t.handles)
            throw new Error(
              "noUiSlider: must pass a attributes for all handles."
            );
          t.handleAttributes = e;
        }
        function hC(t, e) {
          if (!TR(e))
            throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
          t.ariaFormat = e;
        }
        function dC(t, e) {
          if (
            !(function (t) {
              return TR(t) && "function" == typeof t.from;
            })(e)
          )
            throw new Error(
              "noUiSlider: 'format' requires 'to' and 'from' methods."
            );
          t.format = e;
        }
        function pC(t, e) {
          if ("boolean" != typeof e)
            throw new Error(
              "noUiSlider: 'keyboardSupport' option must be a boolean."
            );
          t.keyboardSupport = e;
        }
        function fC(t, e) {
          t.documentElement = e;
        }
        function mC(t, e) {
          if ("string" != typeof e && !1 !== e)
            throw new Error(
              "noUiSlider: 'cssPrefix' must be a string or `false`."
            );
          t.cssPrefix = e;
        }
        function gC(t, e) {
          if ("object" != typeof e)
            throw new Error("noUiSlider: 'cssClasses' must be an object.");
          "string" == typeof t.cssPrefix
            ? ((t.cssClasses = {}),
              Object.keys(e).forEach(function (n) {
                t.cssClasses[n] = t.cssPrefix + e[n];
              }))
            : (t.cssClasses = e);
        }
        function vC(t) {
          var e = {
              margin: null,
              limit: null,
              padding: null,
              animate: !0,
              animationDuration: 300,
              ariaFormat: WR,
              format: WR,
            },
            n = {
              step: {
                r: !1,
                t: XR,
              },
              keyboardPageMultiplier: {
                r: !1,
                t: YR,
              },
              keyboardMultiplier: {
                r: !1,
                t: KR,
              },
              keyboardDefaultStep: {
                r: !1,
                t: $R,
              },
              start: {
                r: !0,
                t: JR,
              },
              connect: {
                r: !0,
                t: nC,
              },
              direction: {
                r: !0,
                t: aC,
              },
              snap: {
                r: !1,
                t: QR,
              },
              animate: {
                r: !1,
                t: tC,
              },
              animationDuration: {
                r: !1,
                t: eC,
              },
              range: {
                r: !0,
                t: ZR,
              },
              orientation: {
                r: !1,
                t: iC,
              },
              margin: {
                r: !1,
                t: rC,
              },
              limit: {
                r: !1,
                t: sC,
              },
              padding: {
                r: !1,
                t: oC,
              },
              behaviour: {
                r: !0,
                t: lC,
              },
              ariaFormat: {
                r: !1,
                t: hC,
              },
              format: {
                r: !1,
                t: dC,
              },
              tooltips: {
                r: !1,
                t: cC,
              },
              keyboardSupport: {
                r: !0,
                t: pC,
              },
              documentElement: {
                r: !1,
                t: fC,
              },
              cssPrefix: {
                r: !0,
                t: mC,
              },
              cssClasses: {
                r: !0,
                t: gC,
              },
              handleAttributes: {
                r: !1,
                t: uC,
              },
            },
            i = {
              connect: !1,
              direction: "ltr",
              behaviour: "tap",
              orientation: "horizontal",
              keyboardSupport: !0,
              cssPrefix: "noUi-",
              cssClasses: jR,
              keyboardPageMultiplier: 5,
              keyboardMultiplier: 1,
              keyboardDefaultStep: 10,
            };
          t.format && !t.ariaFormat && (t.ariaFormat = t.format),
            Object.keys(n).forEach(function (r) {
              if (RR(t[r]) || void 0 !== i[r])
                n[r].t(e, RR(t[r]) ? t[r] : i[r]);
              else if (n[r].r)
                throw new Error("noUiSlider: '" + r + "' is required.");
            }),
            (e.pips = t.pips);
          var r = document.createElement("div"),
            s = void 0 !== r.style.msTransform,
            o = void 0 !== r.style.transform;
          e.transformRule = o
            ? "transform"
            : s
            ? "msTransform"
            : "webkitTransform";
          return (
            (e.style = [
              ["left", "top"],
              ["right", "bottom"],
            ][e.dir][e.ort]),
            e
          );
        }
        function yC(t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u = window.navigator.pointerEnabled
              ? {
                  start: "pointerdown",
                  move: "pointermove",
                  end: "pointerup",
                }
              : window.navigator.msPointerEnabled
              ? {
                  start: "MSPointerDown",
                  move: "MSPointerMove",
                  end: "MSPointerUp",
                }
              : {
                  start: "mousedown touchstart",
                  move: "mousemove touchmove",
                  end: "mouseup touchend",
                },
            h =
              window.CSS &&
              CSS.supports &&
              CSS.supports("touch-action", "none") &&
              (function () {
                var t = !1;
                try {
                  var e = Object.defineProperty({}, "passive", {
                    get: function () {
                      t = !0;
                    },
                  });
                  window.addEventListener("test", null, e);
                } catch (t) {}
                return t;
              })(),
            d = t,
            p = e.spectrum,
            f = [],
            m = [],
            g = [],
            v = 0,
            y = {},
            _ = !1,
            x = t.ownerDocument,
            b = e.documentElement || x.documentElement,
            w = x.body,
            E = "rtl" === x.dir || 1 === e.ort ? 0 : 100;
          function S(t, e) {
            var n = x.createElement("div");
            return e && DR(n, e), t.appendChild(n), n;
          }
          function M(t, n) {
            var i = S(t, e.cssClasses.origin),
              r = S(i, e.cssClasses.handle);
            if (
              (S(r, e.cssClasses.touchArea),
              r.setAttribute("data-handle", String(n)),
              e.keyboardSupport &&
                (r.setAttribute("tabindex", "0"),
                r.addEventListener("keydown", function (t) {
                  return (function (t, n) {
                    if (R() || C(n)) return !1;
                    var i = ["Left", "Right"],
                      r = ["Down", "Up"],
                      s = ["PageDown", "PageUp"],
                      o = ["Home", "End"];
                    e.dir && !e.ort
                      ? i.reverse()
                      : e.ort && !e.dir && (r.reverse(), s.reverse());
                    var a,
                      l = t.key.replace("Arrow", ""),
                      c = l === s[0],
                      u = l === s[1],
                      h = l === r[0] || l === i[0] || c,
                      d = l === r[1] || l === i[1] || u,
                      g = l === o[0],
                      v = l === o[1];
                    if (!(h || d || g || v)) return !0;
                    if ((t.preventDefault(), d || h)) {
                      var y = h ? 0 : 1,
                        _ = at(n)[y];
                      if (null === _) return !1;
                      !1 === _ &&
                        (_ = p.getDefaultStep(m[n], h, e.keyboardDefaultStep)),
                        (_ *=
                          u || c
                            ? e.keyboardPageMultiplier
                            : e.keyboardMultiplier),
                        (_ = Math.max(_, 1e-7)),
                        (_ *= h ? -1 : 1),
                        (a = f[n] + _);
                    } else a = v ? e.spectrum.xVal[e.spectrum.xVal.length - 1] : e.spectrum.xVal[0];
                    return (
                      nt(n, p.toStepping(a), !0, !0),
                      K("slide", n),
                      K("update", n),
                      K("change", n),
                      K("set", n),
                      !1
                    );
                  })(t, n);
                })),
              void 0 !== e.handleAttributes)
            ) {
              var s = e.handleAttributes[n];
              Object.keys(s).forEach(function (t) {
                r.setAttribute(t, s[t]);
              });
            }
            return (
              r.setAttribute("role", "slider"),
              r.setAttribute(
                "aria-orientation",
                e.ort ? "vertical" : "horizontal"
              ),
              0 === n
                ? DR(r, e.cssClasses.handleLower)
                : n === e.handles - 1 && DR(r, e.cssClasses.handleUpper),
              (i.handle = r),
              i
            );
          }
          function T(t, n) {
            return !!n && S(t, e.cssClasses.connect);
          }
          function A(t, n) {
            return (
              !(!e.tooltips || !e.tooltips[n]) &&
              S(t.firstChild, e.cssClasses.tooltip)
            );
          }
          function R() {
            return d.hasAttribute("disabled");
          }
          function C(t) {
            return s[t].hasAttribute("disabled");
          }
          function L() {
            l &&
              (Y("update" + qR.tooltips),
              l.forEach(function (t) {
                t && AR(t);
              }),
              (l = null));
          }
          function P() {
            L(),
              (l = s.map(A)),
              X("update" + qR.tooltips, function (t, n, i) {
                if (l && e.tooltips && !1 !== l[n]) {
                  var r = t[n];
                  !0 !== e.tooltips[n] && (r = e.tooltips[n].to(i[n])),
                    (l[n].innerHTML = r);
                }
              });
          }
          function O(t, e) {
            return t.map(function (t) {
              return p.fromStepping(e ? p.getStep(t) : t);
            });
          }
          function I(t) {
            var e,
              n = (function (t) {
                if (t.mode === xR.Range || t.mode === xR.Steps) return p.xVal;
                if (t.mode === xR.Count) {
                  if (t.values < 2)
                    throw new Error(
                      "noUiSlider: 'values' (>= 2) required for mode 'count'."
                    );
                  for (var e = t.values - 1, n = 100 / e, i = []; e--; )
                    i[e] = e * n;
                  return i.push(100), O(i, t.stepped);
                }
                return t.mode === xR.Positions
                  ? O(t.values, t.stepped)
                  : t.mode === xR.Values
                  ? t.stepped
                    ? t.values.map(function (t) {
                        return p.fromStepping(p.getStep(p.toStepping(t)));
                      })
                    : t.values
                  : [];
              })(t),
              i = {},
              r = p.xVal[0],
              s = p.xVal[p.xVal.length - 1],
              o = !1,
              a = !1,
              l = 0;
            return (
              (e = n.slice().sort(function (t, e) {
                return t - e;
              })),
              (n = e.filter(function (t) {
                return !this[t] && (this[t] = !0);
              }, {})),
              n[0] !== r && (n.unshift(r), (o = !0)),
              n[n.length - 1] !== s && (n.push(s), (a = !0)),
              n.forEach(function (e, r) {
                var s,
                  c,
                  u,
                  h,
                  d,
                  f,
                  m,
                  g,
                  v,
                  y,
                  _ = e,
                  x = n[r + 1],
                  b = t.mode === xR.Steps;
                for (
                  b && (s = p.xNumSteps[r]),
                    s || (s = x - _),
                    void 0 === x && (x = _),
                    s = Math.max(s, 1e-7),
                    c = _;
                  c <= x;
                  c = Number((c + s).toFixed(7))
                ) {
                  for (
                    g = (d = (h = p.toStepping(c)) - l) / (t.density || 1),
                      y = d / (v = Math.round(g)),
                      u = 1;
                    u <= v;
                    u += 1
                  )
                    i[(f = l + u * y).toFixed(5)] = [p.fromStepping(f), 0];
                  (m =
                    n.indexOf(c) > -1
                      ? bR.LargeValue
                      : b
                      ? bR.SmallValue
                      : bR.NoValue),
                    !r && o && c !== x && (m = 0),
                    (c === x && a) || (i[h.toFixed(5)] = [c, m]),
                    (l = h);
                }
              }),
              i
            );
          }
          function N(t, n, i) {
            var r,
              s,
              o = x.createElement("div"),
              a =
                (((r = {})[bR.None] = ""),
                (r[bR.NoValue] = e.cssClasses.valueNormal),
                (r[bR.LargeValue] = e.cssClasses.valueLarge),
                (r[bR.SmallValue] = e.cssClasses.valueSub),
                r),
              l =
                (((s = {})[bR.None] = ""),
                (s[bR.NoValue] = e.cssClasses.markerNormal),
                (s[bR.LargeValue] = e.cssClasses.markerLarge),
                (s[bR.SmallValue] = e.cssClasses.markerSub),
                s),
              c = [e.cssClasses.valueHorizontal, e.cssClasses.valueVertical],
              u = [e.cssClasses.markerHorizontal, e.cssClasses.markerVertical];
            function h(t, n) {
              var i = n === e.cssClasses.value,
                r = i ? a : l;
              return n + " " + (i ? c : u)[e.ort] + " " + r[t];
            }
            return (
              DR(o, e.cssClasses.pips),
              DR(
                o,
                0 === e.ort
                  ? e.cssClasses.pipsHorizontal
                  : e.cssClasses.pipsVertical
              ),
              Object.keys(t).forEach(function (r) {
                !(function (t, r, s) {
                  if ((s = n ? n(r, s) : s) !== bR.None) {
                    var a = S(o, !1);
                    (a.className = h(s, e.cssClasses.marker)),
                      (a.style[e.style] = t + "%"),
                      s > bR.NoValue &&
                        (((a = S(o, !1)).className = h(s, e.cssClasses.value)),
                        a.setAttribute("data-value", String(r)),
                        (a.style[e.style] = t + "%"),
                        (a.innerHTML = String(i.to(r))));
                  }
                })(r, t[r][0], t[r][1]);
              }),
              o
            );
          }
          function D() {
            a && (AR(a), (a = null));
          }
          function U(t) {
            D();
            var e = I(t),
              n = t.filter,
              i = t.format || {
                to: function (t) {
                  return String(Math.round(t));
                },
              };
            return (a = d.appendChild(N(e, n, i)));
          }
          function F() {
            var t = i.getBoundingClientRect(),
              n = "offset" + ["Width", "Height"][e.ort];
            return 0 === e.ort ? t.width || i[n] : t.height || i[n];
          }
          function k(t, n, i, r) {
            var s = function (s) {
                var o,
                  a,
                  l = (function (t, e, n) {
                    var i = 0 === t.type.indexOf("touch"),
                      r = 0 === t.type.indexOf("mouse"),
                      s = 0 === t.type.indexOf("pointer"),
                      o = 0,
                      a = 0;
                    0 === t.type.indexOf("MSPointer") && (s = !0);
                    if ("mousedown" === t.type && !t.buttons && !t.touches)
                      return !1;
                    if (i) {
                      var l = function (e) {
                        var i = e.target;
                        return (
                          i === n ||
                          n.contains(i) ||
                          (t.composed && t.composedPath().shift() === n)
                        );
                      };
                      if ("touchstart" === t.type) {
                        var c = Array.prototype.filter.call(t.touches, l);
                        if (c.length > 1) return !1;
                        (o = c[0].pageX), (a = c[0].pageY);
                      } else {
                        var u = Array.prototype.find.call(t.changedTouches, l);
                        if (!u) return !1;
                        (o = u.pageX), (a = u.pageY);
                      }
                    }
                    (e = e || FR(x)),
                      (r || s) &&
                        ((o = t.clientX + e.x), (a = t.clientY + e.y));
                    return (
                      (t.pageOffset = e),
                      (t.points = [o, a]),
                      (t.cursor = r || s),
                      t
                    );
                  })(s, r.pageOffset, r.target || n);
                return (
                  !!l &&
                  !(R() && !r.doNotReject) &&
                  ((o = d),
                  (a = e.cssClasses.tap),
                  !(
                    (o.classList
                      ? o.classList.contains(a)
                      : new RegExp("\\b" + a + "\\b").test(o.className)) &&
                    !r.doNotReject
                  ) &&
                    !(t === u.start && void 0 !== l.buttons && l.buttons > 1) &&
                    (!r.hover || !l.buttons) &&
                    (h || l.preventDefault(),
                    (l.calcPoint = l.points[e.ort]),
                    void i(l, r)))
                );
              },
              o = [];
            return (
              t.split(" ").forEach(function (t) {
                n.addEventListener(
                  t,
                  s,
                  !!h && {
                    passive: !0,
                  }
                ),
                  o.push([t, s]);
              }),
              o
            );
          }
          function B(t) {
            var n =
                t -
                (function (t, e) {
                  var n = t.getBoundingClientRect(),
                    i = t.ownerDocument,
                    r = i.documentElement,
                    s = FR(i);
                  return (
                    /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) &&
                      (s.x = 0),
                    e ? n.top + s.y - r.clientTop : n.left + s.x - r.clientLeft
                  );
                })(i, e.ort),
              r = (100 * n) / F();
            return (r = OR(r)), e.dir ? 100 - r : r;
          }
          function z(t, e) {
            "mouseout" === t.type &&
              "HTML" === t.target.nodeName &&
              null === t.relatedTarget &&
              V(t, e);
          }
          function H(t, n) {
            if (
              -1 === navigator.appVersion.indexOf("MSIE 9") &&
              0 === t.buttons &&
              0 !== n.buttonsProperty
            )
              return V(t, n);
            var i = (e.dir ? -1 : 1) * (t.calcPoint - n.startCalcPoint);
            J(
              i > 0,
              (100 * i) / n.baseSize,
              n.locations,
              n.handleNumbers,
              n.connect
            );
          }
          function V(t, n) {
            n.handle && (UR(n.handle, e.cssClasses.active), (v -= 1)),
              n.listeners.forEach(function (t) {
                b.removeEventListener(t[0], t[1]);
              }),
              0 === v &&
                (UR(d, e.cssClasses.drag),
                et(),
                t.cursor &&
                  ((w.style.cursor = ""),
                  w.removeEventListener("selectstart", CR))),
              e.events.smoothSteps &&
                (n.handleNumbers.forEach(function (t) {
                  nt(t, m[t], !0, !0, !1, !1);
                }),
                n.handleNumbers.forEach(function (t) {
                  K("update", t);
                })),
              n.handleNumbers.forEach(function (t) {
                K("change", t), K("set", t), K("end", t);
              });
          }
          function G(t, n) {
            if (!n.handleNumbers.some(C)) {
              var i;
              if (1 === n.handleNumbers.length)
                (i = s[n.handleNumbers[0]].children[0]),
                  (v += 1),
                  DR(i, e.cssClasses.active);
              t.stopPropagation();
              var r = [],
                o = k(u.move, b, H, {
                  target: t.target,
                  handle: i,
                  connect: n.connect,
                  listeners: r,
                  startCalcPoint: t.calcPoint,
                  baseSize: F(),
                  pageOffset: t.pageOffset,
                  handleNumbers: n.handleNumbers,
                  buttonsProperty: t.buttons,
                  locations: m.slice(),
                }),
                a = k(u.end, b, V, {
                  target: t.target,
                  handle: i,
                  listeners: r,
                  doNotReject: !0,
                  handleNumbers: n.handleNumbers,
                }),
                l = k("mouseout", b, z, {
                  target: t.target,
                  handle: i,
                  listeners: r,
                  doNotReject: !0,
                  handleNumbers: n.handleNumbers,
                });
              r.push.apply(r, o.concat(a, l)),
                t.cursor &&
                  ((w.style.cursor = getComputedStyle(t.target).cursor),
                  s.length > 1 && DR(d, e.cssClasses.drag),
                  w.addEventListener("selectstart", CR, !1)),
                n.handleNumbers.forEach(function (t) {
                  K("start", t);
                });
            }
          }
          function W(t) {
            t.stopPropagation();
            var n = B(t.calcPoint),
              i = (function (t) {
                var e = 100,
                  n = !1;
                return (
                  s.forEach(function (i, r) {
                    if (!C(r)) {
                      var s = m[r],
                        o = Math.abs(s - t);
                      (o < e ||
                        (o <= e && t > s) ||
                        (100 === o && 100 === e)) &&
                        ((n = r), (e = o));
                    }
                  }),
                  n
                );
              })(n);
            !1 !== i &&
              (e.events.snap || PR(d, e.cssClasses.tap, e.animationDuration),
              nt(i, n, !0, !0),
              et(),
              K("slide", i, !0),
              K("update", i, !0),
              e.events.snap
                ? G(t, {
                    handleNumbers: [i],
                  })
                : (K("change", i, !0), K("set", i, !0)));
          }
          function j(t) {
            var e = B(t.calcPoint),
              n = p.getStep(e),
              i = p.fromStepping(n);
            Object.keys(y).forEach(function (t) {
              "hover" === t.split(".")[0] &&
                y[t].forEach(function (t) {
                  t.call(ct, i);
                });
            });
          }
          function q(t) {
            t.fixed ||
              s.forEach(function (t, e) {
                k(u.start, t.children[0], G, {
                  handleNumbers: [e],
                });
              }),
              t.tap && k(u.start, i, W, {}),
              t.hover &&
                k(u.move, i, j, {
                  hover: !0,
                }),
              t.drag &&
                o.forEach(function (n, i) {
                  if (!1 !== n && 0 !== i && i !== o.length - 1) {
                    var r = s[i - 1],
                      a = s[i],
                      l = [n],
                      c = [r, a],
                      h = [i - 1, i];
                    DR(n, e.cssClasses.draggable),
                      t.fixed && (l.push(r.children[0]), l.push(a.children[0])),
                      t.dragAll && ((c = s), (h = g)),
                      l.forEach(function (t) {
                        k(u.start, t, G, {
                          handles: c,
                          handleNumbers: h,
                          connect: n,
                        });
                      });
                  }
                });
          }
          function X(t, e) {
            (y[t] = y[t] || []),
              y[t].push(e),
              "update" === t.split(".")[0] &&
                s.forEach(function (t, e) {
                  K("update", e);
                });
          }
          function Y(t) {
            var e = t && t.split(".")[0],
              n = e ? t.substring(e.length) : t;
            Object.keys(y).forEach(function (t) {
              var i = t.split(".")[0],
                r = t.substring(i.length);
              (e && e !== i) ||
                (n && n !== r) ||
                ((function (t) {
                  return t === qR.aria || t === qR.tooltips;
                })(r) &&
                  n !== r) ||
                delete y[t];
            });
          }
          function K(t, n, i) {
            Object.keys(y).forEach(function (r) {
              var s = r.split(".")[0];
              t === s &&
                y[r].forEach(function (t) {
                  t.call(
                    ct,
                    f.map(e.format.to),
                    n,
                    f.slice(),
                    i || !1,
                    m.slice(),
                    ct
                  );
                });
            });
          }
          function $(t, n, i, r, o, a, l) {
            var c;
            return (
              s.length > 1 &&
                !e.events.unconstrained &&
                (r &&
                  n > 0 &&
                  ((c = p.getAbsoluteDistance(t[n - 1], e.margin, !1)),
                  (i = Math.max(i, c))),
                o &&
                  n < s.length - 1 &&
                  ((c = p.getAbsoluteDistance(t[n + 1], e.margin, !0)),
                  (i = Math.min(i, c)))),
              s.length > 1 &&
                e.limit &&
                (r &&
                  n > 0 &&
                  ((c = p.getAbsoluteDistance(t[n - 1], e.limit, !1)),
                  (i = Math.min(i, c))),
                o &&
                  n < s.length - 1 &&
                  ((c = p.getAbsoluteDistance(t[n + 1], e.limit, !0)),
                  (i = Math.max(i, c)))),
              e.padding &&
                (0 === n &&
                  ((c = p.getAbsoluteDistance(0, e.padding[0], !1)),
                  (i = Math.max(i, c))),
                n === s.length - 1 &&
                  ((c = p.getAbsoluteDistance(100, e.padding[1], !0)),
                  (i = Math.min(i, c)))),
              l || (i = p.getStep(i)),
              !((i = OR(i)) === t[n] && !a) && i
            );
          }
          function Z(t, n) {
            var i = e.ort;
            return (i ? n : t) + ", " + (i ? t : n);
          }
          function J(t, n, i, r, s) {
            var o = i.slice(),
              a = r[0],
              l = e.events.smoothSteps,
              c = [!t, t],
              u = [t, !t];
            (r = r.slice()),
              t && r.reverse(),
              r.length > 1
                ? r.forEach(function (t, e) {
                    var i = $(o, t, o[t] + n, c[e], u[e], !1, l);
                    !1 === i ? (n = 0) : ((n = i - o[t]), (o[t] = i));
                  })
                : (c = u = [!0]);
            var h = !1;
            r.forEach(function (t, e) {
              h = nt(t, i[t] + n, c[e], u[e], !1, l) || h;
            }),
              h &&
                (r.forEach(function (t) {
                  K("update", t), K("slide", t);
                }),
                null != s && K("drag", a));
          }
          function Q(t, n) {
            return e.dir ? 100 - t - n : t;
          }
          function tt(t, n) {
            (m[t] = n), (f[t] = p.fromStepping(n));
            var i = "translate(" + Z(Q(n, 0) - E + "%", "0") + ")";
            if (
              ((s[t].style[e.transformRule] = i),
              e.events.invertConnects && m.length > 1)
            ) {
              var r = m.every(function (t, e, n) {
                return 0 === e || t >= n[e - 1];
              });
              if (_ !== !r)
                return (
                  (_ = !_),
                  nC(
                    e,
                    e.connect.map(function (t) {
                      return !t;
                    })
                  ),
                  void lt()
                );
            }
            it(t), it(t + 1), _ && (it(t - 1), it(t + 2));
          }
          function et() {
            g.forEach(function (t) {
              var e = m[t] > 50 ? -1 : 1,
                n = 3 + (s.length + e * t);
              s[t].style.zIndex = String(n);
            });
          }
          function nt(t, e, n, i, r, s) {
            return (
              r || (e = $(m, t, e, n, i, !1, s)), !1 !== e && (tt(t, e), !0)
            );
          }
          function it(t) {
            if (o[t]) {
              var n = m.slice();
              _ &&
                n.sort(function (t, e) {
                  return t - e;
                });
              var i = 0,
                r = 100;
              0 !== t && (i = n[t - 1]), t !== o.length - 1 && (r = n[t]);
              var s = r - i,
                a = "translate(" + Z(Q(i, s) + "%", "0") + ")",
                l = "scale(" + Z(s / 100, "1") + ")";
              o[t].style[e.transformRule] = a + " " + l;
            }
          }
          function rt(t, n) {
            return null === t || !1 === t || void 0 === t
              ? m[n]
              : ("number" == typeof t && (t = String(t)),
                !1 !== (t = e.format.from(t)) && (t = p.toStepping(t)),
                !1 === t || isNaN(t) ? m[n] : t);
          }
          function st(t, n, i) {
            var r = IR(t),
              s = void 0 === m[0];
            (n = void 0 === n || n),
              e.animate && !s && PR(d, e.cssClasses.tap, e.animationDuration),
              g.forEach(function (t) {
                nt(t, rt(r[t], t), !0, !1, i);
              });
            var o = 1 === g.length ? 0 : 1;
            if (s && p.hasNoSize() && ((i = !0), (m[0] = 0), g.length > 1)) {
              var a = 100 / (g.length - 1);
              g.forEach(function (t) {
                m[t] = t * a;
              });
            }
            for (; o < g.length; ++o)
              g.forEach(function (t) {
                nt(t, m[t], !0, !0, i);
              });
            et(),
              g.forEach(function (t) {
                K("update", t), null !== r[t] && n && K("set", t);
              });
          }
          function ot(t) {
            if ((void 0 === t && (t = !1), t))
              return 1 === f.length ? f[0] : f.slice(0);
            var n = f.map(e.format.to);
            return 1 === n.length ? n[0] : n;
          }
          function at(t) {
            var n = m[t],
              i = p.getNearbySteps(n),
              r = f[t],
              s = i.thisStep.step,
              o = null;
            if (e.snap)
              return [
                r - i.stepBefore.startValue || null,
                i.stepAfter.startValue - r || null,
              ];
            !1 !== s &&
              r + s > i.stepAfter.startValue &&
              (s = i.stepAfter.startValue - r),
              (o =
                r > i.thisStep.startValue
                  ? i.thisStep.step
                  : !1 !== i.stepBefore.step && r - i.stepBefore.highestStep),
              100 === n ? (s = null) : 0 === n && (o = null);
            var a = p.countStepDecimals();
            return (
              null !== s && !1 !== s && (s = Number(s.toFixed(a))),
              null !== o && !1 !== o && (o = Number(o.toFixed(a))),
              [o, s]
            );
          }
          function lt() {
            for (; r.firstChild; ) r.removeChild(r.firstChild);
            for (var t = 0; t <= e.handles; t++)
              (o[t] = T(r, e.connect[t])), it(t);
            q({
              drag: e.events.drag,
              fixed: !0,
            });
          }
          DR((c = d), e.cssClasses.target),
            0 === e.dir ? DR(c, e.cssClasses.ltr) : DR(c, e.cssClasses.rtl),
            0 === e.ort
              ? DR(c, e.cssClasses.horizontal)
              : DR(c, e.cssClasses.vertical),
            DR(
              c,
              "rtl" === getComputedStyle(c).direction
                ? e.cssClasses.textDirectionRtl
                : e.cssClasses.textDirectionLtr
            ),
            (i = S(c, e.cssClasses.base)),
            (function (t, n) {
              (r = S(n, e.cssClasses.connects)),
                (s = []),
                (o = []).push(T(r, t[0]));
              for (var i = 0; i < e.handles; i++)
                s.push(M(n, i)), (g[i] = i), o.push(T(r, t[i + 1]));
            })(e.connect, i),
            q(e.events),
            st(e.start),
            e.pips && U(e.pips),
            e.tooltips && P(),
            Y("update" + qR.aria),
            X("update" + qR.aria, function (t, n, i, r, o) {
              g.forEach(function (t) {
                var n = s[t],
                  r = $(m, t, 0, !0, !0, !0),
                  a = $(m, t, 100, !0, !0, !0),
                  l = o[t],
                  c = String(e.ariaFormat.to(i[t]));
                (r = p.fromStepping(r).toFixed(1)),
                  (a = p.fromStepping(a).toFixed(1)),
                  (l = p.fromStepping(l).toFixed(1)),
                  n.children[0].setAttribute("aria-valuemin", r),
                  n.children[0].setAttribute("aria-valuemax", a),
                  n.children[0].setAttribute("aria-valuenow", l),
                  n.children[0].setAttribute("aria-valuetext", c);
              });
            });
          var ct = {
            destroy: function () {
              for (
                Y(qR.aria),
                  Y(qR.tooltips),
                  Object.keys(e.cssClasses).forEach(function (t) {
                    UR(d, e.cssClasses[t]);
                  });
                d.firstChild;

              )
                d.removeChild(d.firstChild);
              delete d.noUiSlider;
            },
            steps: function () {
              return g.map(at);
            },
            on: X,
            off: Y,
            get: ot,
            set: st,
            setHandle: function (t, e, n, i) {
              if (!((t = Number(t)) >= 0 && t < g.length))
                throw new Error("noUiSlider: invalid handle number, got: " + t);
              nt(t, rt(e, t), !0, !0, i), K("update", t), n && K("set", t);
            },
            reset: function (t) {
              st(e.start, t);
            },
            disable: function (t) {
              null != t
                ? (s[t].setAttribute("disabled", ""),
                  s[t].handle.removeAttribute("tabindex"))
                : (d.setAttribute("disabled", ""),
                  s.forEach(function (t) {
                    t.handle.removeAttribute("tabindex");
                  }));
            },
            enable: function (t) {
              null != t
                ? (s[t].removeAttribute("disabled"),
                  s[t].handle.setAttribute("tabindex", "0"))
                : (d.removeAttribute("disabled"),
                  s.forEach(function (t) {
                    t.removeAttribute("disabled"),
                      t.handle.setAttribute("tabindex", "0");
                  }));
            },
            __moveHandles: function (t, e, n) {
              J(t, e, m, n);
            },
            options: n,
            updateOptions: function (t, i) {
              var r = ot(),
                s = [
                  "margin",
                  "limit",
                  "padding",
                  "range",
                  "animate",
                  "snap",
                  "step",
                  "format",
                  "pips",
                  "tooltips",
                  "connect",
                ];
              s.forEach(function (e) {
                void 0 !== t[e] && (n[e] = t[e]);
              });
              var o = vC(n);
              s.forEach(function (n) {
                void 0 !== t[n] && (e[n] = o[n]);
              }),
                (p = o.spectrum),
                (e.margin = o.margin),
                (e.limit = o.limit),
                (e.padding = o.padding),
                e.pips ? U(e.pips) : D(),
                e.tooltips ? P() : L(),
                (m = []),
                st(RR(t.start) ? t.start : r, i),
                t.connect && lt();
            },
            target: d,
            removePips: D,
            removeTooltips: L,
            getPositions: function () {
              return m.slice();
            },
            getTooltips: function () {
              return l;
            },
            getOrigins: function () {
              return s;
            },
            pips: U,
          };
          return ct;
        }
        const _C = {
          __spectrum: GR,
          cssClasses: jR,
          create: function (t, e) {
            if (!t || !t.nodeName)
              throw new Error(
                "noUiSlider: create requires a single element, got: " + t
              );
            if (t.noUiSlider)
              throw new Error("noUiSlider: Slider was already initialized.");
            var n = yC(t, vC(e), e);
            return (t.noUiSlider = n), n;
          },
        };
        function xC() {
          const t = document.getElementById("range-slider");
          _C.create(t, {
            range: {
              min: 1e6,
              max: 3e7,
            },
            step: 1e6,
            start: [1e7, 21e6],
            margin: 11e5,
            connect: !0,
            behaviour: "tap-drag",
          }).on("update", function (t) {
            !(function (t) {
              const e = document.getElementById("input-08"),
                n = document.querySelector("[data-js-range-result-num]"),
                i = n.querySelector(".lower-num"),
                r = n.querySelector(".upper-num");
              (i.innerHTML = "¥" + Number(t[0]).toLocaleString()),
                (r.innerHTML = "¥" + Number(t[1]).toLocaleString()),
                (e.value = n.innerText.replace(/\r?\n/g, ""));
            })(t);
          });
        }
        class bC {
          constructor() {
            (this.requiredFields = document.querySelectorAll(
              ".input-validation-item"
            )),
              (this.requiredCheckboxAgree = document.querySelector(
                ".input-validation-agree input"
              )),
              (this.requiredCheckboxDetails = document.querySelectorAll(
                ".input-validation-detail input"
              )),
              (this.submitButton = document.querySelector(".wpcf7-submit")),
              (this.requiredArray = {}),
              this.init();
          }
          init() {
            (this.submitButton.disabled = !0),
              this.requiredFields.forEach((t) => {
                "" === t.value && (this.requiredArray[t.name] = !1),
                  t.addEventListener("input", () => this.handleInput(t));
              }),
              this.requiredCheckboxAgree &&
                this.requiredCheckboxAgree.addEventListener("input", () =>
                  this.handleCheckboxAgree()
                ),
              this.requiredCheckboxDetails.forEach((t) => {
                t.addEventListener("input", () => this.handleCheckboxDetails());
              }),
              this.reloadReCaptcha();
          }
          handleInput(t) {
            "" === t.value
              ? (this.requiredArray[t.name] = !1)
              : delete this.requiredArray[t.name],
              this.updateSubmitButtonState();
          }
          handleCheckboxAgree() {
            const t = document.querySelector(
              ".input-validation-agree input:checked"
            );
            this.updateSubmitButtonState(t);
          }
          handleCheckboxDetails() {
            const t = document.querySelectorAll(
              ".input-validation-detail input:checked"
            );
            this.updateSubmitButtonState(t.length > 0);
          }
          updateSubmitButtonState(t = !0) {
            const e = 0 === Object.keys(this.requiredArray).length,
              n =
                null !==
                document.querySelector(".input-validation-agree input:checked"),
              i =
                document.querySelectorAll(
                  ".input-validation-detail input:checked"
                ).length > 0;
            "/talk-with-us/document/" === location.pathname && e && n && t
              ? (this.submitButton.disabled = !1)
              : (this.submitButton.disabled = !(e && n && i && t));
          }
          reloadReCaptcha() {
            const t = document.querySelector(".g-recaptcha");
            t &&
              "undefined" != typeof grecaptcha &&
              grecaptcha.render(t, {
                sitekey: "6LdB-nsqAAAAAJylTIBQYiZaT4FYlKYRbHiFXjA8",
              });
          }
        }
        class wC {
          constructor() {
            const t = this;
            (this.textPositionData = []),
              (this.bioData = []),
              (this.delayTime = 500),
              (this.world = document.getElementById("world")),
              (this.mainArea = document.getElementsByClassName("main-area")[0]),
              (this.container =
                document.getElementsByClassName("main_container")[0]),
              (this.modal = document.getElementsByClassName(
                "content__member_modal"
              )[0]),
              (this.menu_btn =
                document.getElementsByClassName("menu-button")[0]),
              (this.modalCont = this.modal.children[1]),
              (this.member = document.getElementsByClassName("member")),
              (this.nop = this.member.length - 1),
              this.bioNo,
              (this.addNo = Number(0)),
              (this.active = "modal-active"),
              this.mainArea.addEventListener("click", function (e) {
                t.activeJudge(e.target);
              });
          }
          activeJudge(t) {
            if (!0 !== this.container.classList.contains(this.active))
              (t = t.closest(".member")),
                (this.bioNo = t.id),
                t && this.modalOpen();
            else if (t.closest(".arrow")) {
              t.closest("#prev") ? (this.addNo = -1) : (this.addNo = 1);
              for (let t = 1; t < this.modalCont.childElementCount; t++)
                (this.modalCont.children[t].style.opacity = 0),
                  (this.modalCont.children[t].style.transitionDuration =
                    "0.1s");
              this.arwBtn();
            } else
              (t.closest(".btn__close") ||
                t.closest(".content__member_modal_bg")) &&
                this.modalClose();
          }
          addCls(t) {
            t.classList.add(this.active);
          }
          rmCls(t) {
            t.classList.remove(this.active);
          }
          modalOpen() {
            this.setModal(),
              this.addCls(this.container),
              this.addCls(this.modal),
              (this.menu_btn.style.opacity = "0");
          }
          arwBtn() {
            (this.bioNo = Number(this.bioNo) + Number(this.addNo)),
              this.bioNo < 0
                ? (this.bioNo = this.nop)
                : this.bioNo > this.nop && (this.bioNo = 0),
              setTimeout(() => {
                this.setModal();
              }, 100);
          }
          modalClose() {
            this.rmCls(this.container),
              this.rmCls(this.modal),
              (this.menu_btn.style.opacity = "");
          }
          getData() {
            const t = this.member[this.bioNo];
            (this.textPositionData = []),
              (this.bioData = []),
              t.querySelectorAll(".position__item").forEach((t) => {
                this.textPositionData.push(t.innerText);
              }),
              this.bioData.push(
                t.children[0].children[0].children[0].getAttribute("src"),
                this.textPositionData.join(", "),
                t.children[2].innerText,
                t.children[3].innerHTML
              );
          }
          setModal() {
            this.getData();
            for (let t = 1; t < this.modalCont.childElementCount; t++)
              1 == t
                ? ((this.modalCont.children[t].firstChild.src =
                    this.bioData[0]),
                  (this.modalCont.children[t].firstChild.alt = this.bioData[2]))
                : (this.modalCont.children[t].innerHTML = this.bioData[t - 1]),
                setTimeout(() => {
                  (this.modalCont.children[t].style.opacity = 1),
                    (this.modalCont.children[t].style.transitionDuration =
                      "0.5s");
                }, this.delayTime);
          }
        }
        e().use(r()),
          e().use(o()),
          e().hooks.beforeEnter((t) => {
            !(function (t) {
              const e = document.head,
                n = t.next.html.match(/<head[^>]*>([\s\S.]*)<\/head>/i)[0],
                i = document.createElement("head");
              i.innerHTML = n;
              const r = [
                "meta[name='keywords']",
                "meta[name='description']",
                "meta[property^='fb']",
                "meta[property^='og']",
                "meta[name^='twitter']",
                "meta[name='robots']",
                "meta[itemprop]",
                "link[itemprop]",
                "link[rel='prev']",
                "link[rel='next']",
                "link[rel='canonical']",
              ].join(",");
              e.querySelectorAll(r).forEach((t) => {
                e.removeChild(t);
              }),
                i.querySelectorAll(r).forEach((t) => {
                  e.appendChild(t);
                });
            })(t);
          }),
          e().hooks.after(() => {
            "function" == typeof ga &&
              (ga("set", "page", window.location.pathname),
              ga("send", "pageview")),
              "function" == typeof gtag &&
                gtag("config", window.GA_MEASUREMENT_ID, {
                  page_path: window.location.pathname,
                });
          });
        class EC {
          constructor() {
            (this.controller = new fR()),
              (this.resize = this.resize.bind(this)),
              (this.update = this.update.bind(this)),
              (this.links = [...document.querySelectorAll("a[href]")]);
          }
          resize() {
            this.controller.resize();
          }
          update() {
            this.controller.update();
          }
          leave() {
            this.controller.pause();
          }
          enter() {
            this.controller.play();
          }
          beforeLeave() {}
          beforeEnter() {}
          load() {
            return new Promise(async (t) => {
              await this.controller.load(), t();
            });
          }
          loaded() {
            this.barbaInit();
          }
          init() {
            return (
              this.eventDelete(),
              new Promise(async (t) => {
                await this.controller.init(), t();
              })
            );
          }
          eventDelete() {
            this.links.forEach((t) => {
              t.addEventListener(
                "click",
                (t) => {
                  if (t.currentTarget.href === window.location.href)
                    return t.preventDefault(), void t.stopPropagation();
                },
                !1
              );
            }),
              e().hooks.enter(() => {
                window.scrollTo(0, 0);
              });
          }
          barbaInit() {
            e().init({
              sync: !0,
              debug: !1,
              preventRunning: !1,
              timeout: 5e3,
              logLevel: 0,
              prevent: function (t) {
                if (t.el.classList.contains("no-barba")) return !0;
                if (
                  /\.(xlsx?|docx?|pptx?|pdf|jpe?g|png|gif|svg)/.test(
                    t.el.href.toLowerCase()
                  )
                )
                  return t.el.setAttribute("target", "_blank"), !0;
                var e = location.protocol + "//" + location.host;
                return t.el.href.startsWith(e)
                  ? void 0
                  : (t.el.setAttribute("target", "_blank"), !1);
              },
              views: [
                {
                  namespace: "index",
                  afterEnter(t) {
                    document
                      .querySelectorAll("[data-js-splide-btn-carousel]")
                      .forEach((t) => {
                        new Ya(t, !0, "0").init();
                      });
                    const e = document.querySelectorAll(
                        "[data-js-cursor-stalker-static-area]"
                      ),
                      n = document.querySelector(
                        "[data-js-cursor-stalker-static]"
                      );
                    e.forEach((t) => {
                      new vR(t, n).init();
                    });
                  },
                },
                {
                  namespace: "about-us",
                  afterEnter(t) {
                    document
                      .querySelectorAll("[data-js-lazy-scroll-init]")
                      .forEach((t) => {
                        t.classList.add("-in");
                      });
                    const e = document.querySelector(
                        "[data-js-video-fixed-sec1]"
                      ),
                      n = document.querySelector("[data-js-video-fixed-sec2]");
                    new _R(e, n).init();
                    document
                      .querySelectorAll("[data-js-splide-btn-carousel]")
                      .forEach((t) => {
                        new Ya(t, !1, "35px").init();
                      });
                    const i = document.querySelector(
                      ".__child-carousel[data-js-splide-auto-carousel]"
                    );
                    new Xa(i, "0", "100", "ltr", !1).init();
                    document
                      .querySelectorAll("[data-js-splide-auto-random-carousel]")
                      .forEach((t) => {
                        new SR(t).init();
                      });
                    const r = document.querySelectorAll(
                      "[data-js-bg-transition-scroll]"
                    );
                    new dh(r).init();
                    const s = document.querySelectorAll("[data-js-side-menu]");
                    new MR(s).init();
                    document
                      .querySelectorAll("[data-js-anchor-scroll]")
                      .forEach((t) => {
                        new ph(t).init();
                      });
                  },
                },
                {
                  namespace: "service",
                  afterEnter(t) {
                    const e = document.querySelectorAll(
                      "[data-js-bg-transition-scroll]"
                    );
                    new dh(e).init();
                    const n = document.querySelectorAll("[data-js-side-menu]");
                    new MR(n).init();
                    document
                      .querySelectorAll("[data-js-anchor-scroll]")
                      .forEach((t) => {
                        new ph(t).init();
                      });
                  },
                },
                {
                  namespace: "projects",
                  afterEnter(t) {
                    document
                      .querySelectorAll("[data-js-lazy-scroll-init]")
                      .forEach((t) => {
                        t.classList.add("-in");
                      });
                    const e = document.querySelectorAll(
                        "[data-js-cursor-stalker-static-area]"
                      ),
                      n = document.querySelector(
                        "[data-js-cursor-stalker-static]"
                      );
                    e.forEach((t) => {
                      new vR(t, n).init();
                    });
                    document.querySelectorAll("video").forEach(function (t) {
                      (t.muted = !0), t.play().catch(function (t) {});
                    });
                  },
                },
                {
                  namespace: "topics",
                  afterEnter(t) {
                    document
                      .querySelectorAll("[data-js-lazy-scroll-init]")
                      .forEach((t) => {
                        t.classList.add("-in");
                      });
                    const e = document.querySelectorAll(
                        "[data-js-cursor-stalker-static-area]"
                      ),
                      n = document.querySelector(
                        "[data-js-cursor-stalker-static]"
                      );
                    e.forEach((t) => {
                      new vR(t, n).init();
                    });
                  },
                },
                {
                  namespace: "team",
                  afterEnter(t) {
                    new wC();
                    const e = document.querySelectorAll(
                        "[data-js-cursor-stalker-static-area]"
                      ),
                      n = document.querySelector(
                        "[data-js-cursor-stalker-static]"
                      );
                    e.forEach((t) => {
                      new vR(t, n).init();
                    });
                  },
                },
                {
                  namespace: "company",
                  afterEnter(t) {
                    document
                      .querySelectorAll("[data-js-lazy-scroll-init]")
                      .forEach((t) => {
                        t.classList.add("-in");
                      });
                    const e = document.querySelectorAll(
                      "[data-js-bg-transition-scroll]"
                    );
                    new dh(e).init();
                    const n = document.querySelectorAll("[data-js-side-menu]");
                    new MR(n).init();
                    document
                      .querySelectorAll("[data-js-anchor-scroll]")
                      .forEach((t) => {
                        new ph(t).init();
                      });
                    document
                      .querySelectorAll("[data-js-splide-auto-random-carousel]")
                      .forEach((t) => {
                        new SR(t).init();
                      });
                  },
                },
                {
                  namespace: "talk-with-us",
                  afterEnter(t) {
                    document
                      .querySelector(".footer-contact-carousel-area")
                      .classList.add("is-hide"),
                      document
                        .querySelector(".contact-carousel-area")
                        .classList.add("is-hide");
                    document
                      .querySelectorAll(".input-item--radio")
                      .forEach((t) => {
                        t.addEventListener("click", function () {
                          document
                            .querySelector(".input-item--radio.--checked")
                            .classList.remove("--checked"),
                            t.classList.add("--checked");
                        });
                      }),
                      "/talk-with-us/document/" != location.pathname &&
                        "/talk-with-us/complete/" != location.pathname &&
                        xC(),
                      "/talk-with-us/complete/" != location.pathname
                        ? new bC()
                        : (document.getElementById("world").style.opacity =
                            "1");
                  },
                },
              ],
              transitions: [
                {
                  once: (t) => {},
                  afterOnce: (t) => {
                    this.namespace = t.next.namespace;
                    const e = document.querySelector(
                        "[data-js-common-ui-toggle-01]"
                      ),
                      n = document.querySelector(
                        "[data-js-common-ui-toggle-02]"
                      );
                    new fh(e, n).init(),
                      "index" != t.next.namespace
                        ? document
                            .querySelector(".lConfigMenu")
                            .classList.add("is-hide")
                        : document
                            .querySelector(".lConfigMenu")
                            .classList.remove("is-hide");
                    const i = document.querySelector(
                      ".footer-contact-carousel-area"
                    );
                    var r = this.controller;
                    new IntersectionObserver(
                      function (e) {
                        e.forEach(function (e) {
                          e.isIntersecting
                            ? ((document.getElementById("world").style.opacity =
                                "1"),
                              r.play())
                            : "index" != t.next.namespace &&
                              "/talk-with-us/complete/" != location.pathname &&
                              ((document.getElementById("world").style.opacity =
                                "0"),
                              r.pause());
                        });
                      },
                      {
                        root: null,
                        rootMargin: "0px",
                        threshold: 0,
                      }
                    ).observe(i);
                    const s = document.querySelectorAll(
                      "[data-js-lazy-scroll]"
                    );
                    new uh(s).init();
                    const o = document.querySelector("[data-js-menu-button]");
                    new $i(o).init();
                    const a = document.querySelector(
                      "[data-js-loading-animation]"
                    );
                    new Ki(a).init();
                    document
                      .querySelectorAll("[data-js-splide-auto-carousel]")
                      .forEach((t) => {
                        new Xa(t, "0", "100", "ltr", !1).init();
                      });
                    document
                      .querySelectorAll("[data-js-color-thief-image]")
                      .forEach((t) => {
                        new hh(t).init();
                      });
                  },
                  before: (t) => {
                    this.leave();
                  },
                  beforeLeave: (t) => (
                    this.enter(),
                    new Promise(function (t, e) {
                      document
                        .querySelectorAll("[data-js-page-transition]")
                        .forEach((t) => {
                          t.classList.add("is-close");
                        }),
                        setTimeout(function () {
                          t();
                        }, 1e3);
                    })
                  ),
                  leave(t) {
                    new fh().refresh();
                  },
                  beforeEnter: (t) => {
                    new fh().refresh();
                    const e = document.querySelector(
                        "[data-js-common-ui-toggle-01]"
                      ),
                      n = document.querySelector(
                        "[data-js-common-ui-toggle-02]"
                      );
                    new fh(e, n).init();
                    const i = document.querySelector(
                        ".footer-contact-carousel-area"
                      ),
                      r = document.getElementById("world"),
                      s = document.querySelector(".lConfigMenu"),
                      o = document.querySelector(".contact-carousel-area");
                    "talk-with-us" != t.next.namespace
                      ? (o.classList.remove("is-hide"),
                        i.classList.remove("is-hide"))
                      : (o.classList.add("is-hide"),
                        i.classList.add("is-hide")),
                      "index" != t.next.namespace
                        ? ((r.style.opacity = "0"), s.classList.add("is-hide"))
                        : (s.classList.remove("is-hide"),
                          (r.style.opacity = "1"));
                    const a = document.querySelectorAll(
                      "[data-js-lazy-scroll]"
                    );
                    new uh(a).init();
                    document
                      .querySelectorAll("[data-js-color-thief-image]")
                      .forEach((t) => {
                        new hh(t).init();
                      });
                    const l = document.querySelector(
                      "[data-js-loading-animation]"
                    );
                    new Ki(l).init(),
                      document
                        .querySelectorAll("[data-js-page-transition]")
                        .forEach((t) => {
                          t.classList.remove("is-close");
                        });
                  },
                  enter: (t) => {},
                  after: (t) => {
                    document
                      .querySelectorAll("[data-js-color-thief-image]")
                      .forEach((t) => {
                        new hh(t).init();
                      });
                    const e = document.querySelectorAll(
                      "[data-js-lazy-scroll]"
                    );
                    new uh(e).init();
                  },
                  afterEnter: (t) => {},
                },
              ],
            });
          }
        }
        window.addEventListener("load", async (t) => {
          e().hooks.afterEnter((t) => {
            if ("index" === t.next.namespace) {
              const t = document.querySelector("[data-js-modal-button]");
              new yR(t).init();
              const e = document.querySelector("[data-js-movie-toggle-scale]");
              new mR(e).init();
              const n = document.querySelector("[data-js-cursor-stalker-area]"),
                i = document.querySelector("[data-js-cursor-stalker]");
              new gR(n, i).init();
            }
          });
        }),
          window.addEventListener("DOMContentLoaded", async (t) => {
            const e = new EC();
            window.addEventListener("resize", e.resize, {
              passive: !0,
            }),
              Yi.ticker.add(e.update),
              Yi.ticker.fps(60),
              await e.load(),
              e.loaded();
          });
      })();
  })();
  </script>
</body>
</html>
